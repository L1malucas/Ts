{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem-vind@ ao Meu Reposit\u00f3rio de Estudos Este projeto \u00e9 o meu centro de conhecimento pessoal, um espa\u00e7o dedicado a registrar e aprofundar meus estudos em diversas tecnologias essenciais para o desenvolvimento de software moderno. O objetivo \u00e9 criar uma base de consulta r\u00e1pida, com exemplos pr\u00e1ticos e anota\u00e7\u00f5es detalhadas sobre os desafios e solu\u00e7\u00f5es encontrados no dia a dia. Tecnologias em Foco Atualmente, o reposit\u00f3rio est\u00e1 organizado nas seguintes se\u00e7\u00f5es: TypeScript Nesta se\u00e7\u00e3o, voc\u00ea encontrar\u00e1 um plano de estudos detalhado de 30 dias, focado em levar o conhecimento do n\u00edvel b\u00e1sico ao intermedi\u00e1rio. Os t\u00f3picos incluem: Fundamentos S\u00f3lidos : Classes, o contexto do this , e a elimina\u00e7\u00e3o progressiva do any . Conceitos Avan\u00e7ados : Generics, decorators, conditional types e utility types. Padr\u00f5es de Arquitetura : Implementa\u00e7\u00e3o de services, error handling type-safe e integra\u00e7\u00e3o com bibliotecas como React Hook Form. O objetivo \u00e9 construir a capacidade de arquitetar aplica\u00e7\u00f5es robustas, seguras e escal\u00e1veis. Python (em breve) Esta se\u00e7\u00e3o ser\u00e1 dedicada aos meus estudos em Python, cobrindo desde a sintaxe fundamental at\u00e9 t\u00f3picos avan\u00e7ados como desenvolvimento web com Django/Flask, an\u00e1lise de dados com Pandas e automa\u00e7\u00e3o de tarefas. Shell Script (em breve) Aqui, vou documentar minhas explora\u00e7\u00f5es em Shell Script, com foco em automa\u00e7\u00e3o de tarefas, manipula\u00e7\u00e3o de arquivos e otimiza\u00e7\u00e3o de workflows no ambiente de linha de comando. Sinta-se \u00e0 vontade para navegar pelo conte\u00fado. A estrutura foi pensada para ser intuitiva e facilitar a consulta dos t\u00f3picos de interesse.","title":"In\u00edcio"},{"location":"#bem-vind-ao-meu-repositorio-de-estudos","text":"Este projeto \u00e9 o meu centro de conhecimento pessoal, um espa\u00e7o dedicado a registrar e aprofundar meus estudos em diversas tecnologias essenciais para o desenvolvimento de software moderno. O objetivo \u00e9 criar uma base de consulta r\u00e1pida, com exemplos pr\u00e1ticos e anota\u00e7\u00f5es detalhadas sobre os desafios e solu\u00e7\u00f5es encontrados no dia a dia.","title":"Bem-vind@ ao Meu Reposit\u00f3rio de Estudos"},{"location":"#tecnologias-em-foco","text":"Atualmente, o reposit\u00f3rio est\u00e1 organizado nas seguintes se\u00e7\u00f5es:","title":"Tecnologias em Foco"},{"location":"#typescript","text":"Nesta se\u00e7\u00e3o, voc\u00ea encontrar\u00e1 um plano de estudos detalhado de 30 dias, focado em levar o conhecimento do n\u00edvel b\u00e1sico ao intermedi\u00e1rio. Os t\u00f3picos incluem: Fundamentos S\u00f3lidos : Classes, o contexto do this , e a elimina\u00e7\u00e3o progressiva do any . Conceitos Avan\u00e7ados : Generics, decorators, conditional types e utility types. Padr\u00f5es de Arquitetura : Implementa\u00e7\u00e3o de services, error handling type-safe e integra\u00e7\u00e3o com bibliotecas como React Hook Form. O objetivo \u00e9 construir a capacidade de arquitetar aplica\u00e7\u00f5es robustas, seguras e escal\u00e1veis.","title":"TypeScript"},{"location":"#python-em-breve","text":"Esta se\u00e7\u00e3o ser\u00e1 dedicada aos meus estudos em Python, cobrindo desde a sintaxe fundamental at\u00e9 t\u00f3picos avan\u00e7ados como desenvolvimento web com Django/Flask, an\u00e1lise de dados com Pandas e automa\u00e7\u00e3o de tarefas.","title":"Python (em breve)"},{"location":"#shell-script-em-breve","text":"Aqui, vou documentar minhas explora\u00e7\u00f5es em Shell Script, com foco em automa\u00e7\u00e3o de tarefas, manipula\u00e7\u00e3o de arquivos e otimiza\u00e7\u00e3o de workflows no ambiente de linha de comando. Sinta-se \u00e0 vontade para navegar pelo conte\u00fado. A estrutura foi pensada para ser intuitiva e facilitar a consulta dos t\u00f3picos de interesse.","title":"Shell Script (em breve)"},{"location":"Ts/Plano%20de%20Estudos/","text":"Plano de Estudos TypeScript - 30 Dias Do Iniciante ao Intermedi\u00e1rio Estrutura do Plano Dura\u00e7\u00e3o : 30 dias (1h30 por dia) Tempo por sess\u00e3o : 35min teoria + 45min pr\u00e1tica + 10min documenta\u00e7\u00e3o Metodologia : Progress\u00e3o incremental com projetos pr\u00e1ticos Objetivo : Dominar TypeScript intermedi\u00e1rio com foco em classes, tipagens robustas e patterns arquiteturais SEMANA 1: Fundamentos Cr\u00edticos e Classes Dia 1: Classes Fundamentais Teoria : Constructor, properties, methods, access modifiers Pr\u00e1tica : Criar classe User com valida\u00e7\u00f5es Exerc\u00edcio : // Implementar classe com constructor overloading class DatabaseConnection { constructor(url: string); constructor(host: string, port: number, database: string); } Documenta\u00e7\u00e3o : Classes - TypeScript Handbook Dia 2: Context do this - Parte 1 Teoria : this binding, arrow functions vs regular functions Pr\u00e1tica : Implementar m\u00e9todo de chaining type-safe Exerc\u00edcio : Resolver problemas de this context em callbacks class QueryBuilder { where(condition: string): this { /* */ } orderBy(field: string): this { /* */ } } Documenta\u00e7\u00e3o : This Types Dia 3: Eliminando any - Parte 1 Teoria : unknown vs any , type assertions seguras Pr\u00e1tica : Refatorar c\u00f3digo com any para tipagens seguras Exerc\u00edcio : Implementar fun\u00e7\u00e3o de parsing de JSON type-safe function safeJsonParse<T>(json: string): T | Error { // Implementar sem usar any } Documenta\u00e7\u00e3o : Unknown Type Dia 4: Type Guards e Narrowing Teoria : typeof , instanceof , custom type guards Pr\u00e1tica : Criar type guards para valida\u00e7\u00e3o de dados da API Exerc\u00edcio : Implementar type guards para discriminated unions type ApiResponse = SuccessResponse | ErrorResponse; function isSuccessResponse(response: ApiResponse): response is SuccessResponse { // Implementar } Documenta\u00e7\u00e3o : Narrowing Dia 5: Utility Types Nativos - Record e B\u00e1sicos Teoria : Record<K,V> , Pick , Omit , Partial , Required Pr\u00e1tica : Criar sistema de configura\u00e7\u00e3o type-safe Exerc\u00edcio : Implementar mapeamento como seu exemplo: const tooltipContent: Record<string, DictionaryPath> = { [columnType.YIELD]: 'min_fare.table.tooltips.yield', }; Documenta\u00e7\u00e3o : Utility Types Dia 6: Template Literal Types Teoria : Template literals, key remapping Pr\u00e1tica : Criar sistema de rotas type-safe Exerc\u00edcio : Implementar auto-complete para caminhos de API type ApiRoutes = `/api/${'users' | 'posts'}/${string}`; Documenta\u00e7\u00e3o : Template Literal Types Dia 7: Project Mini #1 Pr\u00e1tica Intensiva : Implementar classe BaseRepository combinando todos os conceitos - Classes com generics - Type guards para valida\u00e7\u00e3o - Methods com this return para chaining - Utility types para opera\u00e7\u00f5es CRUD SEMANA 2: Classes Avan\u00e7adas e Generics Dia 8: Heran\u00e7a e Abstract Classes Teoria : extends , super , abstract methods e properties Pr\u00e1tica : Implementar hierarquia de classes para diferentes tipos de usu\u00e1rios Exerc\u00edcio : Criar abstract class similar ao seu GetTableDataService abstract class BaseService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; } Documenta\u00e7\u00e3o : Abstract Classes Dia 9: Generics em Classes Teoria : Generic constraints, multiple type parameters, default types Pr\u00e1tica : Criar sistema de cache gen\u00e9rico type-safe Exerc\u00edcio : Implementar DataService<T extends BaseEntity, K extends keyof T> Documenta\u00e7\u00e3o : Generics Dia 10: Context this - Parte 2 Avan\u00e7ada Teoria : this parameters, ThisType<T> , this em generics Pr\u00e1tica : Implementar fluent API com tipagem correta do this Exerc\u00edcio : Criar builder pattern type-safe class FormBuilder<T> { field<K extends keyof T>(name: K): FormBuilder<T> { /* */ } build(): Form<T> { /* */ } } Documenta\u00e7\u00e3o : This Parameters Dia 11: Decorators Teoria : Method decorators, property decorators, metadata Pr\u00e1tica : Criar sistema de valida\u00e7\u00e3o com decorators Exerc\u00edcio : Implementar @validate , @cache , @log decorators Documenta\u00e7\u00e3o : Decorators Dia 12: Eliminando any - Parte 2 Teoria : never type, exhaustive checking, branded types Pr\u00e1tica : Refatorar APIs externas sem tipagem Exerc\u00edcio : Criar wrapper type-safe para biblioteca sem tipos // Converter isto para type-safe: declare const untypedLibrary: any; Documenta\u00e7\u00e3o : Never Type Dia 13: Conditional Types Teoria : T extends U ? X : Y , infer keyword Pr\u00e1tica : Criar utility types customizados Exerc\u00edcio : Implementar DeepPartial<T> , NonNullable<T> type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]>; } : T; Documenta\u00e7\u00e3o : Conditional Types Dia 14: Project Mini #2 Pr\u00e1tica Intensiva : Sistema de autentica\u00e7\u00e3o completo - Abstract classes para diferentes providers - Generics para diferentes tipos de usu\u00e1rio - Decorators para autoriza\u00e7\u00e3o - Conditional types para permiss\u00f5es SEMANA 3: Patterns Arquiteturais e Function Types Dia 15: Function Overloading Teoria : Multiple signatures, conditional returns Pr\u00e1tica : Criar API com diferentes assinaturas baseadas em par\u00e2metros Exerc\u00edcio : Implementar fun\u00e7\u00e3o que retorna tipos diferentes baseado no input function getData(id: string): Promise<User>; function getData(filter: Filter): Promise<User[]>; Documenta\u00e7\u00e3o : Function Overloads Dia 16: Mapped Types Avan\u00e7ados Teoria : Key remapping, filtering, template literals em mapped types Pr\u00e1tica : Criar sistema de forms din\u00e2mico Exerc\u00edcio : Implementar FormConfig<T> que gera configura\u00e7\u00e3o baseada no tipo type FormConfig<T> = { [K in keyof T as `${string & K}Config`]: FieldConfig<T[K]> } Documenta\u00e7\u00e3o : Mapped Types Dia 17: Service Layer Architecture Teoria : Dependency injection, interface segregation Pr\u00e1tica : Recriar e melhorar seu GetTableDataService Exerc\u00edcio : Implementar sistema completo de services com DI abstract class GetTableDataService<TResponse, TParams extends Record<string, any>> { // Sua implementa\u00e7\u00e3o + melhorias } Documenta\u00e7\u00e3o : Interfaces Dia 18: Error Handling Type-Safe Teoria : Result pattern, discriminated unions para errors Pr\u00e1tica : Implementar sistema de error handling sem exceptions Exerc\u00edcio : Criar Result<T, E> pattern type Result<T, E = Error> = Success<T> | Failure<E>; Documenta\u00e7\u00e3o : Union Types Dia 19: Advanced Record Patterns Teoria : Record com template literals, const assertions Pr\u00e1tica : Criar sistema de internacionaliza\u00e7\u00e3o type-safe Exerc\u00edcio : Implementar dictionary pattern como seu exemplo const tooltipContent: Record<ColumnType, DictionaryPath> = { // Implementar com type safety completo } as const; Documenta\u00e7\u00e3o : Const Assertions Dia 20: Utility Types Avan\u00e7ados Teoria : ReturnType , Parameters , ConstructorParameters , InstanceType Pr\u00e1tica : Criar meta-programming utilities Exerc\u00edcio : Implementar factory pattern type-safe type ServiceFactory<T> = { create(...args: ConstructorParameters<T>): InstanceType<T> } Documenta\u00e7\u00e3o : Advanced Utility Types Dia 21: Project Mini #3 Pr\u00e1tica Intensiva : Sistema de HTTP client type-safe - Service layer com error handling - Function overloading para diferentes m\u00e9todos - Generic constraints para request/response - Record patterns para configura\u00e7\u00e3o SEMANA 4: Integra\u00e7\u00e3o e Refinamento Dia 22: Form Integration (React Hook Form) Teoria : Integration com bibliotecas externas, module augmentation Pr\u00e1tica : Implementar tipagens como seu exemplo RenderMinFareForm Exerc\u00edcio : Criar form handler completamente tipado export type RenderMinFareForm = { control: Control<MinFareFormValue>; errors: FieldErrors<MinFareFormValue>; setValue: UseFormSetValue<MinFareFormValue>; clearErrors: UseFormClearErrors<MinFareFormValue>; }; Documenta\u00e7\u00e3o : Module Augmentation Dia 23: State Management Type-Safe Teoria : Store patterns, action creators, selectors tipados Pr\u00e1tica : Implementar store pattern com TypeScript Exerc\u00edcio : Criar Redux-like store completamente tipado Documenta\u00e7\u00e3o : Literal Types Dia 24: Module System e Path Mapping Teoria : Barrel exports, path mapping, declaration files Pr\u00e1tica : Organizar arquitetura de m\u00f3dulos como nos seus exemplos Exerc\u00edcio : Configurar sistema de imports absolutos import { HttpStatusCode } from '@data/protocols/http'; import { UnexpectedError } from '@domain/errors'; Documenta\u00e7\u00e3o : Module Resolution Dia 25: Testing Types Teoria : Type-safe mocks, testing utilities Pr\u00e1tica : Criar mocks tipados para seus services Exerc\u00edcio : Implementar mock factory type-safe Documenta\u00e7\u00e3o : Testing Dia 26: Performance e Optimization Teoria : Type checking performance, compilation optimization Pr\u00e1tica : Otimizar tipos complexos, evitar deep recursion Exerc\u00edcio : Refatorar tipos pesados para performance Documenta\u00e7\u00e3o : Performance Dia 27: Advanced Patterns Teoria : Builder pattern, Factory pattern, Observer pattern em TS Pr\u00e1tica : Implementar patterns GOF com TypeScript Exerc\u00edcio : Criar sistema de eventos type-safe Documenta\u00e7\u00e3o : Advanced Types Dia 28: Project Final - Setup Planejamento : Arquitetura completa de uma aplica\u00e7\u00e3o - Definir estrutura de pastas - Configurar tipos base - Planejar services e repositories Dia 29: Project Final - Implementation Desenvolvimento : Implementar sistema completo - Services como GetTableDataService - Form handling type-safe - Error handling robusto - Classes e abstra\u00e7\u00f5es Dia 30: Project Final - Review e Refinamento Finaliza\u00e7\u00e3o : Code review, optimizations, documenta\u00e7\u00e3o - Revisar toda implementa\u00e7\u00e3o - Aplicar best practices aprendidas - Documentar patterns utilizados Recursos Adicionais Documenta\u00e7\u00e3o Principal TypeScript Handbook Type Challenges TypeScript Deep Dive Exerc\u00edcios Complementares Cada dia incluir\u00e1 2-3 exerc\u00edcios extras para praticar Mini-projetos semanais para consolidar conhecimento Refatora\u00e7\u00e3o de c\u00f3digo real (como seus exemplos) M\u00e9tricas de Progresso Dia 7 : Capaz de criar classes robustas com type safety Dia 14 : Domina generics e patterns arquiteturais b\u00e1sicos Dia 21 : Implementa services complexos sem any Dia 30 : Arquiteta aplica\u00e7\u00f5es TypeScript intermedi\u00e1rias Este plano foi estruturado para voc\u00ea evoluir naturalmente dos conceitos que j\u00e1 domina (interfaces, types b\u00e1sicos) para implementa\u00e7\u00f5es robustas como as dos seus exemplos, sempre priorizando tipagem segura e elimina\u00e7\u00e3o de any .","title":"Plano de Estudos TypeScript - 30 Dias"},{"location":"Ts/Plano%20de%20Estudos/#plano-de-estudos-typescript-30-dias","text":"","title":"Plano de Estudos TypeScript - 30 Dias"},{"location":"Ts/Plano%20de%20Estudos/#do-iniciante-ao-intermediario","text":"","title":"Do Iniciante ao Intermedi\u00e1rio"},{"location":"Ts/Plano%20de%20Estudos/#estrutura-do-plano","text":"Dura\u00e7\u00e3o : 30 dias (1h30 por dia) Tempo por sess\u00e3o : 35min teoria + 45min pr\u00e1tica + 10min documenta\u00e7\u00e3o Metodologia : Progress\u00e3o incremental com projetos pr\u00e1ticos Objetivo : Dominar TypeScript intermedi\u00e1rio com foco em classes, tipagens robustas e patterns arquiteturais","title":"Estrutura do Plano"},{"location":"Ts/Plano%20de%20Estudos/#semana-1-fundamentos-criticos-e-classes","text":"","title":"SEMANA 1: Fundamentos Cr\u00edticos e Classes"},{"location":"Ts/Plano%20de%20Estudos/#dia-1-classes-fundamentais","text":"Teoria : Constructor, properties, methods, access modifiers Pr\u00e1tica : Criar classe User com valida\u00e7\u00f5es Exerc\u00edcio : // Implementar classe com constructor overloading class DatabaseConnection { constructor(url: string); constructor(host: string, port: number, database: string); } Documenta\u00e7\u00e3o : Classes - TypeScript Handbook","title":"Dia 1: Classes Fundamentais"},{"location":"Ts/Plano%20de%20Estudos/#dia-2-context-do-this-parte-1","text":"Teoria : this binding, arrow functions vs regular functions Pr\u00e1tica : Implementar m\u00e9todo de chaining type-safe Exerc\u00edcio : Resolver problemas de this context em callbacks class QueryBuilder { where(condition: string): this { /* */ } orderBy(field: string): this { /* */ } } Documenta\u00e7\u00e3o : This Types","title":"Dia 2: Context do this - Parte 1"},{"location":"Ts/Plano%20de%20Estudos/#dia-3-eliminando-any-parte-1","text":"Teoria : unknown vs any , type assertions seguras Pr\u00e1tica : Refatorar c\u00f3digo com any para tipagens seguras Exerc\u00edcio : Implementar fun\u00e7\u00e3o de parsing de JSON type-safe function safeJsonParse<T>(json: string): T | Error { // Implementar sem usar any } Documenta\u00e7\u00e3o : Unknown Type","title":"Dia 3: Eliminando any - Parte 1"},{"location":"Ts/Plano%20de%20Estudos/#dia-4-type-guards-e-narrowing","text":"Teoria : typeof , instanceof , custom type guards Pr\u00e1tica : Criar type guards para valida\u00e7\u00e3o de dados da API Exerc\u00edcio : Implementar type guards para discriminated unions type ApiResponse = SuccessResponse | ErrorResponse; function isSuccessResponse(response: ApiResponse): response is SuccessResponse { // Implementar } Documenta\u00e7\u00e3o : Narrowing","title":"Dia 4: Type Guards e Narrowing"},{"location":"Ts/Plano%20de%20Estudos/#dia-5-utility-types-nativos-record-e-basicos","text":"Teoria : Record<K,V> , Pick , Omit , Partial , Required Pr\u00e1tica : Criar sistema de configura\u00e7\u00e3o type-safe Exerc\u00edcio : Implementar mapeamento como seu exemplo: const tooltipContent: Record<string, DictionaryPath> = { [columnType.YIELD]: 'min_fare.table.tooltips.yield', }; Documenta\u00e7\u00e3o : Utility Types","title":"Dia 5: Utility Types Nativos - Record e B\u00e1sicos"},{"location":"Ts/Plano%20de%20Estudos/#dia-6-template-literal-types","text":"Teoria : Template literals, key remapping Pr\u00e1tica : Criar sistema de rotas type-safe Exerc\u00edcio : Implementar auto-complete para caminhos de API type ApiRoutes = `/api/${'users' | 'posts'}/${string}`; Documenta\u00e7\u00e3o : Template Literal Types","title":"Dia 6: Template Literal Types"},{"location":"Ts/Plano%20de%20Estudos/#dia-7-project-mini-1","text":"Pr\u00e1tica Intensiva : Implementar classe BaseRepository combinando todos os conceitos - Classes com generics - Type guards para valida\u00e7\u00e3o - Methods com this return para chaining - Utility types para opera\u00e7\u00f5es CRUD","title":"Dia 7: Project Mini #1"},{"location":"Ts/Plano%20de%20Estudos/#semana-2-classes-avancadas-e-generics","text":"","title":"SEMANA 2: Classes Avan\u00e7adas e Generics"},{"location":"Ts/Plano%20de%20Estudos/#dia-8-heranca-e-abstract-classes","text":"Teoria : extends , super , abstract methods e properties Pr\u00e1tica : Implementar hierarquia de classes para diferentes tipos de usu\u00e1rios Exerc\u00edcio : Criar abstract class similar ao seu GetTableDataService abstract class BaseService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; } Documenta\u00e7\u00e3o : Abstract Classes","title":"Dia 8: Heran\u00e7a e Abstract Classes"},{"location":"Ts/Plano%20de%20Estudos/#dia-9-generics-em-classes","text":"Teoria : Generic constraints, multiple type parameters, default types Pr\u00e1tica : Criar sistema de cache gen\u00e9rico type-safe Exerc\u00edcio : Implementar DataService<T extends BaseEntity, K extends keyof T> Documenta\u00e7\u00e3o : Generics","title":"Dia 9: Generics em Classes"},{"location":"Ts/Plano%20de%20Estudos/#dia-10-context-this-parte-2-avancada","text":"Teoria : this parameters, ThisType<T> , this em generics Pr\u00e1tica : Implementar fluent API com tipagem correta do this Exerc\u00edcio : Criar builder pattern type-safe class FormBuilder<T> { field<K extends keyof T>(name: K): FormBuilder<T> { /* */ } build(): Form<T> { /* */ } } Documenta\u00e7\u00e3o : This Parameters","title":"Dia 10: Context this - Parte 2 Avan\u00e7ada"},{"location":"Ts/Plano%20de%20Estudos/#dia-11-decorators","text":"Teoria : Method decorators, property decorators, metadata Pr\u00e1tica : Criar sistema de valida\u00e7\u00e3o com decorators Exerc\u00edcio : Implementar @validate , @cache , @log decorators Documenta\u00e7\u00e3o : Decorators","title":"Dia 11: Decorators"},{"location":"Ts/Plano%20de%20Estudos/#dia-12-eliminando-any-parte-2","text":"Teoria : never type, exhaustive checking, branded types Pr\u00e1tica : Refatorar APIs externas sem tipagem Exerc\u00edcio : Criar wrapper type-safe para biblioteca sem tipos // Converter isto para type-safe: declare const untypedLibrary: any; Documenta\u00e7\u00e3o : Never Type","title":"Dia 12: Eliminando any - Parte 2"},{"location":"Ts/Plano%20de%20Estudos/#dia-13-conditional-types","text":"Teoria : T extends U ? X : Y , infer keyword Pr\u00e1tica : Criar utility types customizados Exerc\u00edcio : Implementar DeepPartial<T> , NonNullable<T> type DeepPartial<T> = T extends object ? { [P in keyof T]?: DeepPartial<T[P]>; } : T; Documenta\u00e7\u00e3o : Conditional Types","title":"Dia 13: Conditional Types"},{"location":"Ts/Plano%20de%20Estudos/#dia-14-project-mini-2","text":"Pr\u00e1tica Intensiva : Sistema de autentica\u00e7\u00e3o completo - Abstract classes para diferentes providers - Generics para diferentes tipos de usu\u00e1rio - Decorators para autoriza\u00e7\u00e3o - Conditional types para permiss\u00f5es","title":"Dia 14: Project Mini #2"},{"location":"Ts/Plano%20de%20Estudos/#semana-3-patterns-arquiteturais-e-function-types","text":"","title":"SEMANA 3: Patterns Arquiteturais e Function Types"},{"location":"Ts/Plano%20de%20Estudos/#dia-15-function-overloading","text":"Teoria : Multiple signatures, conditional returns Pr\u00e1tica : Criar API com diferentes assinaturas baseadas em par\u00e2metros Exerc\u00edcio : Implementar fun\u00e7\u00e3o que retorna tipos diferentes baseado no input function getData(id: string): Promise<User>; function getData(filter: Filter): Promise<User[]>; Documenta\u00e7\u00e3o : Function Overloads","title":"Dia 15: Function Overloading"},{"location":"Ts/Plano%20de%20Estudos/#dia-16-mapped-types-avancados","text":"Teoria : Key remapping, filtering, template literals em mapped types Pr\u00e1tica : Criar sistema de forms din\u00e2mico Exerc\u00edcio : Implementar FormConfig<T> que gera configura\u00e7\u00e3o baseada no tipo type FormConfig<T> = { [K in keyof T as `${string & K}Config`]: FieldConfig<T[K]> } Documenta\u00e7\u00e3o : Mapped Types","title":"Dia 16: Mapped Types Avan\u00e7ados"},{"location":"Ts/Plano%20de%20Estudos/#dia-17-service-layer-architecture","text":"Teoria : Dependency injection, interface segregation Pr\u00e1tica : Recriar e melhorar seu GetTableDataService Exerc\u00edcio : Implementar sistema completo de services com DI abstract class GetTableDataService<TResponse, TParams extends Record<string, any>> { // Sua implementa\u00e7\u00e3o + melhorias } Documenta\u00e7\u00e3o : Interfaces","title":"Dia 17: Service Layer Architecture"},{"location":"Ts/Plano%20de%20Estudos/#dia-18-error-handling-type-safe","text":"Teoria : Result pattern, discriminated unions para errors Pr\u00e1tica : Implementar sistema de error handling sem exceptions Exerc\u00edcio : Criar Result<T, E> pattern type Result<T, E = Error> = Success<T> | Failure<E>; Documenta\u00e7\u00e3o : Union Types","title":"Dia 18: Error Handling Type-Safe"},{"location":"Ts/Plano%20de%20Estudos/#dia-19-advanced-record-patterns","text":"Teoria : Record com template literals, const assertions Pr\u00e1tica : Criar sistema de internacionaliza\u00e7\u00e3o type-safe Exerc\u00edcio : Implementar dictionary pattern como seu exemplo const tooltipContent: Record<ColumnType, DictionaryPath> = { // Implementar com type safety completo } as const; Documenta\u00e7\u00e3o : Const Assertions","title":"Dia 19: Advanced Record Patterns"},{"location":"Ts/Plano%20de%20Estudos/#dia-20-utility-types-avancados","text":"Teoria : ReturnType , Parameters , ConstructorParameters , InstanceType Pr\u00e1tica : Criar meta-programming utilities Exerc\u00edcio : Implementar factory pattern type-safe type ServiceFactory<T> = { create(...args: ConstructorParameters<T>): InstanceType<T> } Documenta\u00e7\u00e3o : Advanced Utility Types","title":"Dia 20: Utility Types Avan\u00e7ados"},{"location":"Ts/Plano%20de%20Estudos/#dia-21-project-mini-3","text":"Pr\u00e1tica Intensiva : Sistema de HTTP client type-safe - Service layer com error handling - Function overloading para diferentes m\u00e9todos - Generic constraints para request/response - Record patterns para configura\u00e7\u00e3o","title":"Dia 21: Project Mini #3"},{"location":"Ts/Plano%20de%20Estudos/#semana-4-integracao-e-refinamento","text":"","title":"SEMANA 4: Integra\u00e7\u00e3o e Refinamento"},{"location":"Ts/Plano%20de%20Estudos/#dia-22-form-integration-react-hook-form","text":"Teoria : Integration com bibliotecas externas, module augmentation Pr\u00e1tica : Implementar tipagens como seu exemplo RenderMinFareForm Exerc\u00edcio : Criar form handler completamente tipado export type RenderMinFareForm = { control: Control<MinFareFormValue>; errors: FieldErrors<MinFareFormValue>; setValue: UseFormSetValue<MinFareFormValue>; clearErrors: UseFormClearErrors<MinFareFormValue>; }; Documenta\u00e7\u00e3o : Module Augmentation","title":"Dia 22: Form Integration (React Hook Form)"},{"location":"Ts/Plano%20de%20Estudos/#dia-23-state-management-type-safe","text":"Teoria : Store patterns, action creators, selectors tipados Pr\u00e1tica : Implementar store pattern com TypeScript Exerc\u00edcio : Criar Redux-like store completamente tipado Documenta\u00e7\u00e3o : Literal Types","title":"Dia 23: State Management Type-Safe"},{"location":"Ts/Plano%20de%20Estudos/#dia-24-module-system-e-path-mapping","text":"Teoria : Barrel exports, path mapping, declaration files Pr\u00e1tica : Organizar arquitetura de m\u00f3dulos como nos seus exemplos Exerc\u00edcio : Configurar sistema de imports absolutos import { HttpStatusCode } from '@data/protocols/http'; import { UnexpectedError } from '@domain/errors'; Documenta\u00e7\u00e3o : Module Resolution","title":"Dia 24: Module System e Path Mapping"},{"location":"Ts/Plano%20de%20Estudos/#dia-25-testing-types","text":"Teoria : Type-safe mocks, testing utilities Pr\u00e1tica : Criar mocks tipados para seus services Exerc\u00edcio : Implementar mock factory type-safe Documenta\u00e7\u00e3o : Testing","title":"Dia 25: Testing Types"},{"location":"Ts/Plano%20de%20Estudos/#dia-26-performance-e-optimization","text":"Teoria : Type checking performance, compilation optimization Pr\u00e1tica : Otimizar tipos complexos, evitar deep recursion Exerc\u00edcio : Refatorar tipos pesados para performance Documenta\u00e7\u00e3o : Performance","title":"Dia 26: Performance e Optimization"},{"location":"Ts/Plano%20de%20Estudos/#dia-27-advanced-patterns","text":"Teoria : Builder pattern, Factory pattern, Observer pattern em TS Pr\u00e1tica : Implementar patterns GOF com TypeScript Exerc\u00edcio : Criar sistema de eventos type-safe Documenta\u00e7\u00e3o : Advanced Types","title":"Dia 27: Advanced Patterns"},{"location":"Ts/Plano%20de%20Estudos/#dia-28-project-final-setup","text":"Planejamento : Arquitetura completa de uma aplica\u00e7\u00e3o - Definir estrutura de pastas - Configurar tipos base - Planejar services e repositories","title":"Dia 28: Project Final - Setup"},{"location":"Ts/Plano%20de%20Estudos/#dia-29-project-final-implementation","text":"Desenvolvimento : Implementar sistema completo - Services como GetTableDataService - Form handling type-safe - Error handling robusto - Classes e abstra\u00e7\u00f5es","title":"Dia 29: Project Final - Implementation"},{"location":"Ts/Plano%20de%20Estudos/#dia-30-project-final-review-e-refinamento","text":"Finaliza\u00e7\u00e3o : Code review, optimizations, documenta\u00e7\u00e3o - Revisar toda implementa\u00e7\u00e3o - Aplicar best practices aprendidas - Documentar patterns utilizados","title":"Dia 30: Project Final - Review e Refinamento"},{"location":"Ts/Plano%20de%20Estudos/#recursos-adicionais","text":"","title":"Recursos Adicionais"},{"location":"Ts/Plano%20de%20Estudos/#documentacao-principal","text":"TypeScript Handbook Type Challenges TypeScript Deep Dive","title":"Documenta\u00e7\u00e3o Principal"},{"location":"Ts/Plano%20de%20Estudos/#exercicios-complementares","text":"Cada dia incluir\u00e1 2-3 exerc\u00edcios extras para praticar Mini-projetos semanais para consolidar conhecimento Refatora\u00e7\u00e3o de c\u00f3digo real (como seus exemplos)","title":"Exerc\u00edcios Complementares"},{"location":"Ts/Plano%20de%20Estudos/#metricas-de-progresso","text":"Dia 7 : Capaz de criar classes robustas com type safety Dia 14 : Domina generics e patterns arquiteturais b\u00e1sicos Dia 21 : Implementa services complexos sem any Dia 30 : Arquiteta aplica\u00e7\u00f5es TypeScript intermedi\u00e1rias Este plano foi estruturado para voc\u00ea evoluir naturalmente dos conceitos que j\u00e1 domina (interfaces, types b\u00e1sicos) para implementa\u00e7\u00f5es robustas como as dos seus exemplos, sempre priorizando tipagem segura e elimina\u00e7\u00e3o de any .","title":"M\u00e9tricas de Progresso"},{"location":"Ts/Semana1/","text":"Semana 1: Fundamentos Cr\u00edticos e Classes Vis\u00e3o Geral da Semana Nesta primeira semana, nosso objetivo \u00e9 construir uma base s\u00f3lida em TypeScript. Vamos focar em dominar o sistema de classes, entender o comportamento do this e, crucialmente, come\u00e7ar a jornada para eliminar o any do nosso c\u00f3digo, substituindo-o por padr\u00f5es de tipagem seguros e robustos como unknown e type guards. Ao final da semana, voc\u00ea ter\u00e1 as ferramentas para construir componentes encapsulados e reutiliz\u00e1veis. Dia 1: Classes Fundamentais Foco do Dia Construir e entender a estrutura de classes em TypeScript, incluindo como inicializar, controlar o acesso a propriedades e definir o comportamento atrav\u00e9s de m\u00e9todos. Leitura e Teoria (Aprofundada) Classes s\u00e3o um dos pilares da programa\u00e7\u00e3o orientada a objetos. Elas s\u00e3o \"plantas\" para criar objetos. Propriedades (Properties) : S\u00e3o as vari\u00e1veis de uma classe. Elas definem o estado de um objeto. M\u00e9todos (Methods) : S\u00e3o as fun\u00e7\u00f5es de uma classe. Eles definem o comportamento de um objeto. Construtor (Constructor) : Um m\u00e9todo especial para criar e inicializar um objeto. Ele \u00e9 chamado automaticamente quando usamos a palavra-chave new . Modificadores de Acesso (Access Modifiers) : public : (padr\u00e3o) A propriedade ou m\u00e9todo pode ser acessado de qualquer lugar. private : A propriedade ou m\u00e9todo s\u00f3 pode ser acessado de dentro da pr\u00f3pria classe . Isso \u00e9 chamado de encapsulamento e \u00e9 crucial para proteger os dados e esconder a complexidade. protected : Pode ser acessado de dentro da classe e de classes que a herdam ( extends ). Veremos mais sobre heran\u00e7a na Semana 2. readonly : Uma propriedade marcada como readonly s\u00f3 pode receber um valor durante a sua declara\u00e7\u00e3o ou dentro do construtor. Garante imutabilidade ap\u00f3s a cria\u00e7\u00e3o do objeto. Parameter Properties : Um atalho do TypeScript para declarar e inicializar propriedades diretamente nos par\u00e2metros do construtor. Documenta\u00e7\u00e3o Essencial Classes (TypeScript Handbook) Parameter Properties (TypeScript Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Classe B\u00e1sica class Player { // Propriedade p\u00fablica, acess\u00edvel de qualquer lugar health: number = 100; // M\u00e9todo p\u00fablico attack() { console.log(\"O jogador ataca!\"); } } const player1 = new Player(); console.log(player1.health); // 100 player1.attack(); // \"O jogador ataca!\" Exemplo 2: Encapsulamento com private e readonly class BankAccount { public readonly accountNumber: string; private balance: number; constructor(accountNumber: string, initialBalance: number) { this.accountNumber = accountNumber; this.balance = initialBalance; } // M\u00e9todo p\u00fablico para acessar um dado privado de forma controlada public getBalance(): number { // Aqui poder\u00edamos adicionar l\u00f3gica de permiss\u00e3o, por exemplo return this.balance; } // M\u00e9todo p\u00fablico para modificar um dado privado public deposit(amount: number): void { if (amount > 0) { this.balance += amount; } } } const myAccount = new BankAccount(\"12345-6\", 500); // myAccount.balance = 10000; // Erro: 'balance' \u00e9 privado. // myAccount.accountNumber = \"98765-4\"; // Erro: 'accountNumber' \u00e9 readonly. myAccount.deposit(150); console.log(myAccount.getBalance()); // 650 Exemplo 3: Atalho com Parameter Properties class Car { // Declara e inicializa as propriedades diretamente no construtor constructor( public readonly model: string, private year: number ) {} public getCarInfo(): string { return `Carro: ${this.model}, Ano: ${this.year}`; } } const myCar = new Car(\"Fusca\", 1978); console.log(myCar.model); // \"Fusca\" console.log(myCar.getCarInfo()); // \"Carro: Fusca, Ano: 1978\" Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe Rectangle com propriedades width e height (ambas public e do tipo number ). Adicione um m\u00e9todo getArea() que retorna a \u00e1rea do ret\u00e2ngulo ( width * height ). Ver Solu\u00e7\u00e3o class Rectangle { public width: number; public height: number; constructor(width: number, height: number) { this.width = width; this.height = height; } public getArea(): number { return this.width * this.height; } } // Teste const rect = new Rectangle(10, 20); console.log(rect.getArea()); // 200 N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Product com propriedades name (string) e price (number), ambas private . Use parameter properties . Adicione um m\u00e9todo p\u00fablico getPrice() para ler o pre\u00e7o e um m\u00e9todo setPrice(newPrice: number) que s\u00f3 permite a altera\u00e7\u00e3o se o newPrice for maior que zero. Ver Solu\u00e7\u00e3o class Product { constructor( private name: string, private price: number ) {} public getPrice(): number { return this.price; } public setPrice(newPrice: number): void { if (newPrice > 0) { this.price = newPrice; console.log(`O pre\u00e7o de ${this.name} foi atualizado para ${newPrice}.`); } else { console.log(\"Pre\u00e7o inv\u00e1lido. O valor deve ser maior que zero.\"); } } } // Teste const book = new Product(\"O Senhor dos An\u00e9is\", 50); console.log(book.getPrice()); // 50 book.setPrice(65); console.log(book.getPrice()); // 65 book.setPrice(-10); // \"Pre\u00e7o inv\u00e1lido...\" N\u00edvel 3: Avan\u00e7ado Implemente a classe DatabaseConnection que simula o padr\u00e3o de constructor overloading . A classe deve poder ser instanciada de duas formas: 1. new DatabaseConnection(url: string) 2. new DatabaseConnection(host: string, port: number, database: string) O construtor deve ter uma \u00fanica implementa\u00e7\u00e3o que verifica os argumentos recebidos e monta a connectionString interna de acordo. Ver Solu\u00e7\u00e3o class DatabaseConnection { private connectionString: string; // Assinatura de sobrecarga 1 constructor(url: string); // Assinatura de sobrecarga 2 constructor(host: string, port: number, database: string); // Implementa\u00e7\u00e3o real do construtor constructor(arg1: string, arg2?: number, arg3?: string) { // Verifica se os argumentos correspondem \u00e0 segunda assinatura if (typeof arg2 === 'number' && typeof arg3 === 'string') { const host = arg1; const port = arg2; const database = arg3; this.connectionString = `mongodb://${host}:${port}/${database}`; } else { // Caso contr\u00e1rio, trata como a primeira assinatura const url = arg1; this.connectionString = url; } } public connect(): void { console.log(`Conectando a: ${this.connectionString}`); } } // Teste const connFromUrl = new DatabaseConnection('mysql://user:pass@server/db'); connFromUrl.connect(); // \"Conectando a: mysql://user:pass@server/db\" const connFromParts = new DatabaseConnection('localhost', 5432, 'postgres'); connFromParts.connect(); // \"Conectando a: postgresql://localhost:5432/postgres\" Checklist do Dia [ ] Entendi a diferen\u00e7a entre public e private . [ ] Sei por que readonly \u00e9 \u00fatil para imutabilidade. [ ] Usei o atalho de parameter properties . [ ] Implementei o padr\u00e3o de \"overload\" de construtor em TypeScript. Dia 2: Contexto do this - Parte 1 Foco do Dia Entender como o this funciona em JavaScript/TypeScript e como garantir que ele se refira ao contexto correto, especialmente em callbacks e m\u00e9todos encadeados. Leitura e Teoria (Aprofundada) O this \u00e9 uma das fontes mais comuns de bugs em JavaScript. Seu valor \u00e9 determinado por como a fun\u00e7\u00e3o \u00e9 chamada (call-site) , n\u00e3o onde ela \u00e9 definida. Fun\u00e7\u00e3o Regular ( function() {} ou metodo() {} ) : O this \u00e9 din\u00e2mico. Se a fun\u00e7\u00e3o \u00e9 chamada como obj.metodo() , this \u00e9 obj . Se a fun\u00e7\u00e3o \u00e9 simplesmente chamada ( funcao() ), this \u00e9 undefined (em 'strict mode', o padr\u00e3o em m\u00f3dulos e classes) ou o objeto global ( window no browser). Arrow Function ( () => {} ) : O this \u00e9 est\u00e1tico (l\u00e9xico). Ela n\u00e3o possui seu pr\u00f3prio this . Ela \"herda\" o this do escopo onde foi definida . Dentro de um m\u00e9todo de classe definido como arrow function, this sempre se referir\u00e1 \u00e0 inst\u00e2ncia da classe. Documenta\u00e7\u00e3o Essencial O this em JavaScript (MDN) - Essencial para entender a base. This Types (TypeScript Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: O Problema - Perdendo o this class Greeter { prefix = \"Hello, \"; // M\u00e9todo de classe normal greet(name: string) { console.log(this.prefix + name); } } const greeter = new Greeter(); const greetFunction = greeter.greet; // A fun\u00e7\u00e3o \u00e9 extra\u00edda do objeto // greetFunction(\"Mundo\"); // Crash! `this` \u00e9 undefined aqui. Exemplo 2: A Solu\u00e7\u00e3o - Arrow Function como M\u00e9todo class SafeGreeter { prefix = \"Hello, \"; // O m\u00e9todo \u00e9 uma propriedade que cont\u00e9m uma arrow function // A arrow function \"lembra\" do `this` de onde foi criada greet = (name: string) => { console.log(this.prefix + name); } } const safeGreeter = new SafeGreeter(); const safeGreetFunction = safeGreeter.greet; safeGreetFunction(\"Mundo\"); // Funciona! \"Hello, Mundo\" Exemplo 3: Method Chaining com o tipo this class StringBuilder { private parts: string[] = []; add(part: string): this { this.parts.push(part); return this; // Retornar `this` permite o encadeamento } build(): string { return this.parts.join(\"\"); } } const builder = new StringBuilder(); const result = builder.add(\"Hello, \").add(\"World!\").build(); console.log(result); // \"Hello, World!\" Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe Logger com uma propriedade message . Crie um m\u00e9todo printMessage() . Chame este m\u00e9todo dentro de um setTimeout e observe o erro. Em seguida, corrija o problema para que a mensagem seja impressa corretamente ap\u00f3s 1 segundo. Ver Solu\u00e7\u00e3o class Logger { constructor(private message: string = \"Opera\u00e7\u00e3o conclu\u00edda!\") {} // A solu\u00e7\u00e3o \u00e9 definir o m\u00e9todo como uma arrow function printMessage = () => { console.log(this.message); } public schedulePrint(): void { console.log(\"Agendando impress\u00e3o...\"); setTimeout(this.printMessage, 1000); } } // Teste const logger = new Logger(); logger.schedulePrint(); // Ap\u00f3s 1s: \"Opera\u00e7\u00e3o conclu\u00edda!\" N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Calculator com uma propriedade value (number, private, inicia em 0). Crie os m\u00e9todos add(num: number) , subtract(num: number) e multiply(num: number) . Cada um desses m\u00e9todos deve modificar o value e retornar this para permitir o encadeamento de chamadas. Ver Solu\u00e7\u00e3o class Calculator { private value: number = 0; constructor(initialValue: number = 0) { this.value = initialValue; } add(num: number): this { this.value += num; return this; } subtract(num: number): this { this.value -= num; return this; } multiply(num: number): this { this.value *= num; return this; } getResult(): number { return this.value; } } // Teste const calc = new Calculator(10); const result = calc.add(5).subtract(3).multiply(2).getResult(); // (10 + 5 - 3) * 2 = 24 console.log(result); // 24 N\u00edvel 3: Avan\u00e7ado Crie uma classe DOMManager . Ela deve ter um m\u00e9todo createElement(tag: string, text: string) que cria um elemento (simulado por um objeto {tag, text} ) e o armazena em um array private elements . Crie um m\u00e9todo render(containerId: string) que deveria (em um cen\u00e1rio real) adicionar os elementos a um cont\u00eainer do DOM. O m\u00e9todo render deve ser chamado por um objeto externo, simulando um event listener, ent\u00e3o voc\u00ea precisa garantir que o this dentro de render ainda se refira \u00e0 inst\u00e2ncia de DOMManager . Ver Solu\u00e7\u00e3o interface Element { tag: string; text: string; } class DOMManager { private elements: Element[] = []; public createElement(tag: string, text: string): this { this.elements.push({ tag, text }); return this; } // Definido como arrow function para garantir o `this` l\u00e9xico public render = (containerId: string) => { // Em um app real, far\u00edamos: const container = document.getElementById(containerId); console.log(`Renderizando ${this.elements.length} elementos em #${containerId}`); for (const el of this.elements) { console.log(` <${el.tag}>${el.text}</${el.tag}>`); } } } // Teste const manager = new DOMManager(); manager.createElement(\"h1\", \"T\u00edtulo Principal\").createElement(\"p\", \"Este \u00e9 um par\u00e1grafo.\"); // Simulando um sistema de eventos que pega a fun\u00e7\u00e3o e a chama depois const eventSystem = { listeners: {} as Record<string, () => void>, addEventListener: function(eventName: string, callback: () => void) { this.listeners[eventName] = callback; }, trigger: function(eventName: string) { this.listeners[eventName](); } }; // Passamos o m\u00e9todo `render` como callback. Gra\u00e7as \u00e0 arrow function, o `this` funciona. eventSystem.addEventListener(\"renderPage\", () => manager.render(\"app-root\")); eventSystem.trigger(\"renderPage\"); Checklist do Dia [ ] Sei explicar a diferen\u00e7a de this entre function() e () => {} . [ ] Consigo resolver um problema de this perdido em um callback. [ ] Entendi como return this; permite o encadeamento de m\u00e9todos. [ ] Implementei uma classe com uma API fluente. Dia 3: Eliminando any - Parte 1 Foco do Dia Abandonar o any e adotar unknown como a alternativa segura para tipos desconhecidos, for\u00e7ando a verifica\u00e7\u00e3o de tipos antes do uso. Leitura e Teoria (Aprofundada) any : \u00c9 a \"v\u00e1lvula de escape\" do TypeScript. Uma vari\u00e1vel do tipo any desliga completamente a verifica\u00e7\u00e3o de tipos . Voc\u00ea pode chamar qualquer m\u00e9todo, acessar qualquer propriedade, e o compilador n\u00e3o vai reclamar. Isso \u00e9 perigoso e anula o prop\u00f3sito de usar TypeScript. unknown : \u00c9 a alternativa segura. Uma vari\u00e1vel unknown tamb\u00e9m pode receber qualquer valor, mas voc\u00ea n\u00e3o pode fazer nada com ela sem antes provar ao TypeScript qual \u00e9 o seu tipo. Esse processo de prova \u00e9 chamado de narrowing (estreitamento). Caracter\u00edstica any unknown Atribui\u00e7\u00e3o Pode receber qualquer valor Pode receber qualquer valor Opera\u00e7\u00f5es Permite qualquer opera\u00e7\u00e3o N\u00e3o permite nenhuma opera\u00e7\u00e3o Seguran\u00e7a Baixa Alta Necessidade Nenhuma verifica\u00e7\u00e3o Requer verifica\u00e7\u00e3o de tipo Documenta\u00e7\u00e3o Essencial The unknown Type (Handbook) The any Type (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: O Perigo do any let value: any = \"isto \u00e9 uma string\"; // Nenhuma verifica\u00e7\u00e3o do compilador! value.toFixed(2); // Crash em tempo de execu\u00e7\u00e3o: value.toFixed is not a function Exemplo 2: A Seguran\u00e7a do unknown let safeValue: unknown = \"isto \u00e9 uma string\"; // Erro de compila\u00e7\u00e3o! O TS nos protege. // safeValue.toFixed(2); // Object is of type 'unknown'. Exemplo 3: Usando unknown Corretamente com Verifica\u00e7\u00e3o let anotherSafeValue: unknown = 123.456; if (typeof anotherSafeValue === 'number') { // Dentro deste bloco, o TS sabe que anotherSafeValue \u00e9 um n\u00famero console.log(anotherSafeValue.toFixed(2)); // \"123.46\" } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o logString(value: unknown) que verifica se o valor recebido \u00e9 uma string . Se for, ela o imprime no console. Se n\u00e3o for, ela imprime a mensagem \"Valor n\u00e3o \u00e9 uma string\". Ver Solu\u00e7\u00e3o function logString(value: unknown): void { if (typeof value === 'string') { console.log(value); } else { console.log(\"Valor n\u00e3o \u00e9 uma string.\"); } } // Teste logString(\"Ol\u00e1, TypeScript!\"); // \"Ol\u00e1, TypeScript!\" logString(123); // \"Valor n\u00e3o \u00e9 uma string.\" logString({}); // \"Valor n\u00e3o \u00e9 uma string.\" N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o getDouble(value: unknown): number | null que verifica se o valor \u00e9 um number . Se for, a fun\u00e7\u00e3o deve retornar o dobro do valor. Caso contr\u00e1rio, deve retornar null . Ver Solu\u00e7\u00e3o function getDouble(value: unknown): number | null { if (typeof value === 'number') { return value * 2; } return null; } // Teste console.log(getDouble(10)); // 20 console.log(getDouble(\"20\")); // null console.log(getDouble(null)); // null N\u00edvel 3: Avan\u00e7ado Crie uma fun\u00e7\u00e3o safeJsonParse(json: string): unknown | Error . Esta fun\u00e7\u00e3o deve receber uma string JSON, tentar fazer o parse com JSON.parse . Se for bem-sucedido, deve retornar o objeto parseado (como unknown ). Se ocorrer um erro no parse, ela deve capturar a exce\u00e7\u00e3o e retornar um objeto Error . Ver Solu\u00e7\u00e3o function safeJsonParse(json: string): unknown | Error { try { // JSON.parse por padr\u00e3o retorna `any`, mas n\u00f3s o atribu\u00edmos a `unknown` // para for\u00e7ar quem chama a fun\u00e7\u00e3o a verificar o tipo do resultado. const parsed: unknown = JSON.parse(json); return parsed; } catch (e) { if (e instanceof Error) { return e; } return new Error(\"Falha desconhecida ao analisar JSON.\"); } } // Teste const validJson = '{\"name\": \"Lucas\", \"id\": 1}'; const invalidJson = '{'name': \"Lucas\"}'; // JSON malformado const result1 = safeJsonParse(validJson); const result2 = safeJsonParse(invalidJson); if (result1 instanceof Error) { console.error(\"Erro no JSON v\u00e1lido:\", result1.message); } else { console.log(\"Sucesso no JSON v\u00e1lido:\", result1); } if (result2 instanceof Error) { console.error(\"Erro no JSON inv\u00e1lido:\", result2.message); } else { console.log(\"Sucesso no JSON inv\u00e1lido:\", result2); } Checklist do Dia [ ] Entendi por que any \u00e9 perigoso e deve ser evitado. [ ] Sei a diferen\u00e7a fundamental entre any e unknown . [ ] Usei typeof para fazer narrowing de um tipo unknown . [ ] Implementei uma fun\u00e7\u00e3o que lida com dados de tipo desconhecido de forma segura. Dia 4: Type Guards e Narrowing Foco do Dia Aprender as t\u00e9cnicas de narrowing (estreitamento de tipo) para que o TypeScript possa inferir um tipo mais espec\u00edfico dentro de um bloco de c\u00f3digo, e criar seus pr\u00f3prios type guards customizados. Leitura e Teoria (Aprofundada) Narrowing \u00e9 o processo pelo qual o TypeScript remove tipos de uma uni\u00e3o. Se voc\u00ea tem string | number , e o TS prova que \u00e9 string , ele \"estreita\" o tipo para apenas string naquele escopo. T\u00e9cnicas de Narrowing: 1. typeof : Para tipos primitivos ( string , number , boolean , etc.). 2. instanceof : Para verificar se um objeto \u00e9 uma inst\u00e2ncia de uma classe. 3. Truthiness : Verificar se um valor n\u00e3o \u00e9 null , undefined , false , 0 , \"\" . 4. Equality ( === ) : Verificar igualdade com um valor literal. 5. in operator : Verificar se um objeto possui uma propriedade com um certo nome. 6. Discriminated Unions : Um padr\u00e3o poderoso onde voc\u00ea usa uma propriedade literal comum ( kind , type , status ) em v\u00e1rios tipos para ajudar o TypeScript a descobrir qual tipo \u00e9. 7. Custom Type Guards (Type Predicates) : Fun\u00e7\u00f5es que retornam um booleano especial: parametro is Tipo . Se a fun\u00e7\u00e3o retornar true , o TypeScript \"confia\" que o par\u00e2metro \u00e9 daquele Tipo no resto do escopo. Documenta\u00e7\u00e3o Essencial Narrowing (Handbook) Using Type Predicates (Custom Type Guards) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: typeof function padLeft(padding: number | string, input: string): string { if (typeof padding === \"number\") { return \" \".repeat(padding) + input; } return padding + input; } Exemplo 2: instanceof class Cat { meow() { console.log(\"Meow!\"); } } class Dog { bark() { console.log(\"Woof!\"); } } type Pet = Cat | Dog; function makeSound(pet: Pet) { if (pet instanceof Cat) { pet.meow(); // O TS sabe que `pet` \u00e9 um Cat aqui } } Exemplo 3: in operator interface Movie { title: string; duration: number; } interface TVShow { title: string; seasons: number; } type Media = Movie | TVShow; function getMediaTitle(media: Media) { if ('duration' in media) { return `Filme: ${media.title}`; } // O TS sabe que se n\u00e3o tem 'duration', deve ter 'seasons' return `S\u00e9rie: ${media.title}`; } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o formatInput(input: string | string[]) . Se o input for uma string , retorne a pr\u00f3pria string. Se for um array de strings, retorne as strings unidas por um espa\u00e7o. Use o type guard Array.isArray() . Ver Solu\u00e7\u00e3o function formatInput(input: string | string[]): string { if (Array.isArray(input)) { // O TS sabe que `input` \u00e9 string[] aqui return input.join(' '); } // O TS sabe que `input` \u00e9 string aqui return input; } // Teste console.log(formatInput(\"hello\")); // \"hello\" console.log(formatInput([\"hello\", \"world\"])); // \"hello world\" N\u00edvel 2: Intermedi\u00e1rio Defina duas interfaces: Fish com um m\u00e9todo swim() e Bird com um m\u00e9todo fly() . Crie uma fun\u00e7\u00e3o makePetMove(pet: Fish | Bird) . Dentro dela, use um custom type guard isFish(pet): pet is Fish para verificar o tipo do animal e chamar o m\u00e9todo correto ( swim ou fly ). Ver Solu\u00e7\u00e3o interface Fish { swim: () => void; } interface Bird { fly: () => void; } type Animal = Fish | Bird; // Custom type guard function isFish(pet: Animal): pet is Fish { // Se o pet tem a propriedade 'swim', ent\u00e3o ele \u00e9 um Fish. // A asser\u00e7\u00e3o `(pet as Fish)` \u00e9 necess\u00e1ria para checar a propriedade // que pode n\u00e3o existir no tipo Animal. return (pet as Fish).swim !== undefined; } function makePetMove(pet: Animal) { if (isFish(pet)) { pet.swim(); } else { pet.fly(); } } // Teste const nemo: Fish = { swim: () => console.log(\"Nemo est\u00e1 nadando.\") }; const zazu: Bird = { fly: () => console.log(\"Zazu est\u00e1 voando.\") }; makePetMove(nemo); makePetMove(zazu); N\u00edvel 3: Avan\u00e7ado Implemente o padr\u00e3o Discriminated Union . Crie duas interfaces, SuccessResponse e ErrorResponse . Ambas devem ter uma propriedade status , mas com valores literais diferentes ( 'success' e 'error' ). Crie uma fun\u00e7\u00e3o handleApiResponse(response: ApiResponse) que usa a propriedade status para identificar o tipo da resposta e logar os dados ou a mensagem de erro apropriada. Ver Solu\u00e7\u00e3o interface SuccessResponse { status: 'success'; // Propriedade discriminante data: { id: number; name: string }; } interface ErrorResponse { status: 'error'; // Propriedade discriminante error: { code: number; message: string }; } type ApiResponse = SuccessResponse | ErrorResponse; function handleApiResponse(response: ApiResponse) { // Usando um switch na propriedade discriminante switch (response.status) { case 'success': // O TS sabe que `response` \u00e9 SuccessResponse aqui console.log(\"Dados recebidos:\", response.data.name); break; case 'error': // O TS sabe que `response` \u00e9 ErrorResponse aqui console.error(\"Ocorreu um erro:\", response.error.message); break; } } // Teste const success: ApiResponse = { status: 'success', data: { id: 1, name: 'Produto A' } }; const failure: ApiResponse = { status: 'error', error: { code: 404, message: 'Produto n\u00e3o encontrado' } }; handleApiResponse(success); handleApiResponse(failure); Checklist do Dia [ ] Sei usar typeof , instanceof e in para narrowing. [ ] Entendi o padr\u00e3o de Discriminated Unions . [ ] Criei e usei um custom type guard ( is Type ). [ ] Apliquei narrowing para acessar propriedades de tipos em uma uni\u00e3o de forma segura. Dia 5: Utility Types Nativos - Record e B\u00e1sicos Foco do Dia Utilizar os Utility Types nativos do TypeScript para transformar e criar novos tipos a partir de tipos existentes, com foco especial em Record<K,V> . Leitura e Teoria (Aprofundada) Utility Types s\u00e3o ferramentas que ajudam a manipular tipos sem ter que reescrev\u00ea-los. Record<Keys, Type> : Constr\u00f3i um tipo de objeto cujas chaves s\u00e3o Keys e os valores s\u00e3o Type . Perfeito para dicion\u00e1rios ou mapeamentos onde as chaves s\u00e3o de um conjunto conhecido. Partial<Type> : Constr\u00f3i um tipo com todas as propriedades de Type definidas como opcionais . \u00datil para payloads de atualiza\u00e7\u00e3o ( update ). Required<Type> : O oposto de Partial . Torna todas as propriedades obrigat\u00f3rias . Pick<Type, Keys> : Constr\u00f3i um tipo \"pegando\" um conjunto de propriedades Keys de Type . Omit<Type, Keys> : O oposto de Pick . Constr\u00f3i um tipo com todas as propriedades de Type , exceto as Keys . Readonly<Type> : Torna todas as propriedades de Type somente leitura. Documenta\u00e7\u00e3o Essencial Utility Types (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Partial para atualiza\u00e7\u00f5es interface User { name: string; age: number; email: string; } function updateUser(user: User, fieldsToUpdate: Partial<User>) { return { ...user, ...fieldsToUpdate }; } const user1 = { name: 'Lucas', age: 30, email: 'lucas@test.com' }; const updatedUser = updateUser(user1, { age: 31 }); Exemplo 2: Pick para dados p\u00fablicos interface UserWithPassword { id: number; name: string; passwordHash: string; } type PublicUser = Pick<UserWithPassword, 'id' | 'name'>; const publicProfile: PublicUser = { id: 1, name: 'Ana' }; Exemplo 3: Omit para remover dados sens\u00edveis type UserWithoutPassword = Omit<UserWithPassword, 'passwordHash'>; const userToSend: UserWithoutPassword = { id: 2, name: 'Beto' }; Exemplo 4: Record para um dicion\u00e1rio de configura\u00e7\u00f5es type Theme = 'light' | 'dark'; interface ThemeSettings { color: string; background: string; } const themes: Record<Theme, ThemeSettings> = { light: { color: '#000', background: '#fff' }, dark: { color: '#fff', background: '#000' }, }; Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Dada a interface Book { id: number; title: string; author: string; pages: number; } , crie um tipo BookPreview que contenha apenas as propriedades title e author usando um Utility Type. Ver Solu\u00e7\u00e3o interface Book { id: number; title: string; author: string; pages: number; } type BookPreview = Pick<Book, 'title' | 'author'>; // Teste const preview: BookPreview = { title: \"Duna\", author: \"Frank Herbert\" }; N\u00edvel 2: Intermedi\u00e1rio Crie uma interface AppSettings com todas as propriedades opcionais: theme: string , fontSize: number , language: string . Em seguida, crie um tipo RequiredAppSettings que tenha todas essas mesmas propriedades, mas como obrigat\u00f3rias. Por fim, crie uma fun\u00e7\u00e3o applySettings(settings: RequiredAppSettings) . Ver Solu\u00e7\u00e3o interface AppSettings { theme?: string; fontSize?: number; language?: string; } type RequiredAppSettings = Required<AppSettings>; function applySettings(settings: RequiredAppSettings) { console.log(\"Aplicando configura\u00e7\u00f5es:\", settings); } // Teste const mySettings: RequiredAppSettings = { theme: 'dark', fontSize: 14, language: 'pt-BR' }; applySettings(mySettings); // const invalidSettings: RequiredAppSettings = { theme: 'light' }; // Erro: fontSize e language est\u00e3o faltando N\u00edvel 3: Avan\u00e7ado Crie um enum chamado UserRole com os valores ADMIN , EDITOR , e VIEWER . Crie um tipo Permissions que define o que cada papel pode fazer (ex: { canWrite: boolean; canRead: boolean; } ). Use o Utility Type Record para criar um objeto rolePermissions que mapeia cada UserRole para seu respectivo objeto Permissions de forma type-safe. Ver Solu\u00e7\u00e3o enum UserRole { ADMIN = 'admin', EDITOR = 'editor', VIEWER = 'viewer' } interface Permissions { canWrite: boolean; canRead: boolean; canDelete: boolean; } const rolePermissions: Record<UserRole, Permissions> = { [UserRole.ADMIN]: { canWrite: true, canRead: true, canDelete: true }, [UserRole.EDITOR]: { canWrite: true, canRead: true, canDelete: false }, [UserRole.VIEWER]: { canWrite: false, canRead: true, canDelete: false }, }; // Teste function checkPermissions(role: UserRole) { const permissions = rolePermissions[role]; console.log(`Permiss\u00f5es para ${role.toUpperCase()}:`, permissions); } checkPermissions(UserRole.EDITOR); // checkPermissions('guest'); // Erro: Argument of type '\"guest\"' is not assignable to parameter of type 'UserRole'. Checklist do Dia [ ] Entendi o prop\u00f3sito do Record<K, V> . [ ] Usei Record para criar um dicion\u00e1rio type-safe. [ ] Sei a diferen\u00e7a entre Pick e Omit . [ ] Combinei Partial e Required para manipular tipos. Dia 6: Template Literal Types Foco do Dia Criar tipos de string altamente espec\u00edficos e din\u00e2micos usando Template Literals, permitindo valida\u00e7\u00e3o de formatos de string em tempo de compila\u00e7\u00e3o. Leitura e Teoria (Aprofundada) Template Literal Types usam a mesma sintaxe de template strings do JavaScript ( ${} ), mas no n\u00edvel dos tipos. Eles permitem construir novos tipos de string concatenando outros tipos, especialmente uni\u00f5es. Com Unions (o superpoder): type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'; type ApiEndpoint = 'users' | 'products'; // Gera uma uni\u00e3o de todas as 8 combina\u00e7\u00f5es poss\u00edveis: // \"GET /api/users\" | \"POST /api/users\" | ... type ApiRequestSignature = `${HttpMethod} /api/${ApiEndpoint}`; Com Helpers de Manipula\u00e7\u00e3o de String: TypeScript inclui tipos utilit\u00e1rios para manipular strings dentro dos tipos: Uppercase<S> , Lowercase<S> , Capitalize<S> , Uncapitalize<S> . Documenta\u00e7\u00e3o Essencial Template Literal Types (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Concatena\u00e7\u00e3o Simples type World = \"World\"; type Greeting = `Hello ${World}`; const g: Greeting = \"Hello World\"; // V\u00e1lido Exemplo 2: Uni\u00e3o de Tipos type MarginSide = 'top' | 'right' | 'bottom' | 'left'; type MarginProperty = `margin-${MarginSide}`; const m: MarginProperty = \"margin-left\"; // V\u00e1lido Exemplo 3: Capitalize para Nomes de Eventos type EventName = 'click' | 'scroll' | 'focus'; type HandlerName = `on${Capitalize<EventName>}`; const handler: HandlerName = \"onClick\"; // V\u00e1lido Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie um tipo Size ( 'small' | 'medium' | 'large' ) e um tipo Color ( 'red' | 'blue' | 'green' ). Crie um terceiro tipo, TShirtSKU , que combine os dois para formar um identificador de produto, como por exemplo 'small-red' . Ver Solu\u00e7\u00e3o type Size = 'small' | 'medium' | 'large'; type Color = 'red' | 'blue' | 'green'; type TShirtSKU = `${Size}-${Color}`; // Teste const myShirt: TShirtSKU = \"medium-blue\"; const anotherShirt: TShirtSKU = \"large-red\"; // const invalidShirt: TShirtSKU = \"small-yellow\"; // Erro: 'yellow' n\u00e3o \u00e9 uma cor v\u00e1lida N\u00edvel 2: Intermedi\u00e1rio Crie um tipo IconName que represente nomes de \u00edcones no formato icon-[nome] , onde [nome] pode ser user , home , ou settings . Em seguida, crie um tipo IconSize que pode ser 16 , 24 , ou 32 . Finalmente, crie um tipo IconId que combine os dois, no formato icon-[nome]-[tamanho]px . Ver Solu\u00e7\u00e3o type IconName = `icon-${'user' | 'home' | 'settings'}`; type IconSize = 16 | 24 | 32; type IconId = `${IconName}-${IconSize}px`; // Teste const userIcon: IconId = \"icon-user-24px\"; const homeIcon: IconId = \"icon-home-32px\"; // const invalidIcon: IconId = \"icon-settings-20px\"; // Erro: 20 n\u00e3o \u00e9 um tamanho v\u00e1lido N\u00edvel 3: Avan\u00e7ado Crie um tipo ApiRoute que valide os seguintes formatos de rota para uma API RESTful: 1. Listar todos os recursos: /api/[recurso] (ex: /api/users ) 2. Obter um recurso espec\u00edfico: /api/[recurso]/[id] (ex: /api/posts/123 ) Onde [recurso] pode ser users , posts , ou products , e [id] pode ser string ou number . Ver Solu\u00e7\u00e3o type Resource = 'users' | 'posts' | 'products'; type ResourceId = string | number; type ApiRoute = `/api/${Resource}` | `/api/${Resource}/${ResourceId}`; // Teste const listUsers: ApiRoute = '/api/users'; const getPost: ApiRoute = '/api/posts/post-id-abc'; const getProduct: ApiRoute = '/api/products/12345'; // const invalidRoute1: ApiRoute = '/api/orders'; // Erro: 'orders' n\u00e3o \u00e9 um Resource // const invalidRoute2: ApiRoute = '/api/users/1/comments'; // Erro: formato inv\u00e1lido Checklist do Dia [ ] Criei um tipo de string simples com template literals. [ ] Usei uni\u00f5es para gerar m\u00faltiplas strings poss\u00edveis a partir de um template. [ ] Usei Capitalize e outras helpers para transformar strings em tipos. [ ] Constru\u00ed um tipo pr\u00e1tico para validar um formato de string (rotas de API). Dia 7: Projeto Mini #1 - Consolidando Conceitos Foco do Dia Consolidar todos os conceitos da semana (Classes, this , unknown , Type Guards, Utility Types) em um \u00fanico projeto pr\u00e1tico: um BaseRepository gen\u00e9rico para opera\u00e7\u00f5es CRUD em mem\u00f3ria. Leitura e Teoria (Revis\u00e3o) Classes e Generics ( <T> ) : Para criar uma \"planta\" reutiliz\u00e1vel. Constraints ( extends ) : Para garantir que o tipo T tenha as propriedades que precisamos (como id ). Record<K, V> : Para criar um armazenamento em mem\u00f3ria type-safe. Partial e Omit : Para criar um payload de atualiza\u00e7\u00e3o seguro. Type Guards : Para verificar se um item existe antes de realizar uma opera\u00e7\u00e3o. Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe StringStore n\u00e3o gen\u00e9rica . Ela deve ter um array privado para armazenar strings. Implemente dois m\u00e9todos: add(item: string) e getAll(): string[] . Ver Solu\u00e7\u00e3o class StringStore { private data: string[] = []; public add(item: string): void { this.data.push(item); } public getAll(): string[] { return this.data; } } // Teste const store = new StringStore(); store.add(\"ma\u00e7\u00e3\"); store.add(\"banana\"); console.log(store.getAll()); // [\"ma\u00e7\u00e3\", \"banana\"] N\u00edvel 2: Intermedi\u00e1rio Crie uma classe KeyValueStore<V> que seja gen\u00e9rica para o valor ( V ), mas a chave seja sempre string . Use um Record<string, V> para o armazenamento privado. Implemente os m\u00e9todos set(key: string, value: V) e get(key: string): V | undefined . Ver Solu\u00e7\u00e3o class KeyValueStore<V> { private data: Record<string, V> = {}; public set(key: string, value: V): void { this.data[key] = value; } public get(key: string): V | undefined { return this.data[key]; } } // Teste com n\u00fameros const userAges = new KeyValueStore<number>(); userAges.set(\"Lucas\", 30); userAges.set(\"Ana\", 25); console.log(userAges.get(\"Lucas\")); // 30 // Teste com objetos interface User { id: number; name: string; } const users = new KeyValueStore<User>(); users.set(\"user-1\", { id: 1, name: \"Lucas\" }); console.log(users.get(\"user-1\")); // { id: 1, name: \"Lucas\" } N\u00edvel 3: Avan\u00e7ado Implemente a classe BaseRepository<T> . Esta classe deve ser gen\u00e9rica e funcionar para qualquer tipo T que satisfa\u00e7a a constraint BaseEntity (que possui uma propriedade id do tipo string | number ). Requisitos: 1. Crie a interface BaseEntity { id: string | number; } . 2. A classe BaseRepository<T extends BaseEntity> deve usar um Record para armazenamento privado. 3. Implemente os m\u00e9todos: create(item: T) , findById(id: T['id']) , update(id: T['id'], payload: Partial<Omit<T, 'id'>>) , e delete(id: T['id']) . Ver Solu\u00e7\u00e3o // A constraint que todas as entidades devem seguir interface BaseEntity { id: string | number; } class BaseRepository<T extends BaseEntity> { private data: Record<T['id'], T> = {} as Record<T['id'], T>; public create(item: T): T { this.data[item.id] = item; return item; } public findById(id: T['id']): T | undefined { return this.data[id]; } public update(id: T['id'], payload: Partial<Omit<T, 'id'>>): T | undefined { const currentItem = this.findById(id); if (!currentItem) { return undefined; } const updatedItem = { ...currentItem, ...payload } as T; this.data[id] = updatedItem; return updatedItem; } public delete(id: T['id']): boolean { if (!this.findById(id)) { return false; } delete this.data[id]; return true; } public findAll(): T[] { return Object.values(this.data); } } // Teste interface Post extends BaseEntity { id: string; title: string; content: string; } const postRepository = new BaseRepository<Post>(); postRepository.create({ id: 'post-1', title: \"Primeiro Post\", content: \"...\" }); postRepository.create({ id: 'post-2', title: \"Segundo Post\", content: \"...\" }); postRepository.update('post-1', { title: \"T\u00edtulo Atualizado\" }); postRepository.delete('post-2'); console.log(postRepository.findAll()); // [ { id: 'post-1', title: 'T\u00edtulo Atualizado', content: '...' } ] Checklist do Dia [ ] Criei uma classe gen\u00e9rica com constraints ( extends ). [ ] Usei Record como um armazenamento em mem\u00f3ria type-safe. [ ] Implementei m\u00e9todos CRUD (Create, Read, Update, Delete). [ ] Usei Partial e Omit para criar um payload de atualiza\u00e7\u00e3o seguro. [ ] Sinto-me mais confiante para aplicar os conceitos da Semana 1 em um projeto real.","title":"Semana 1"},{"location":"Ts/Semana1/#semana-1-fundamentos-criticos-e-classes","text":"","title":"Semana 1: Fundamentos Cr\u00edticos e Classes"},{"location":"Ts/Semana1/#visao-geral-da-semana","text":"Nesta primeira semana, nosso objetivo \u00e9 construir uma base s\u00f3lida em TypeScript. Vamos focar em dominar o sistema de classes, entender o comportamento do this e, crucialmente, come\u00e7ar a jornada para eliminar o any do nosso c\u00f3digo, substituindo-o por padr\u00f5es de tipagem seguros e robustos como unknown e type guards. Ao final da semana, voc\u00ea ter\u00e1 as ferramentas para construir componentes encapsulados e reutiliz\u00e1veis.","title":"Vis\u00e3o Geral da Semana"},{"location":"Ts/Semana1/#dia-1-classes-fundamentais","text":"","title":"Dia 1: Classes Fundamentais"},{"location":"Ts/Semana1/#foco-do-dia","text":"Construir e entender a estrutura de classes em TypeScript, incluindo como inicializar, controlar o acesso a propriedades e definir o comportamento atrav\u00e9s de m\u00e9todos.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada","text":"Classes s\u00e3o um dos pilares da programa\u00e7\u00e3o orientada a objetos. Elas s\u00e3o \"plantas\" para criar objetos. Propriedades (Properties) : S\u00e3o as vari\u00e1veis de uma classe. Elas definem o estado de um objeto. M\u00e9todos (Methods) : S\u00e3o as fun\u00e7\u00f5es de uma classe. Eles definem o comportamento de um objeto. Construtor (Constructor) : Um m\u00e9todo especial para criar e inicializar um objeto. Ele \u00e9 chamado automaticamente quando usamos a palavra-chave new . Modificadores de Acesso (Access Modifiers) : public : (padr\u00e3o) A propriedade ou m\u00e9todo pode ser acessado de qualquer lugar. private : A propriedade ou m\u00e9todo s\u00f3 pode ser acessado de dentro da pr\u00f3pria classe . Isso \u00e9 chamado de encapsulamento e \u00e9 crucial para proteger os dados e esconder a complexidade. protected : Pode ser acessado de dentro da classe e de classes que a herdam ( extends ). Veremos mais sobre heran\u00e7a na Semana 2. readonly : Uma propriedade marcada como readonly s\u00f3 pode receber um valor durante a sua declara\u00e7\u00e3o ou dentro do construtor. Garante imutabilidade ap\u00f3s a cria\u00e7\u00e3o do objeto. Parameter Properties : Um atalho do TypeScript para declarar e inicializar propriedades diretamente nos par\u00e2metros do construtor.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial","text":"Classes (TypeScript Handbook) Parameter Properties (TypeScript Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo","text":"Exemplo 1: Classe B\u00e1sica class Player { // Propriedade p\u00fablica, acess\u00edvel de qualquer lugar health: number = 100; // M\u00e9todo p\u00fablico attack() { console.log(\"O jogador ataca!\"); } } const player1 = new Player(); console.log(player1.health); // 100 player1.attack(); // \"O jogador ataca!\" Exemplo 2: Encapsulamento com private e readonly class BankAccount { public readonly accountNumber: string; private balance: number; constructor(accountNumber: string, initialBalance: number) { this.accountNumber = accountNumber; this.balance = initialBalance; } // M\u00e9todo p\u00fablico para acessar um dado privado de forma controlada public getBalance(): number { // Aqui poder\u00edamos adicionar l\u00f3gica de permiss\u00e3o, por exemplo return this.balance; } // M\u00e9todo p\u00fablico para modificar um dado privado public deposit(amount: number): void { if (amount > 0) { this.balance += amount; } } } const myAccount = new BankAccount(\"12345-6\", 500); // myAccount.balance = 10000; // Erro: 'balance' \u00e9 privado. // myAccount.accountNumber = \"98765-4\"; // Erro: 'accountNumber' \u00e9 readonly. myAccount.deposit(150); console.log(myAccount.getBalance()); // 650 Exemplo 3: Atalho com Parameter Properties class Car { // Declara e inicializa as propriedades diretamente no construtor constructor( public readonly model: string, private year: number ) {} public getCarInfo(): string { return `Carro: ${this.model}, Ano: ${this.year}`; } } const myCar = new Car(\"Fusca\", 1978); console.log(myCar.model); // \"Fusca\" console.log(myCar.getCarInfo()); // \"Carro: Fusca, Ano: 1978\"","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes","text":"N\u00edvel 1: B\u00e1sico Crie uma classe Rectangle com propriedades width e height (ambas public e do tipo number ). Adicione um m\u00e9todo getArea() que retorna a \u00e1rea do ret\u00e2ngulo ( width * height ). Ver Solu\u00e7\u00e3o class Rectangle { public width: number; public height: number; constructor(width: number, height: number) { this.width = width; this.height = height; } public getArea(): number { return this.width * this.height; } } // Teste const rect = new Rectangle(10, 20); console.log(rect.getArea()); // 200 N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Product com propriedades name (string) e price (number), ambas private . Use parameter properties . Adicione um m\u00e9todo p\u00fablico getPrice() para ler o pre\u00e7o e um m\u00e9todo setPrice(newPrice: number) que s\u00f3 permite a altera\u00e7\u00e3o se o newPrice for maior que zero. Ver Solu\u00e7\u00e3o class Product { constructor( private name: string, private price: number ) {} public getPrice(): number { return this.price; } public setPrice(newPrice: number): void { if (newPrice > 0) { this.price = newPrice; console.log(`O pre\u00e7o de ${this.name} foi atualizado para ${newPrice}.`); } else { console.log(\"Pre\u00e7o inv\u00e1lido. O valor deve ser maior que zero.\"); } } } // Teste const book = new Product(\"O Senhor dos An\u00e9is\", 50); console.log(book.getPrice()); // 50 book.setPrice(65); console.log(book.getPrice()); // 65 book.setPrice(-10); // \"Pre\u00e7o inv\u00e1lido...\" N\u00edvel 3: Avan\u00e7ado Implemente a classe DatabaseConnection que simula o padr\u00e3o de constructor overloading . A classe deve poder ser instanciada de duas formas: 1. new DatabaseConnection(url: string) 2. new DatabaseConnection(host: string, port: number, database: string) O construtor deve ter uma \u00fanica implementa\u00e7\u00e3o que verifica os argumentos recebidos e monta a connectionString interna de acordo. Ver Solu\u00e7\u00e3o class DatabaseConnection { private connectionString: string; // Assinatura de sobrecarga 1 constructor(url: string); // Assinatura de sobrecarga 2 constructor(host: string, port: number, database: string); // Implementa\u00e7\u00e3o real do construtor constructor(arg1: string, arg2?: number, arg3?: string) { // Verifica se os argumentos correspondem \u00e0 segunda assinatura if (typeof arg2 === 'number' && typeof arg3 === 'string') { const host = arg1; const port = arg2; const database = arg3; this.connectionString = `mongodb://${host}:${port}/${database}`; } else { // Caso contr\u00e1rio, trata como a primeira assinatura const url = arg1; this.connectionString = url; } } public connect(): void { console.log(`Conectando a: ${this.connectionString}`); } } // Teste const connFromUrl = new DatabaseConnection('mysql://user:pass@server/db'); connFromUrl.connect(); // \"Conectando a: mysql://user:pass@server/db\" const connFromParts = new DatabaseConnection('localhost', 5432, 'postgres'); connFromParts.connect(); // \"Conectando a: postgresql://localhost:5432/postgres\"","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia","text":"[ ] Entendi a diferen\u00e7a entre public e private . [ ] Sei por que readonly \u00e9 \u00fatil para imutabilidade. [ ] Usei o atalho de parameter properties . [ ] Implementei o padr\u00e3o de \"overload\" de construtor em TypeScript.","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-2-contexto-do-this-parte-1","text":"","title":"Dia 2: Contexto do this - Parte 1"},{"location":"Ts/Semana1/#foco-do-dia_1","text":"Entender como o this funciona em JavaScript/TypeScript e como garantir que ele se refira ao contexto correto, especialmente em callbacks e m\u00e9todos encadeados.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada_1","text":"O this \u00e9 uma das fontes mais comuns de bugs em JavaScript. Seu valor \u00e9 determinado por como a fun\u00e7\u00e3o \u00e9 chamada (call-site) , n\u00e3o onde ela \u00e9 definida. Fun\u00e7\u00e3o Regular ( function() {} ou metodo() {} ) : O this \u00e9 din\u00e2mico. Se a fun\u00e7\u00e3o \u00e9 chamada como obj.metodo() , this \u00e9 obj . Se a fun\u00e7\u00e3o \u00e9 simplesmente chamada ( funcao() ), this \u00e9 undefined (em 'strict mode', o padr\u00e3o em m\u00f3dulos e classes) ou o objeto global ( window no browser). Arrow Function ( () => {} ) : O this \u00e9 est\u00e1tico (l\u00e9xico). Ela n\u00e3o possui seu pr\u00f3prio this . Ela \"herda\" o this do escopo onde foi definida . Dentro de um m\u00e9todo de classe definido como arrow function, this sempre se referir\u00e1 \u00e0 inst\u00e2ncia da classe.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial_1","text":"O this em JavaScript (MDN) - Essencial para entender a base. This Types (TypeScript Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo_1","text":"Exemplo 1: O Problema - Perdendo o this class Greeter { prefix = \"Hello, \"; // M\u00e9todo de classe normal greet(name: string) { console.log(this.prefix + name); } } const greeter = new Greeter(); const greetFunction = greeter.greet; // A fun\u00e7\u00e3o \u00e9 extra\u00edda do objeto // greetFunction(\"Mundo\"); // Crash! `this` \u00e9 undefined aqui. Exemplo 2: A Solu\u00e7\u00e3o - Arrow Function como M\u00e9todo class SafeGreeter { prefix = \"Hello, \"; // O m\u00e9todo \u00e9 uma propriedade que cont\u00e9m uma arrow function // A arrow function \"lembra\" do `this` de onde foi criada greet = (name: string) => { console.log(this.prefix + name); } } const safeGreeter = new SafeGreeter(); const safeGreetFunction = safeGreeter.greet; safeGreetFunction(\"Mundo\"); // Funciona! \"Hello, Mundo\" Exemplo 3: Method Chaining com o tipo this class StringBuilder { private parts: string[] = []; add(part: string): this { this.parts.push(part); return this; // Retornar `this` permite o encadeamento } build(): string { return this.parts.join(\"\"); } } const builder = new StringBuilder(); const result = builder.add(\"Hello, \").add(\"World!\").build(); console.log(result); // \"Hello, World!\"","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_1","text":"N\u00edvel 1: B\u00e1sico Crie uma classe Logger com uma propriedade message . Crie um m\u00e9todo printMessage() . Chame este m\u00e9todo dentro de um setTimeout e observe o erro. Em seguida, corrija o problema para que a mensagem seja impressa corretamente ap\u00f3s 1 segundo. Ver Solu\u00e7\u00e3o class Logger { constructor(private message: string = \"Opera\u00e7\u00e3o conclu\u00edda!\") {} // A solu\u00e7\u00e3o \u00e9 definir o m\u00e9todo como uma arrow function printMessage = () => { console.log(this.message); } public schedulePrint(): void { console.log(\"Agendando impress\u00e3o...\"); setTimeout(this.printMessage, 1000); } } // Teste const logger = new Logger(); logger.schedulePrint(); // Ap\u00f3s 1s: \"Opera\u00e7\u00e3o conclu\u00edda!\" N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Calculator com uma propriedade value (number, private, inicia em 0). Crie os m\u00e9todos add(num: number) , subtract(num: number) e multiply(num: number) . Cada um desses m\u00e9todos deve modificar o value e retornar this para permitir o encadeamento de chamadas. Ver Solu\u00e7\u00e3o class Calculator { private value: number = 0; constructor(initialValue: number = 0) { this.value = initialValue; } add(num: number): this { this.value += num; return this; } subtract(num: number): this { this.value -= num; return this; } multiply(num: number): this { this.value *= num; return this; } getResult(): number { return this.value; } } // Teste const calc = new Calculator(10); const result = calc.add(5).subtract(3).multiply(2).getResult(); // (10 + 5 - 3) * 2 = 24 console.log(result); // 24 N\u00edvel 3: Avan\u00e7ado Crie uma classe DOMManager . Ela deve ter um m\u00e9todo createElement(tag: string, text: string) que cria um elemento (simulado por um objeto {tag, text} ) e o armazena em um array private elements . Crie um m\u00e9todo render(containerId: string) que deveria (em um cen\u00e1rio real) adicionar os elementos a um cont\u00eainer do DOM. O m\u00e9todo render deve ser chamado por um objeto externo, simulando um event listener, ent\u00e3o voc\u00ea precisa garantir que o this dentro de render ainda se refira \u00e0 inst\u00e2ncia de DOMManager . Ver Solu\u00e7\u00e3o interface Element { tag: string; text: string; } class DOMManager { private elements: Element[] = []; public createElement(tag: string, text: string): this { this.elements.push({ tag, text }); return this; } // Definido como arrow function para garantir o `this` l\u00e9xico public render = (containerId: string) => { // Em um app real, far\u00edamos: const container = document.getElementById(containerId); console.log(`Renderizando ${this.elements.length} elementos em #${containerId}`); for (const el of this.elements) { console.log(` <${el.tag}>${el.text}</${el.tag}>`); } } } // Teste const manager = new DOMManager(); manager.createElement(\"h1\", \"T\u00edtulo Principal\").createElement(\"p\", \"Este \u00e9 um par\u00e1grafo.\"); // Simulando um sistema de eventos que pega a fun\u00e7\u00e3o e a chama depois const eventSystem = { listeners: {} as Record<string, () => void>, addEventListener: function(eventName: string, callback: () => void) { this.listeners[eventName] = callback; }, trigger: function(eventName: string) { this.listeners[eventName](); } }; // Passamos o m\u00e9todo `render` como callback. Gra\u00e7as \u00e0 arrow function, o `this` funciona. eventSystem.addEventListener(\"renderPage\", () => manager.render(\"app-root\")); eventSystem.trigger(\"renderPage\");","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_1","text":"[ ] Sei explicar a diferen\u00e7a de this entre function() e () => {} . [ ] Consigo resolver um problema de this perdido em um callback. [ ] Entendi como return this; permite o encadeamento de m\u00e9todos. [ ] Implementei uma classe com uma API fluente.","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-3-eliminando-any-parte-1","text":"","title":"Dia 3: Eliminando any - Parte 1"},{"location":"Ts/Semana1/#foco-do-dia_2","text":"Abandonar o any e adotar unknown como a alternativa segura para tipos desconhecidos, for\u00e7ando a verifica\u00e7\u00e3o de tipos antes do uso.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada_2","text":"any : \u00c9 a \"v\u00e1lvula de escape\" do TypeScript. Uma vari\u00e1vel do tipo any desliga completamente a verifica\u00e7\u00e3o de tipos . Voc\u00ea pode chamar qualquer m\u00e9todo, acessar qualquer propriedade, e o compilador n\u00e3o vai reclamar. Isso \u00e9 perigoso e anula o prop\u00f3sito de usar TypeScript. unknown : \u00c9 a alternativa segura. Uma vari\u00e1vel unknown tamb\u00e9m pode receber qualquer valor, mas voc\u00ea n\u00e3o pode fazer nada com ela sem antes provar ao TypeScript qual \u00e9 o seu tipo. Esse processo de prova \u00e9 chamado de narrowing (estreitamento). Caracter\u00edstica any unknown Atribui\u00e7\u00e3o Pode receber qualquer valor Pode receber qualquer valor Opera\u00e7\u00f5es Permite qualquer opera\u00e7\u00e3o N\u00e3o permite nenhuma opera\u00e7\u00e3o Seguran\u00e7a Baixa Alta Necessidade Nenhuma verifica\u00e7\u00e3o Requer verifica\u00e7\u00e3o de tipo","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial_2","text":"The unknown Type (Handbook) The any Type (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo_2","text":"Exemplo 1: O Perigo do any let value: any = \"isto \u00e9 uma string\"; // Nenhuma verifica\u00e7\u00e3o do compilador! value.toFixed(2); // Crash em tempo de execu\u00e7\u00e3o: value.toFixed is not a function Exemplo 2: A Seguran\u00e7a do unknown let safeValue: unknown = \"isto \u00e9 uma string\"; // Erro de compila\u00e7\u00e3o! O TS nos protege. // safeValue.toFixed(2); // Object is of type 'unknown'. Exemplo 3: Usando unknown Corretamente com Verifica\u00e7\u00e3o let anotherSafeValue: unknown = 123.456; if (typeof anotherSafeValue === 'number') { // Dentro deste bloco, o TS sabe que anotherSafeValue \u00e9 um n\u00famero console.log(anotherSafeValue.toFixed(2)); // \"123.46\" }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_2","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o logString(value: unknown) que verifica se o valor recebido \u00e9 uma string . Se for, ela o imprime no console. Se n\u00e3o for, ela imprime a mensagem \"Valor n\u00e3o \u00e9 uma string\". Ver Solu\u00e7\u00e3o function logString(value: unknown): void { if (typeof value === 'string') { console.log(value); } else { console.log(\"Valor n\u00e3o \u00e9 uma string.\"); } } // Teste logString(\"Ol\u00e1, TypeScript!\"); // \"Ol\u00e1, TypeScript!\" logString(123); // \"Valor n\u00e3o \u00e9 uma string.\" logString({}); // \"Valor n\u00e3o \u00e9 uma string.\" N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o getDouble(value: unknown): number | null que verifica se o valor \u00e9 um number . Se for, a fun\u00e7\u00e3o deve retornar o dobro do valor. Caso contr\u00e1rio, deve retornar null . Ver Solu\u00e7\u00e3o function getDouble(value: unknown): number | null { if (typeof value === 'number') { return value * 2; } return null; } // Teste console.log(getDouble(10)); // 20 console.log(getDouble(\"20\")); // null console.log(getDouble(null)); // null N\u00edvel 3: Avan\u00e7ado Crie uma fun\u00e7\u00e3o safeJsonParse(json: string): unknown | Error . Esta fun\u00e7\u00e3o deve receber uma string JSON, tentar fazer o parse com JSON.parse . Se for bem-sucedido, deve retornar o objeto parseado (como unknown ). Se ocorrer um erro no parse, ela deve capturar a exce\u00e7\u00e3o e retornar um objeto Error . Ver Solu\u00e7\u00e3o function safeJsonParse(json: string): unknown | Error { try { // JSON.parse por padr\u00e3o retorna `any`, mas n\u00f3s o atribu\u00edmos a `unknown` // para for\u00e7ar quem chama a fun\u00e7\u00e3o a verificar o tipo do resultado. const parsed: unknown = JSON.parse(json); return parsed; } catch (e) { if (e instanceof Error) { return e; } return new Error(\"Falha desconhecida ao analisar JSON.\"); } } // Teste const validJson = '{\"name\": \"Lucas\", \"id\": 1}'; const invalidJson = '{'name': \"Lucas\"}'; // JSON malformado const result1 = safeJsonParse(validJson); const result2 = safeJsonParse(invalidJson); if (result1 instanceof Error) { console.error(\"Erro no JSON v\u00e1lido:\", result1.message); } else { console.log(\"Sucesso no JSON v\u00e1lido:\", result1); } if (result2 instanceof Error) { console.error(\"Erro no JSON inv\u00e1lido:\", result2.message); } else { console.log(\"Sucesso no JSON inv\u00e1lido:\", result2); }","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_2","text":"[ ] Entendi por que any \u00e9 perigoso e deve ser evitado. [ ] Sei a diferen\u00e7a fundamental entre any e unknown . [ ] Usei typeof para fazer narrowing de um tipo unknown . [ ] Implementei uma fun\u00e7\u00e3o que lida com dados de tipo desconhecido de forma segura.","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-4-type-guards-e-narrowing","text":"","title":"Dia 4: Type Guards e Narrowing"},{"location":"Ts/Semana1/#foco-do-dia_3","text":"Aprender as t\u00e9cnicas de narrowing (estreitamento de tipo) para que o TypeScript possa inferir um tipo mais espec\u00edfico dentro de um bloco de c\u00f3digo, e criar seus pr\u00f3prios type guards customizados.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada_3","text":"Narrowing \u00e9 o processo pelo qual o TypeScript remove tipos de uma uni\u00e3o. Se voc\u00ea tem string | number , e o TS prova que \u00e9 string , ele \"estreita\" o tipo para apenas string naquele escopo. T\u00e9cnicas de Narrowing: 1. typeof : Para tipos primitivos ( string , number , boolean , etc.). 2. instanceof : Para verificar se um objeto \u00e9 uma inst\u00e2ncia de uma classe. 3. Truthiness : Verificar se um valor n\u00e3o \u00e9 null , undefined , false , 0 , \"\" . 4. Equality ( === ) : Verificar igualdade com um valor literal. 5. in operator : Verificar se um objeto possui uma propriedade com um certo nome. 6. Discriminated Unions : Um padr\u00e3o poderoso onde voc\u00ea usa uma propriedade literal comum ( kind , type , status ) em v\u00e1rios tipos para ajudar o TypeScript a descobrir qual tipo \u00e9. 7. Custom Type Guards (Type Predicates) : Fun\u00e7\u00f5es que retornam um booleano especial: parametro is Tipo . Se a fun\u00e7\u00e3o retornar true , o TypeScript \"confia\" que o par\u00e2metro \u00e9 daquele Tipo no resto do escopo.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial_3","text":"Narrowing (Handbook) Using Type Predicates (Custom Type Guards)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo_3","text":"Exemplo 1: typeof function padLeft(padding: number | string, input: string): string { if (typeof padding === \"number\") { return \" \".repeat(padding) + input; } return padding + input; } Exemplo 2: instanceof class Cat { meow() { console.log(\"Meow!\"); } } class Dog { bark() { console.log(\"Woof!\"); } } type Pet = Cat | Dog; function makeSound(pet: Pet) { if (pet instanceof Cat) { pet.meow(); // O TS sabe que `pet` \u00e9 um Cat aqui } } Exemplo 3: in operator interface Movie { title: string; duration: number; } interface TVShow { title: string; seasons: number; } type Media = Movie | TVShow; function getMediaTitle(media: Media) { if ('duration' in media) { return `Filme: ${media.title}`; } // O TS sabe que se n\u00e3o tem 'duration', deve ter 'seasons' return `S\u00e9rie: ${media.title}`; }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_3","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o formatInput(input: string | string[]) . Se o input for uma string , retorne a pr\u00f3pria string. Se for um array de strings, retorne as strings unidas por um espa\u00e7o. Use o type guard Array.isArray() . Ver Solu\u00e7\u00e3o function formatInput(input: string | string[]): string { if (Array.isArray(input)) { // O TS sabe que `input` \u00e9 string[] aqui return input.join(' '); } // O TS sabe que `input` \u00e9 string aqui return input; } // Teste console.log(formatInput(\"hello\")); // \"hello\" console.log(formatInput([\"hello\", \"world\"])); // \"hello world\" N\u00edvel 2: Intermedi\u00e1rio Defina duas interfaces: Fish com um m\u00e9todo swim() e Bird com um m\u00e9todo fly() . Crie uma fun\u00e7\u00e3o makePetMove(pet: Fish | Bird) . Dentro dela, use um custom type guard isFish(pet): pet is Fish para verificar o tipo do animal e chamar o m\u00e9todo correto ( swim ou fly ). Ver Solu\u00e7\u00e3o interface Fish { swim: () => void; } interface Bird { fly: () => void; } type Animal = Fish | Bird; // Custom type guard function isFish(pet: Animal): pet is Fish { // Se o pet tem a propriedade 'swim', ent\u00e3o ele \u00e9 um Fish. // A asser\u00e7\u00e3o `(pet as Fish)` \u00e9 necess\u00e1ria para checar a propriedade // que pode n\u00e3o existir no tipo Animal. return (pet as Fish).swim !== undefined; } function makePetMove(pet: Animal) { if (isFish(pet)) { pet.swim(); } else { pet.fly(); } } // Teste const nemo: Fish = { swim: () => console.log(\"Nemo est\u00e1 nadando.\") }; const zazu: Bird = { fly: () => console.log(\"Zazu est\u00e1 voando.\") }; makePetMove(nemo); makePetMove(zazu); N\u00edvel 3: Avan\u00e7ado Implemente o padr\u00e3o Discriminated Union . Crie duas interfaces, SuccessResponse e ErrorResponse . Ambas devem ter uma propriedade status , mas com valores literais diferentes ( 'success' e 'error' ). Crie uma fun\u00e7\u00e3o handleApiResponse(response: ApiResponse) que usa a propriedade status para identificar o tipo da resposta e logar os dados ou a mensagem de erro apropriada. Ver Solu\u00e7\u00e3o interface SuccessResponse { status: 'success'; // Propriedade discriminante data: { id: number; name: string }; } interface ErrorResponse { status: 'error'; // Propriedade discriminante error: { code: number; message: string }; } type ApiResponse = SuccessResponse | ErrorResponse; function handleApiResponse(response: ApiResponse) { // Usando um switch na propriedade discriminante switch (response.status) { case 'success': // O TS sabe que `response` \u00e9 SuccessResponse aqui console.log(\"Dados recebidos:\", response.data.name); break; case 'error': // O TS sabe que `response` \u00e9 ErrorResponse aqui console.error(\"Ocorreu um erro:\", response.error.message); break; } } // Teste const success: ApiResponse = { status: 'success', data: { id: 1, name: 'Produto A' } }; const failure: ApiResponse = { status: 'error', error: { code: 404, message: 'Produto n\u00e3o encontrado' } }; handleApiResponse(success); handleApiResponse(failure);","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_3","text":"[ ] Sei usar typeof , instanceof e in para narrowing. [ ] Entendi o padr\u00e3o de Discriminated Unions . [ ] Criei e usei um custom type guard ( is Type ). [ ] Apliquei narrowing para acessar propriedades de tipos em uma uni\u00e3o de forma segura.","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-5-utility-types-nativos-record-e-basicos","text":"","title":"Dia 5: Utility Types Nativos - Record e B\u00e1sicos"},{"location":"Ts/Semana1/#foco-do-dia_4","text":"Utilizar os Utility Types nativos do TypeScript para transformar e criar novos tipos a partir de tipos existentes, com foco especial em Record<K,V> .","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada_4","text":"Utility Types s\u00e3o ferramentas que ajudam a manipular tipos sem ter que reescrev\u00ea-los. Record<Keys, Type> : Constr\u00f3i um tipo de objeto cujas chaves s\u00e3o Keys e os valores s\u00e3o Type . Perfeito para dicion\u00e1rios ou mapeamentos onde as chaves s\u00e3o de um conjunto conhecido. Partial<Type> : Constr\u00f3i um tipo com todas as propriedades de Type definidas como opcionais . \u00datil para payloads de atualiza\u00e7\u00e3o ( update ). Required<Type> : O oposto de Partial . Torna todas as propriedades obrigat\u00f3rias . Pick<Type, Keys> : Constr\u00f3i um tipo \"pegando\" um conjunto de propriedades Keys de Type . Omit<Type, Keys> : O oposto de Pick . Constr\u00f3i um tipo com todas as propriedades de Type , exceto as Keys . Readonly<Type> : Torna todas as propriedades de Type somente leitura.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial_4","text":"Utility Types (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo_4","text":"Exemplo 1: Partial para atualiza\u00e7\u00f5es interface User { name: string; age: number; email: string; } function updateUser(user: User, fieldsToUpdate: Partial<User>) { return { ...user, ...fieldsToUpdate }; } const user1 = { name: 'Lucas', age: 30, email: 'lucas@test.com' }; const updatedUser = updateUser(user1, { age: 31 }); Exemplo 2: Pick para dados p\u00fablicos interface UserWithPassword { id: number; name: string; passwordHash: string; } type PublicUser = Pick<UserWithPassword, 'id' | 'name'>; const publicProfile: PublicUser = { id: 1, name: 'Ana' }; Exemplo 3: Omit para remover dados sens\u00edveis type UserWithoutPassword = Omit<UserWithPassword, 'passwordHash'>; const userToSend: UserWithoutPassword = { id: 2, name: 'Beto' }; Exemplo 4: Record para um dicion\u00e1rio de configura\u00e7\u00f5es type Theme = 'light' | 'dark'; interface ThemeSettings { color: string; background: string; } const themes: Record<Theme, ThemeSettings> = { light: { color: '#000', background: '#fff' }, dark: { color: '#fff', background: '#000' }, };","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_4","text":"N\u00edvel 1: B\u00e1sico Dada a interface Book { id: number; title: string; author: string; pages: number; } , crie um tipo BookPreview que contenha apenas as propriedades title e author usando um Utility Type. Ver Solu\u00e7\u00e3o interface Book { id: number; title: string; author: string; pages: number; } type BookPreview = Pick<Book, 'title' | 'author'>; // Teste const preview: BookPreview = { title: \"Duna\", author: \"Frank Herbert\" }; N\u00edvel 2: Intermedi\u00e1rio Crie uma interface AppSettings com todas as propriedades opcionais: theme: string , fontSize: number , language: string . Em seguida, crie um tipo RequiredAppSettings que tenha todas essas mesmas propriedades, mas como obrigat\u00f3rias. Por fim, crie uma fun\u00e7\u00e3o applySettings(settings: RequiredAppSettings) . Ver Solu\u00e7\u00e3o interface AppSettings { theme?: string; fontSize?: number; language?: string; } type RequiredAppSettings = Required<AppSettings>; function applySettings(settings: RequiredAppSettings) { console.log(\"Aplicando configura\u00e7\u00f5es:\", settings); } // Teste const mySettings: RequiredAppSettings = { theme: 'dark', fontSize: 14, language: 'pt-BR' }; applySettings(mySettings); // const invalidSettings: RequiredAppSettings = { theme: 'light' }; // Erro: fontSize e language est\u00e3o faltando N\u00edvel 3: Avan\u00e7ado Crie um enum chamado UserRole com os valores ADMIN , EDITOR , e VIEWER . Crie um tipo Permissions que define o que cada papel pode fazer (ex: { canWrite: boolean; canRead: boolean; } ). Use o Utility Type Record para criar um objeto rolePermissions que mapeia cada UserRole para seu respectivo objeto Permissions de forma type-safe. Ver Solu\u00e7\u00e3o enum UserRole { ADMIN = 'admin', EDITOR = 'editor', VIEWER = 'viewer' } interface Permissions { canWrite: boolean; canRead: boolean; canDelete: boolean; } const rolePermissions: Record<UserRole, Permissions> = { [UserRole.ADMIN]: { canWrite: true, canRead: true, canDelete: true }, [UserRole.EDITOR]: { canWrite: true, canRead: true, canDelete: false }, [UserRole.VIEWER]: { canWrite: false, canRead: true, canDelete: false }, }; // Teste function checkPermissions(role: UserRole) { const permissions = rolePermissions[role]; console.log(`Permiss\u00f5es para ${role.toUpperCase()}:`, permissions); } checkPermissions(UserRole.EDITOR); // checkPermissions('guest'); // Erro: Argument of type '\"guest\"' is not assignable to parameter of type 'UserRole'.","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_4","text":"[ ] Entendi o prop\u00f3sito do Record<K, V> . [ ] Usei Record para criar um dicion\u00e1rio type-safe. [ ] Sei a diferen\u00e7a entre Pick e Omit . [ ] Combinei Partial e Required para manipular tipos.","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-6-template-literal-types","text":"","title":"Dia 6: Template Literal Types"},{"location":"Ts/Semana1/#foco-do-dia_5","text":"Criar tipos de string altamente espec\u00edficos e din\u00e2micos usando Template Literals, permitindo valida\u00e7\u00e3o de formatos de string em tempo de compila\u00e7\u00e3o.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-aprofundada_5","text":"Template Literal Types usam a mesma sintaxe de template strings do JavaScript ( ${} ), mas no n\u00edvel dos tipos. Eles permitem construir novos tipos de string concatenando outros tipos, especialmente uni\u00f5es. Com Unions (o superpoder): type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'; type ApiEndpoint = 'users' | 'products'; // Gera uma uni\u00e3o de todas as 8 combina\u00e7\u00f5es poss\u00edveis: // \"GET /api/users\" | \"POST /api/users\" | ... type ApiRequestSignature = `${HttpMethod} /api/${ApiEndpoint}`; Com Helpers de Manipula\u00e7\u00e3o de String: TypeScript inclui tipos utilit\u00e1rios para manipular strings dentro dos tipos: Uppercase<S> , Lowercase<S> , Capitalize<S> , Uncapitalize<S> .","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana1/#documentacao-essencial_5","text":"Template Literal Types (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana1/#pratica-guiada-passo-a-passo_5","text":"Exemplo 1: Concatena\u00e7\u00e3o Simples type World = \"World\"; type Greeting = `Hello ${World}`; const g: Greeting = \"Hello World\"; // V\u00e1lido Exemplo 2: Uni\u00e3o de Tipos type MarginSide = 'top' | 'right' | 'bottom' | 'left'; type MarginProperty = `margin-${MarginSide}`; const m: MarginProperty = \"margin-left\"; // V\u00e1lido Exemplo 3: Capitalize para Nomes de Eventos type EventName = 'click' | 'scroll' | 'focus'; type HandlerName = `on${Capitalize<EventName>}`; const handler: HandlerName = \"onClick\"; // V\u00e1lido","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_5","text":"N\u00edvel 1: B\u00e1sico Crie um tipo Size ( 'small' | 'medium' | 'large' ) e um tipo Color ( 'red' | 'blue' | 'green' ). Crie um terceiro tipo, TShirtSKU , que combine os dois para formar um identificador de produto, como por exemplo 'small-red' . Ver Solu\u00e7\u00e3o type Size = 'small' | 'medium' | 'large'; type Color = 'red' | 'blue' | 'green'; type TShirtSKU = `${Size}-${Color}`; // Teste const myShirt: TShirtSKU = \"medium-blue\"; const anotherShirt: TShirtSKU = \"large-red\"; // const invalidShirt: TShirtSKU = \"small-yellow\"; // Erro: 'yellow' n\u00e3o \u00e9 uma cor v\u00e1lida N\u00edvel 2: Intermedi\u00e1rio Crie um tipo IconName que represente nomes de \u00edcones no formato icon-[nome] , onde [nome] pode ser user , home , ou settings . Em seguida, crie um tipo IconSize que pode ser 16 , 24 , ou 32 . Finalmente, crie um tipo IconId que combine os dois, no formato icon-[nome]-[tamanho]px . Ver Solu\u00e7\u00e3o type IconName = `icon-${'user' | 'home' | 'settings'}`; type IconSize = 16 | 24 | 32; type IconId = `${IconName}-${IconSize}px`; // Teste const userIcon: IconId = \"icon-user-24px\"; const homeIcon: IconId = \"icon-home-32px\"; // const invalidIcon: IconId = \"icon-settings-20px\"; // Erro: 20 n\u00e3o \u00e9 um tamanho v\u00e1lido N\u00edvel 3: Avan\u00e7ado Crie um tipo ApiRoute que valide os seguintes formatos de rota para uma API RESTful: 1. Listar todos os recursos: /api/[recurso] (ex: /api/users ) 2. Obter um recurso espec\u00edfico: /api/[recurso]/[id] (ex: /api/posts/123 ) Onde [recurso] pode ser users , posts , ou products , e [id] pode ser string ou number . Ver Solu\u00e7\u00e3o type Resource = 'users' | 'posts' | 'products'; type ResourceId = string | number; type ApiRoute = `/api/${Resource}` | `/api/${Resource}/${ResourceId}`; // Teste const listUsers: ApiRoute = '/api/users'; const getPost: ApiRoute = '/api/posts/post-id-abc'; const getProduct: ApiRoute = '/api/products/12345'; // const invalidRoute1: ApiRoute = '/api/orders'; // Erro: 'orders' n\u00e3o \u00e9 um Resource // const invalidRoute2: ApiRoute = '/api/users/1/comments'; // Erro: formato inv\u00e1lido","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_5","text":"[ ] Criei um tipo de string simples com template literals. [ ] Usei uni\u00f5es para gerar m\u00faltiplas strings poss\u00edveis a partir de um template. [ ] Usei Capitalize e outras helpers para transformar strings em tipos. [ ] Constru\u00ed um tipo pr\u00e1tico para validar um formato de string (rotas de API).","title":"Checklist do Dia"},{"location":"Ts/Semana1/#dia-7-projeto-mini-1-consolidando-conceitos","text":"","title":"Dia 7: Projeto Mini #1 - Consolidando Conceitos"},{"location":"Ts/Semana1/#foco-do-dia_6","text":"Consolidar todos os conceitos da semana (Classes, this , unknown , Type Guards, Utility Types) em um \u00fanico projeto pr\u00e1tico: um BaseRepository gen\u00e9rico para opera\u00e7\u00f5es CRUD em mem\u00f3ria.","title":"Foco do Dia"},{"location":"Ts/Semana1/#leitura-e-teoria-revisao","text":"Classes e Generics ( <T> ) : Para criar uma \"planta\" reutiliz\u00e1vel. Constraints ( extends ) : Para garantir que o tipo T tenha as propriedades que precisamos (como id ). Record<K, V> : Para criar um armazenamento em mem\u00f3ria type-safe. Partial e Omit : Para criar um payload de atualiza\u00e7\u00e3o seguro. Type Guards : Para verificar se um item existe antes de realizar uma opera\u00e7\u00e3o.","title":"Leitura e Teoria (Revis\u00e3o)"},{"location":"Ts/Semana1/#exercicios-praticos-niveis-crescentes_6","text":"N\u00edvel 1: B\u00e1sico Crie uma classe StringStore n\u00e3o gen\u00e9rica . Ela deve ter um array privado para armazenar strings. Implemente dois m\u00e9todos: add(item: string) e getAll(): string[] . Ver Solu\u00e7\u00e3o class StringStore { private data: string[] = []; public add(item: string): void { this.data.push(item); } public getAll(): string[] { return this.data; } } // Teste const store = new StringStore(); store.add(\"ma\u00e7\u00e3\"); store.add(\"banana\"); console.log(store.getAll()); // [\"ma\u00e7\u00e3\", \"banana\"] N\u00edvel 2: Intermedi\u00e1rio Crie uma classe KeyValueStore<V> que seja gen\u00e9rica para o valor ( V ), mas a chave seja sempre string . Use um Record<string, V> para o armazenamento privado. Implemente os m\u00e9todos set(key: string, value: V) e get(key: string): V | undefined . Ver Solu\u00e7\u00e3o class KeyValueStore<V> { private data: Record<string, V> = {}; public set(key: string, value: V): void { this.data[key] = value; } public get(key: string): V | undefined { return this.data[key]; } } // Teste com n\u00fameros const userAges = new KeyValueStore<number>(); userAges.set(\"Lucas\", 30); userAges.set(\"Ana\", 25); console.log(userAges.get(\"Lucas\")); // 30 // Teste com objetos interface User { id: number; name: string; } const users = new KeyValueStore<User>(); users.set(\"user-1\", { id: 1, name: \"Lucas\" }); console.log(users.get(\"user-1\")); // { id: 1, name: \"Lucas\" } N\u00edvel 3: Avan\u00e7ado Implemente a classe BaseRepository<T> . Esta classe deve ser gen\u00e9rica e funcionar para qualquer tipo T que satisfa\u00e7a a constraint BaseEntity (que possui uma propriedade id do tipo string | number ). Requisitos: 1. Crie a interface BaseEntity { id: string | number; } . 2. A classe BaseRepository<T extends BaseEntity> deve usar um Record para armazenamento privado. 3. Implemente os m\u00e9todos: create(item: T) , findById(id: T['id']) , update(id: T['id'], payload: Partial<Omit<T, 'id'>>) , e delete(id: T['id']) . Ver Solu\u00e7\u00e3o // A constraint que todas as entidades devem seguir interface BaseEntity { id: string | number; } class BaseRepository<T extends BaseEntity> { private data: Record<T['id'], T> = {} as Record<T['id'], T>; public create(item: T): T { this.data[item.id] = item; return item; } public findById(id: T['id']): T | undefined { return this.data[id]; } public update(id: T['id'], payload: Partial<Omit<T, 'id'>>): T | undefined { const currentItem = this.findById(id); if (!currentItem) { return undefined; } const updatedItem = { ...currentItem, ...payload } as T; this.data[id] = updatedItem; return updatedItem; } public delete(id: T['id']): boolean { if (!this.findById(id)) { return false; } delete this.data[id]; return true; } public findAll(): T[] { return Object.values(this.data); } } // Teste interface Post extends BaseEntity { id: string; title: string; content: string; } const postRepository = new BaseRepository<Post>(); postRepository.create({ id: 'post-1', title: \"Primeiro Post\", content: \"...\" }); postRepository.create({ id: 'post-2', title: \"Segundo Post\", content: \"...\" }); postRepository.update('post-1', { title: \"T\u00edtulo Atualizado\" }); postRepository.delete('post-2'); console.log(postRepository.findAll()); // [ { id: 'post-1', title: 'T\u00edtulo Atualizado', content: '...' } ]","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana1/#checklist-do-dia_6","text":"[ ] Criei uma classe gen\u00e9rica com constraints ( extends ). [ ] Usei Record como um armazenamento em mem\u00f3ria type-safe. [ ] Implementei m\u00e9todos CRUD (Create, Read, Update, Delete). [ ] Usei Partial e Omit para criar um payload de atualiza\u00e7\u00e3o seguro. [ ] Sinto-me mais confiante para aplicar os conceitos da Semana 1 em um projeto real.","title":"Checklist do Dia"},{"location":"Ts/Semana2/","text":"Semana 2: Classes Avan\u00e7adas e Generics Vis\u00e3o Geral da Semana Com os fundamentos s\u00f3lidos, a segunda semana mergulha em conceitos mais poderosos e abstratos. Vamos explorar heran\u00e7a com abstract classes , o poder da reutiliza\u00e7\u00e3o de c\u00f3digo com generics , o uso avan\u00e7ado do this , e introduzir decorators para metaprograma\u00e7\u00e3o. Continuaremos nossa miss\u00e3o de eliminar o any com tipos mais sofisticados como never e branded types , e finalizaremos com a introdu\u00e7\u00e3o aos conditional types , uma das ferramentas mais avan\u00e7adas do TypeScript. Dia 8: Heran\u00e7a e Abstract Classes Foco do Dia Entender como criar hierarquias de classes usando heran\u00e7a ( extends ) e como definir \"contratos\" de classes com abstract classes . Leitura e Teoria (Aprofundada) Heran\u00e7a ( extends ) : Permite que uma classe (subclasse ou classe filha) herde propriedades e m\u00e9todos de outra classe (superclasse ou classe pai). Isso promove a reutiliza\u00e7\u00e3o de c\u00f3digo. super() : Dentro do constructor de uma subclasse, super() \u00e9 usado para chamar o constructor da classe pai. Isso \u00e9 obrigat\u00f3rio antes de usar a palavra-chave this na subclasse. Sobrescrita de M\u00e9todos (Method Overriding) : Uma subclasse pode fornecer sua pr\u00f3pria implementa\u00e7\u00e3o de um m\u00e9todo que j\u00e1 existe na classe pai. Classes Abstratas ( abstract class ) : S\u00e3o classes que n\u00e3o podem ser instanciadas diretamente. Elas servem como um modelo base para outras classes. Podem conter m\u00e9todos abstratos , que s\u00e3o m\u00e9todos sem implementa\u00e7\u00e3o que devem ser implementados pelas subclasses. Documenta\u00e7\u00e3o Essencial Heran\u00e7a de Classes (MDN) Abstract Classes and Members (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Heran\u00e7a Simples class Animal { constructor(public name: string) {} move(distanceInMeters: number = 0) { console.log(`${this.name} moveu ${distanceInMeters}m.`); } } class Dog extends Animal { // O construtor da subclasse constructor(name: string) { super(name); // Chama o construtor da classe Animal } // Sobrescrevendo o m\u00e9todo move move(distanceInMeters: number = 5) { console.log(\"Correndo...\"); super.move(distanceInMeters); } } const myDog = new Dog(\"Rex\"); myDog.move(10); Exemplo 2: Classes Abstratas abstract class Shape { // M\u00e9todo abstrato: sem implementa\u00e7\u00e3o, deve ser definido na subclasse abstract getArea(): number; // M\u00e9todo concreto: j\u00e1 tem implementa\u00e7\u00e3o e \u00e9 herdado printInfo() { console.log(`Esta \u00e9 uma forma com \u00e1rea de ${this.getArea()}`); } } class Circle extends Shape { constructor(private radius: number) { super(); } // Implementa\u00e7\u00e3o obrigat\u00f3ria do m\u00e9todo abstrato getArea(): number { return Math.PI * this.radius ** 2; } } // const shape = new Shape(); // Erro: N\u00e3o se pode criar inst\u00e2ncia de classe abstrata. const myCircle = new Circle(10); myCircle.printInfo(); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe base Vehicle com uma propriedade brand (marca) e um m\u00e9todo startEngine() que imprime \"Motor ligado\". Crie uma subclasse Car que herda de Vehicle e adiciona uma propriedade model . O construtor de Car deve receber brand e model . Ver Solu\u00e7\u00e3o class Vehicle { constructor(public brand: string) {} startEngine(): void { console.log(\"Motor ligado.\"); } } class Car extends Vehicle { constructor(brand: string, public model: string) { super(brand); // Passa a marca para o construtor da classe pai } displayInfo(): void { console.log(`Carro: ${this.brand} ${this.model}`); } } // Teste const myCar = new Car(\"Volkswagen\", \"Gol\"); myCar.displayInfo(); // \"Carro: Volkswagen Gol\" myCar.startEngine(); // \"Motor ligado.\" N\u00edvel 2: Intermedi\u00e1rio Crie uma classe abstrata LoggerBase com um m\u00e9todo abstrato log(message: string) . Crie duas classes concretas que herdam de LoggerBase : ConsoleLogger (que imprime a mensagem no console) e FileLogger (que simula a escrita da mensagem em um arquivo, imprimindo \"Escrevendo no arquivo: [mensagem]\"). Ver Solu\u00e7\u00e3o abstract class LoggerBase { abstract log(message: string): void; logWithTimestamp(message: string): void { const timestamp = new Date().toISOString(); this.log(`[${timestamp}] ${message}`); } } class ConsoleLogger extends LoggerBase { log(message: string): void { console.log(message); } } class FileLogger extends LoggerBase { constructor(private filePath: string) { super(); } log(message: string): void { // Simula\u00e7\u00e3o console.log(`Escrevendo em ${this.filePath}: ${message}`); } } // Teste const consoleLogger = new ConsoleLogger(); consoleLogger.logWithTimestamp(\"Esta \u00e9 uma mensagem de teste.\"); const fileLogger = new FileLogger(\"/var/log/app.log\"); fileLogger.logWithTimestamp(\"Erro cr\u00edtico no sistema.\"); N\u00edvel 3: Avan\u00e7ado Recrie a estrutura do seu GetTableDataService usando uma classe abstrata. Crie uma classe BaseService<TResponse, TParams> com um m\u00e9todo abstrato handle(params: TParams): Promise<TResponse> . Crie uma classe concreta FetchUsersService que herda de BaseService e implementa o m\u00e9todo handle para \"buscar\" uma lista de usu\u00e1rios. Ver Solu\u00e7\u00e3o // Defini\u00e7\u00e3o dos tipos para o servi\u00e7o concreto interface User { id: number; name: string; } interface FetchUsersParams { page: number; limit: number; } // A classe abstrata base abstract class BaseService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; // Um m\u00e9todo concreto que pode ser compartilhado protected logRequest(params: TParams): void { console.log(\"Iniciando requisi\u00e7\u00e3o com os par\u00e2metros:\", params); } } // A implementa\u00e7\u00e3o concreta class FetchUsersService extends BaseService<User[], FetchUsersParams> { async handle(params: FetchUsersParams): Promise<User[]> { this.logRequest(params); console.log(`Buscando usu\u00e1rios... P\u00e1gina: ${params.page}, Limite: ${params.limit}`); // Simula uma chamada de API const fakeUsers: User[] = [ { id: 1, name: \"Lucas\" }, { id: 2, name: \"Ana\" }, ]; return Promise.resolve(fakeUsers); } } // Teste async function runService() { const userService = new FetchUsersService(); const users = await userService.handle({ page: 1, limit: 10 }); console.log(\"Usu\u00e1rios recebidos:\", users); } runService(); Checklist do Dia [ ] Entendi como extends e super() funcionam. [ ] Sei a diferen\u00e7a entre uma classe normal e uma abstrata. [ ] Implementei um m\u00e9todo abstrato em uma subclasse. [ ] Criei uma hierarquia de classes para reutilizar c\u00f3digo. Dia 9: Generics em Classes Foco do Dia Escrever classes flex\u00edveis e reutiliz\u00e1veis que podem trabalhar com diferentes tipos de dados usando Generics ( <T> ). Leitura e Teoria (Aprofundada) Generics permitem que voc\u00ea crie componentes que funcionam com qualquer tipo, em vez de um tipo espec\u00edfico. Isso aumenta drasticamente a reutiliza\u00e7\u00e3o de c\u00f3digo e a seguran\u00e7a de tipo. Par\u00e2metros de Tipo ( <T> ) : A letra T \u00e9 uma conven\u00e7\u00e3o para \"Type\". Voc\u00ea pode usar qualquer nome ( <TData> , <TValue> , etc.). Ela atua como uma vari\u00e1vel para o tipo. Constraints ( extends ) : Voc\u00ea pode restringir os tipos que podem ser usados com um generic. class MyClass<T extends SomeType> significa que T deve ser compat\u00edvel com SomeType . M\u00faltiplos Par\u00e2metros de Tipo : Uma classe pode ter v\u00e1rios par\u00e2metros de tipo, como class Pair<K, V> para um par chave-valor. Tipos Padr\u00e3o : Voc\u00ea pode fornecer um tipo padr\u00e3o para um par\u00e2metro gen\u00e9rico: class MyClass<T = string> . Documenta\u00e7\u00e3o Essencial Generics (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Uma Caixa Gen\u00e9rica class Box<T> { private content: T; constructor(initialContent: T) { this.content = initialContent; } getContent(): T { return this.content; } } const stringBox = new Box<string>(\"Ol\u00e1, Generics!\"); const numberBox = new Box<number>(123); console.log(stringBox.getContent().toUpperCase()); console.log(numberBox.getContent().toFixed(2)); Exemplo 2: Generic com Constraints interface WithLength { length: number; } // T pode ser qualquer tipo, desde que tenha uma propriedade `length` class LengthReporter<T extends WithLength> { constructor(private value: T) {} report() { console.log(`O comprimento \u00e9 ${this.value.length}`); } } const stringReporter = new LengthReporter(\"uma string\"); const arrayReporter = new LengthReporter([1, 2, 3]); // const numberReporter = new LengthReporter(123); // Erro: `number` n\u00e3o tem a propriedade `length`. stringReporter.report(); arrayReporter.report(); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe gen\u00e9rica DataStore<T> que armazena um array de itens do tipo T . Ela deve ter os m\u00e9todos add(item: T) e getAll(): T[] . Ver Solu\u00e7\u00e3o class DataStore<T> { private data: T[] = []; add(item: T): void { this.data.push(item); } getAll(): T[] { return this.data; } } // Teste com strings const stringStore = new DataStore<string>(); stringStore.add(\"TypeScript\"); stringStore.add(\"Generics\"); console.log(stringStore.getAll()); // [\"TypeScript\", \"Generics\"] // Teste com n\u00fameros const numberStore = new DataStore<number>(); numberStore.add(10); numberStore.add(20); console.log(numberStore.getAll()); // [10, 20] N\u00edvel 2: Intermedi\u00e1rio Crie uma classe gen\u00e9rica Cache<T> que armazena um valor do tipo T e uma data de expira\u00e7\u00e3o. Implemente os m\u00e9todos set(value: T, ttl: number) (ttl em segundos) e get(): T | null . O m\u00e9todo get deve retornar null se o cache tiver expirado. Ver Solu\u00e7\u00e3o class Cache<T> { private value: T | null = null; private expiresAt: Date | null = null; set(value: T, ttlInSeconds: number): void { this.value = value; const now = new Date(); this.expiresAt = new Date(now.getTime() + ttlInSeconds * 1000); console.log(`Valor armazenado no cache. Expira em: ${this.expiresAt.toLocaleTimeString()}`); } get(): T | null { if (this.expiresAt && this.expiresAt > new Date() && this.value) { console.log(\"Valor retornado do cache.\"); return this.value; } console.log(\"Cache expirado ou vazio.\"); this.value = null; this.expiresAt = null; return null; } } // Teste async function testCache() { const userCache = new Cache<{ name: string }>(); userCache.set({ name: \"Lucas\" }, 3); // Expira em 3 segundos console.log(userCache.get()); // Retorna o objeto await new Promise(resolve => setTimeout(resolve, 4000)); // Espera 4 segundos console.log(userCache.get()); // Retorna null } testCache(); N\u00edvel 3: Avan\u00e7ado Crie uma classe DataService<T extends { id: K }, K extends string | number> . Esta classe deve gerenciar uma cole\u00e7\u00e3o de entidades T . Implemente os m\u00e9todos add(item: T) e findById(id: K): T | undefined . O uso de m\u00faltiplos generics ( T e K ) garante que o tipo do id seja consistente. Ver Solu\u00e7\u00e3o // A constraint gen\u00e9rica interface BaseEntity<K extends string | number> { id: K; } class DataService<T extends BaseEntity<K>, K extends string | number> { private items: Record<K, T> = {} as Record<K, T>; add(item: T): void { this.items[item.id] = item; } findById(id: K): T | undefined { return this.items[id]; } getAll(): T[] { return Object.values(this.items); } } // Teste interface Product { id: number; name: string; price: number; } // O TS infere que K \u00e9 `number` a partir de Product['id'] const productService = new DataService<Product, number>(); productService.add({ id: 101, name: \"Laptop\", price: 5000 }); productService.add({ id: 102, name: \"Mouse\", price: 150 }); console.log(productService.findById(101)); console.log(productService.findById(999)); console.log(productService.getAll()); Checklist do Dia [ ] Criei uma classe gen\u00e9rica simples. [ ] Usei constraints ( extends ) para limitar os tipos de um generic. [ ] Entendi como usar m\u00faltiplos par\u00e2metros de tipo. [ ] Apliquei generics para criar uma classe de servi\u00e7o reutiliz\u00e1vel. Dia 10: Contexto this - Parte 2 Avan\u00e7ada Foco do Dia Explorar t\u00e9cnicas avan\u00e7adas para controlar o this , incluindo this parameters para adicionar tipagem expl\u00edcita ao this em fun\u00e7\u00f5es e ThisType<T> para fornecer contexto a objetos literais. Leitura e Teoria (Aprofundada) this Parameters : TypeScript permite que voc\u00ea declare o tipo de this como o primeiro par\u00e2metro de uma fun\u00e7\u00e3o. Este par\u00e2metro \u00e9 falso (n\u00e3o existe no JavaScript compilado), mas \u00e9 usado pelo TypeScript para garantir que a fun\u00e7\u00e3o seja chamada com o contexto correto. ThisType<T> : Um tipo utilit\u00e1rio que n\u00e3o retorna um novo tipo, mas sim modifica o contexto de this dentro de um objeto literal. \u00c9 muito \u00fatil para criar APIs onde voc\u00ea define m\u00e9todos em um objeto, mas quer que this se refira a um tipo maior e mais complexo. Documenta\u00e7\u00e3o Essencial This Parameters (Handbook) ThisType (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: this Parameter para Seguran\u00e7a // A fun\u00e7\u00e3o espera que `this` seja um objeto com uma propriedade `name` function sayHello(this: { name: string }) { console.log(`Hello, ${this.name}!`); } const person = { name: \"Lucas\", sayHello }; const anotherPerson = { name: \"Ana\", sayHello }; person.sayHello(); // OK anotherPerson.sayHello(); // OK // sayHello(); // Erro: O `this` da fun\u00e7\u00e3o n\u00e3o \u00e9 do tipo `{ name: string }`. Exemplo 2: ThisType<T> para Objetos de Configura\u00e7\u00e3o interface ComponentOptions<T> { data: () => T; methods: Record<string, (this: T, ...args: any[]) => any>; } // O tipo `T` em `ThisType<T>` define o tipo de `this` nos m\u00e9todos function createComponent<T>(options: ComponentOptions<T> & { methods: ThisType<T> }): void { // L\u00f3gica de cria\u00e7\u00e3o do componente... console.log(\"Component created.\"); } createComponent({ data: () => ({ count: 0, message: \"Hello\" }), methods: { increment() { // Gra\u00e7as a `ThisType`, o TS sabe que `this` tem `count` e `message` this.count++; }, logMessage() { console.log(this.message); } } }); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma interface User com name: string . Crie uma fun\u00e7\u00e3o printUserName que n\u00e3o recebe argumentos, mas espera que o this seja do tipo User . Demonstre seu uso correto e incorreto. Ver Solu\u00e7\u00e3o interface User { name: string; } function printUserName(this: User): void { console.log(`User name: ${this.name}`); } // Teste const user1: User = { name: \"Alice\" }; const user2: User = { name: \"Bob\" }; // Para chamar a fun\u00e7\u00e3o, precisamos fornecer o contexto `this` printUserName.call(user1); // \"User name: Alice\" printUserName.apply(user2); // \"User name: Bob\" // const standaloneCall = printUserName; // Erro ao tentar chamar standaloneCall() N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Configuration<T> que armazena um objeto de configura\u00e7\u00e3o. Crie um m\u00e9todo update(updater: (this: T, currentConfig: T) => T) . A fun\u00e7\u00e3o updater deve receber a configura\u00e7\u00e3o atual, mas seu this deve ser tipado como a pr\u00f3pria configura\u00e7\u00e3o T , permitindo acesso direto \u00e0s propriedades. Ver Solu\u00e7\u00e3o class Configuration<T> { constructor(private config: T) {} public update(updater: (this: T, currentConfig: T) => T): void { const newConfig = updater.call(this.config, this.config); this.config = newConfig; } public getConfig(): T { return this.config; } } // Teste interface AppConfig { apiUrl: string; timeout: number; } const myConfig = new Configuration<AppConfig>({ apiUrl: \"/api/v1\", timeout: 5000 }); // A fun\u00e7\u00e3o updater pode usar `this` para acessar as propriedades de AppConfig myConfig.update(function(current) { return { ...current, timeout: this.timeout + 1000 // `this` \u00e9 do tipo AppConfig }; }); console.log(myConfig.getConfig()); // { apiUrl: '/api/v1', timeout: 6000 } N\u00edvel 3: Avan\u00e7ado Implemente a classe FormBuilder<T> do plano de estudos. Ela deve ter um m\u00e9todo field<K extends keyof T>(name: K, value: T[K]): this que adiciona um campo ao formul\u00e1rio. O m\u00e9todo field deve retornar this para encadeamento. Crie um m\u00e9todo build(): T que retorna o objeto de formul\u00e1rio completo. Ver Solu\u00e7\u00e3o class FormBuilder<T extends object> { private formData: Partial<T> = {}; // O tipo de retorno `this` permite o encadeamento public field<K extends keyof T>(name: K, value: T[K]): this { this.formData[name] = value; return this; } // O type guard `this is { formData: T }` ajuda o TS a saber que o form est\u00e1 completo private isComplete(): this is { formData: T } { // Em um cen\u00e1rio real, verificar\u00edamos se todas as chaves de T existem em formData return true; // Simplifica\u00e7\u00e3o para o exerc\u00edcio } public build(): T | Error { if (this.isComplete()) { return this.formData; // Gra\u00e7as ao type guard, o TS sabe que formData \u00e9 T, n\u00e3o Partial<T> } return new Error(\"Formul\u00e1rio incompleto.\"); } } // Teste interface UserForm { name: string; email: string; age: number; } const userFormBuilder = new FormBuilder<UserForm>(); const newUser = userFormBuilder .field(\"name\", \"Lucas\") .field(\"email\", \"lucas@ts.com\") .field(\"age\", 30) .build(); console.log(newUser); Checklist do Dia [ ] Entendi o prop\u00f3sito de um this parameter. [ ] Usei um this parameter para adicionar seguran\u00e7a a uma fun\u00e7\u00e3o. [ ] Entendi como ThisType<T> funciona em objetos literais. [ ] Criei uma classe builder usando this para encadeamento. Dia 11: Decorators Foco do Dia Introduzir decorators , uma proposta do ECMAScript para adicionar anota\u00e7\u00f5es e modificar classes e seus membros em tempo de design. Leitura e Teoria (Aprofundada) Decorators s\u00e3o fun\u00e7\u00f5es especiais que podem ser anexadas a classes, m\u00e9todos, propriedades ou par\u00e2metros. Eles s\u00e3o executados durante a defini\u00e7\u00e3o da classe, n\u00e3o durante a instancia\u00e7\u00e3o. Para usar decorators, voc\u00ea precisa habilitar a op\u00e7\u00e3o experimentalDecorators no seu tsconfig.json . Tipos de Decorators : Class, Method, Accessor, Property, Parameter. F\u00e1brica de Decorators (Decorator Factory) : Uma fun\u00e7\u00e3o que retorna a express\u00e3o do decorator. Isso permite que voc\u00ea configure o decorator, como @log(\"INFO\") . Composi\u00e7\u00e3o : M\u00faltiplos decorators podem ser aplicados a uma declara\u00e7\u00e3o. reflect-metadata : Uma biblioteca usada para adicionar metadados a classes e propriedades, que podem ser lidos posteriormente pelos decorators. Documenta\u00e7\u00e3o Essencial Decorators (Handbook) (Nota: esta \u00e9 uma feature experimental) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Decorator de M\u00e9todo Simples // O decorator recebe o alvo (a classe), a chave (nome do m\u00e9todo) e o descritor da propriedade function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { console.log(`Chamando o m\u00e9todo ${propertyKey} com os argumentos:`, args); const result = originalMethod.apply(this, args); console.log(`O m\u00e9todo ${propertyKey} retornou:`, result); return result; } } class Calculator { @log add(a: number, b: number): number { return a + b; } } new Calculator().add(2, 3); Exemplo 2: Decorator Factory function Enumerable(isEnumerable: boolean) { return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = isEnumerable; } } class Person { constructor(private name: string) {} @Enumerable(true) getName() { return this.name; } @Enumerable(false) getAge() { return 30; } } // O m\u00e9todo getName aparecer\u00e1 no loop, mas getAge n\u00e3o. for (const key in new Person(\"Lucas\")) { console.log(key); } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie um decorator de m\u00e9todo chamado @deprecated . Quando um m\u00e9todo decorado com ele for chamado, ele deve imprimir um aviso no console: Aviso: O m\u00e9todo [nome do m\u00e9todo] est\u00e1 obsoleto e ser\u00e1 removido em futuras vers\u00f5es. Ver Solu\u00e7\u00e3o function deprecated(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { console.warn(`Aviso: O m\u00e9todo ${propertyKey} est\u00e1 obsoleto e ser\u00e1 removido em futuras vers\u00f5es.`); return originalMethod.apply(this, args); } } class OldApiService { @deprecated findUsers() { console.log(\"Buscando usu\u00e1rios...\"); return [{ name: \"Lucas\" }]; } } // Teste new OldApiService().findUsers(); N\u00edvel 2: Intermedi\u00e1rio Crie um decorator de propriedade @min(minValue: number) . Este decorator deve garantir que, sempre que a propriedade for alterada, seu novo valor n\u00e3o seja menor que minValue . Se for, um erro deve ser lan\u00e7ado. Ver Solu\u00e7\u00e3o function min(minValue: number) { return function(target: any, propertyKey: string) { let value = target[propertyKey]; const getter = () => value; const setter = (newValue: number) => { if (newValue < minValue) { throw new Error(`O valor de ${propertyKey} n\u00e3o pode ser menor que ${minValue}.`); } value = newValue; }; Object.defineProperty(target, propertyKey, { get: getter, set: setter, enumerable: true, configurable: true, }); } } class Product { @min(0) price: number; @min(0) stock: number; constructor(price: number, stock: number) { this.price = price; this.stock = stock; } } // Teste const product = new Product(50, 100); console.log(product.price); // 50 product.price = 75; console.log(product.price); // 75 try { product.stock = -10; } catch (e: any) { console.error(e.message); } N\u00edvel 3: Avan\u00e7ado Crie um decorator de m\u00e9todo @cache . Ele deve armazenar o resultado da primeira chamada do m\u00e9todo. Nas chamadas subsequentes com os mesmos argumentos, ele deve retornar o resultado do cache em vez de executar o m\u00e9todo novamente. Use JSON.stringify para criar uma chave de cache a partir dos argumentos. Ver Solu\u00e7\u00e3o function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; const cache = new Map<string, any>(); descriptor.value = function(...args: any[]) { const cacheKey = JSON.stringify(args); if (cache.has(cacheKey)) { console.log(`Retornando do cache para a chave: ${cacheKey}`); return cache.get(cacheKey); } console.log(`Executando o m\u00e9todo pela primeira vez para a chave: ${cacheKey}`); const result = originalMethod.apply(this, args); cache.set(cacheKey, result); return result; } } class MathOperations { @cache heavyCalculation(a: number, b: number): number { // Simula uma opera\u00e7\u00e3o pesada const start = Date.now(); while (Date.now() - start < 1000) {} return a + b; } } // Teste const math = new MathOperations(); console.log(math.heavyCalculation(2, 3)); // Executa, demora 1s, retorna 5 console.log(math.heavyCalculation(5, 10)); // Executa, demora 1s, retorna 15 console.log(math.heavyCalculation(2, 3)); // Retorna do cache, instant\u00e2neo, retorna 5 Checklist do Dia [ ] Habilitei experimentalDecorators no tsconfig.json . [ ] Entendi a diferen\u00e7a entre um decorator e uma decorator factory. [ ] Criei um decorator de m\u00e9todo simples. [ ] Criei um decorator de propriedade que modifica seu comportamento. Dia 12: Eliminando any - Parte 2 Foco do Dia Introduzir tipos avan\u00e7ados para aumentar a seguran\u00e7a: never para c\u00f3digo inalcan\u00e7\u00e1vel e branded types para criar tipos nominais que o TypeScript n\u00e3o suporta nativamente. Leitura e Teoria (Aprofundada) never : Representa o tipo de valores que nunca ocorrem. \u00c9 usado em dois cen\u00e1rios principais: Em fun\u00e7\u00f5es que nunca retornam (ex: lan\u00e7am uma exce\u00e7\u00e3o ou entram em um loop infinito). Para fazer verifica\u00e7\u00e3o exaustiva (exhaustive checking) em switch ou if/else , garantindo que todos os casos de uma uni\u00e3o foram tratados. Branded Types (ou Opaque Types) : Uma t\u00e9cnica para criar tipos que s\u00e3o estruturalmente id\u00eanticos (ex: ambos s\u00e3o string ), mas nominalmente diferentes para o TypeScript. Isso evita que voc\u00ea passe um UserID para uma fun\u00e7\u00e3o que espera um ProductID . \u00c9 um padr\u00e3o, n\u00e3o uma feature nativa. Documenta\u00e7\u00e3o Essencial The never Type (Handbook) Exhaustiveness checking (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: never para Verifica\u00e7\u00e3o Exaustiva type Shape = { kind: \"circle\"; radius: number } | { kind: \"square\"; sideLength: number }; function getArea(shape: Shape) { switch (shape.kind) { case \"circle\": return Math.PI * shape.radius ** 2; case \"square\": return shape.sideLength ** 2; default: // Se adicionarmos um novo tipo a Shape (ex: triangle), o TS dar\u00e1 um erro aqui, // pois o novo tipo n\u00e3o pode ser atribu\u00eddo a `never`. const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } Exemplo 2: Branded Types // O \"brand\" que torna o tipo \u00fanico type Brand<K, T> = K & { __brand: T }; // Criando tipos nominais a partir de tipos primitivos type UserId = Brand<string, \"UserId\">; type ProductId = Brand<string, \"ProductId\">; function getUser(id: UserId) { console.log(`Buscando usu\u00e1rio com ID: ${id}`); } const userId = \"user-123\" as UserId; const productId = \"prod-456\" as ProductId; getUser(userId); // OK // getUser(productId); // Erro! O tipo `ProductId` n\u00e3o \u00e9 compat\u00edvel com `UserId`. Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o fail(message: string): never que sempre lan\u00e7a um erro com a mensagem fornecida. Use-a em uma fun\u00e7\u00e3o que processa um string | number e chama fail se o tipo n\u00e3o for nenhum dos dois. Ver Solu\u00e7\u00e3o function fail(message: string): never { throw new Error(message); } function processValue(value: string | number) { if (typeof value === 'string') { console.log(\"Processando string:\", value.toUpperCase()); } else if (typeof value === 'number') { console.log(\"Processando n\u00famero:\", value.toFixed(2)); } else { // O TS sabe que este c\u00f3digo \u00e9 inalcan\u00e7\u00e1vel fail(\"Valor inesperado!\"); } } // Teste processValue(\"hello\"); processValue(123); N\u00edvel 2: Intermedi\u00e1rio Crie um branded type Email a partir de string . Crie uma fun\u00e7\u00e3o sendEmail(to: Email, subject: string) que s\u00f3 aceita o tipo Email . Crie uma fun\u00e7\u00e3o createEmail(address: string): Email | null que valida se a string cont\u00e9m um @ antes de fazer a asser\u00e7\u00e3o de tipo para Email . Ver Solu\u00e7\u00e3o type Brand<K, T> = K & { __brand: T }; type Email = Brand<string, \"Email\">; function createEmail(address: string): Email | null { if (address.includes(\"@\")) { return address as Email; } return null; } function sendEmail(to: Email, subject: string): void { console.log(`Enviando email para ${to} com o assunto: \"${subject}\"`); } // Teste const userEmail = createEmail(\"lucas@example.com\"); const invalidEmail = createEmail(\"invalid-address\"); const plainString = \"another@test.com\"; if (userEmail) { sendEmail(userEmail, \"Ol\u00e1!\"); // OK } if (invalidEmail === null) { console.log(\"Endere\u00e7o de email inv\u00e1lido detectado.\"); } // sendEmail(plainString, \"Assunto\"); // Erro: `string` n\u00e3o \u00e9 compat\u00edvel com `Email`. N\u00edvel 3: Avan\u00e7ado Crie um wrapper type-safe para uma biblioteca externa falsa. A biblioteca tem um objeto untypedLibrary que \u00e9 any . Crie fun\u00e7\u00f5es safeGetNumber(key: string) e safeGetString(key: string) que usam o untypedLibrary , verificam o tipo do valor retornado, e o retornam com o tipo correto ou undefined se o tipo n\u00e3o corresponder. Ver Solu\u00e7\u00e3o // A biblioteca externa perigosa declare const untypedLibrary: any; const untypedLibrary = { appName: \"Super App\", version: 2.1, userCount: 1500, settings: { theme: \"dark\" } }; // O wrapper seguro class SafeLibraryWrapper { private lib: any; constructor(library: any) { this.lib = library; } public get(key: string): unknown { return this.lib[key]; } public getString(key: string): string | undefined { const value = this.get(key); if (typeof value === 'string') { return value; } return undefined; } public getNumber(key: string): number | undefined { const value = this.get(key); if (typeof value === 'number') { return value; } return undefined; } } // Teste const safeLib = new SafeLibraryWrapper(untypedLibrary); const appName = safeLib.getString(\"appName\"); const version = safeLib.getNumber(\"version\"); const userCount = safeLib.getNumber(\"userCount\"); const settings = safeLib.getString(\"settings\"); // Retorna undefined, pois n\u00e3o \u00e9 string console.log(`App: ${appName}, Vers\u00e3o: ${version}, Usu\u00e1rios: ${userCount}`); console.log(`Settings (string):`, settings); Checklist do Dia [ ] Entendi o prop\u00f3sito do tipo never . [ ] Usei never para fazer verifica\u00e7\u00e3o exaustiva. [ ] Entendi o padr\u00e3o de Branded Types e por que ele \u00e9 \u00fatil. [ ] Criei e usei um branded type para aumentar a seguran\u00e7a de tipo. Dia 13: Conditional Types Foco do Dia Entender Conditional Types , que permitem que um tipo seja escolhido com base em uma condi\u00e7\u00e3o, e a palavra-chave infer para extrair tipos de dentro de outros tipos. Leitura e Teoria (Aprofundada) Conditional Types t\u00eam a forma T extends U ? X : Y , que se l\u00ea como: \"Se T for compat\u00edvel com U , ent\u00e3o o tipo \u00e9 X , sen\u00e3o o tipo \u00e9 Y \". infer : A palavra-chave infer pode ser usada dentro da cl\u00e1usula extends para declarar uma nova vari\u00e1vel de tipo gen\u00e9rico. Ela \"captura\" o tipo que est\u00e1 naquela posi\u00e7\u00e3o para que voc\u00ea possa us\u00e1-lo. Exemplo com infer : type UnpackPromise<T> = T extends Promise<infer U> ? U : T; Aqui, infer U captura o tipo que est\u00e1 dentro do Promise (ex: string em Promise<string> ) e o retorna. Se T n\u00e3o for uma Promise , ele retorna T . Documenta\u00e7\u00e3o Essencial Conditional Types (Handbook) Inferring with infer (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Tipo Condicional Simples type IsString<T> = T extends string ? true : false; type A = IsString<string>; // true type B = IsString<number>; // false Exemplo 2: infer para Obter o Tipo de Retorno de uma Fun\u00e7\u00e3o type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : T; type Fn = () => number; type Num = GetReturnType<Fn>; // number type Str = GetReturnType<string>; // string (cai no caso `Y`) Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie um tipo utilit\u00e1rio ElementTypeOf<T> que obt\u00e9m o tipo dos elementos de um array. Se T n\u00e3o for um array, ele deve retornar never . Ex: ElementTypeOf<string[]> deve ser string . Ver Solu\u00e7\u00e3o type ElementTypeOf<T> = T extends (infer E)[] ? E : never; // Teste type A = ElementTypeOf<string[]>; // string type B = ElementTypeOf<number[]>; // number type C = ElementTypeOf<{ name: string }[]>; // { name: string } type D = ElementTypeOf<string>; // never N\u00edvel 2: Intermedi\u00e1rio Implemente seu pr\u00f3prio NonNullable<T> . Este tipo utilit\u00e1rio deve remover null e undefined de um tipo T . Ver Solu\u00e7\u00e3o type MyNonNullable<T> = T extends null | undefined ? never : T; // Teste type A = MyNonNullable<string | null>; // string type B = MyNonNullable<string | number | undefined>; // string | number type C = MyNonNullable<null | undefined>; // never N\u00edvel 3: Avan\u00e7ado Implemente o tipo DeepPartial<T> do plano de estudos. Ele deve tornar todas as propriedades de um objeto e de seus sub-objetos aninhados opcionais. Dica: voc\u00ea precisar\u00e1 de recurs\u00e3o e mapped types. Ver Solu\u00e7\u00e3o type DeepPartial<T> = T extends object ? { // Para cada propriedade P no objeto T [P in keyof T]?: DeepPartial<T[P]>; // Torna a propriedade opcional e aplica DeepPartial recursivamente } : T; // Se T n\u00e3o for um objeto, retorna o pr\u00f3prio tipo // Teste interface UserProfile { id: number; details: { name: string; address: { street: string; city: string; } } } type PartialUserProfile = DeepPartial<UserProfile>; const partialProfile: PartialUserProfile = { id: 1, details: { address: { city: \"S\u00e3o Paulo\" } } }; Checklist do Dia [ ] Entendi a sintaxe T extends U ? X : Y . [ ] Usei infer para extrair um tipo de dentro de outro. [ ] Criei um tipo utilit\u00e1rio condicional simples. [ ] Implementei um tipo utilit\u00e1rio recursivo ( DeepPartial ). Dia 14: Projeto Mini #2 - Sistema de Autentica\u00e7\u00e3o Foco do Dia Consolidar os conceitos da semana (Heran\u00e7a, Generics, Decorators, Conditional Types) para construir um mini-sistema de autentica\u00e7\u00e3o type-safe. Leitura e Teoria (Revis\u00e3o) Abstract Classes : Para definir um contrato para provedores de autentica\u00e7\u00e3o. Generics : Para lidar com diferentes tipos de dados de usu\u00e1rio (ex: User , Admin ). Decorators : Para adicionar verifica\u00e7\u00e3o de permiss\u00f5es de forma declarativa. Conditional Types : Para criar tipos de permiss\u00e3o din\u00e2micos. Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe abstrata AuthProvider com um m\u00e9todo abstrato authenticate(credentials: any): Promise<boolean> . Crie duas classes concretas: EmailProvider e GoogleProvider , que herdam de AuthProvider e implementam o m\u00e9todo authenticate (pode apenas simular a l\u00f3gica e retornar true ). Ver Solu\u00e7\u00e3o abstract class AuthProvider { abstract authenticate(credentials: any): Promise<boolean>; } class EmailProvider extends AuthProvider { async authenticate(credentials: { email: string, pass: string }): Promise<boolean> { console.log(`Autenticando com email: ${credentials.email}`); return true; // Simula\u00e7\u00e3o } } class GoogleProvider extends AuthProvider { async authenticate(credentials: { token: string }): Promise<boolean> { console.log(`Autenticando com token do Google: ${credentials.token.substring(0, 10)}...`); return true; // Simula\u00e7\u00e3o } } // Teste const emailAuth = new EmailProvider(); emailAuth.authenticate({ email: \"test@test.com\", pass: \"123\" }); const googleAuth = new GoogleProvider(); googleAuth.authenticate({ token: \"abc123xyz\" }); N\u00edvel 2: Intermedi\u00e1rio Melhore o sistema do N\u00edvel 1. Torne a classe AuthProvider gen\u00e9rica: AuthProvider<TUser, TCreds> . O m\u00e9todo authenticate deve agora retornar Promise<TUser | null> . Adapte as classes EmailProvider e GoogleProvider para usar tipos espec\u00edficos de usu\u00e1rio e credenciais. Ver Solu\u00e7\u00e3o interface BaseUser { id: number; name: string; } abstract class AuthProvider<TUser extends BaseUser, TCreds> { abstract authenticate(credentials: TCreds): Promise<TUser | null>; } // Tipos para Email interface EmailUser extends BaseUser { email: string; } interface EmailCreds { email: string; pass: string; } class EmailProvider extends AuthProvider<EmailUser, EmailCreds> { async authenticate(credentials: EmailCreds): Promise<EmailUser | null> { console.log(`Autenticando com email: ${credentials.email}`); if (credentials.pass === \"123\") { return { id: 1, name: \"Usu\u00e1rio de Email\", email: credentials.email }; } return null; } } // Tipos para Google interface GoogleUser extends BaseUser { googleId: string; } interface GoogleCreds { token: string; } class GoogleProvider extends AuthProvider<GoogleUser, GoogleCreds> { async authenticate(credentials: GoogleCreds): Promise<GoogleUser | null> { console.log(`Autenticando com token do Google...`); return { id: 2, name: \"Usu\u00e1rio do Google\", googleId: \"g-123\" }; } } // Teste async function testAuth() { const emailAuth = new EmailProvider(); const user1 = await emailAuth.authenticate({ email: \"test@test.com\", pass: \"123\" }); console.log(\"Usu\u00e1rio 1:\", user1); const googleAuth = new GoogleProvider(); const user2 = await googleAuth.authenticate({ token: \"abc123xyz\" }); console.log(\"Usu\u00e1rio 2:\", user2); } testAuth(); N\u00edvel 3: Avan\u00e7ado Crie um decorator de m\u00e9todo @permission(requiredRole: Role) . Crie um enum Role { USER, ADMIN } . Crie uma classe ProtectedService com um usu\u00e1rio logado (que tem uma propriedade role ). Adicione um m\u00e9todo sensitiveData() decorado com @permission('ADMIN') . O decorator deve verificar se o role do usu\u00e1rio na inst\u00e2ncia do servi\u00e7o corresponde ao requiredRole antes de executar o m\u00e9todo. Se n\u00e3o, deve lan\u00e7ar um erro. Ver Solu\u00e7\u00e3o enum Role { USER, ADMIN } interface UserSession { name: string; role: Role; } // Decorator Factory function permission(requiredRole: Role) { return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { // `this` aqui se refere \u00e0 inst\u00e2ncia de ProtectedService const user = (this as any).currentUser as UserSession; if (user && user.role === requiredRole) { console.log(`Permiss\u00e3o concedida para ${user.name} (${user.role}).`); return originalMethod.apply(this, args); } else { throw new Error(\"Acesso negado: permiss\u00e3o insuficiente.\"); } } } } class ProtectedService { currentUser: UserSession; constructor(user: UserSession) { this.currentUser = user; } @permission(Role.ADMIN) deleteEverything(): void { console.log(\"Todos os dados foram deletados com sucesso!\"); } @permission(Role.USER) viewDashboard(): void { console.log(\"Bem-vindo ao seu dashboard!\"); } } // Teste const adminService = new ProtectedService({ name: \"Admin\", role: Role.ADMIN }); const userService = new ProtectedService({ name: \"User\", role: Role.USER }); adminService.deleteEverything(); // OK userService.viewDashboard(); // OK try { userService.deleteEverything(); // Lan\u00e7a erro } catch (e: any) { console.error(e.message); } Checklist do Dia [ ] Usei uma classe abstrata para definir um contrato. [ ] Apliquei generics para tornar o sistema de autentica\u00e7\u00e3o flex\u00edvel. [ ] Criei um decorator para lidar com permiss\u00f5es de forma declarativa. [ ] Combinei m\u00faltiplos conceitos da semana em um \u00fanico projeto.","title":"Semana 2"},{"location":"Ts/Semana2/#semana-2-classes-avancadas-e-generics","text":"","title":"Semana 2: Classes Avan\u00e7adas e Generics"},{"location":"Ts/Semana2/#visao-geral-da-semana","text":"Com os fundamentos s\u00f3lidos, a segunda semana mergulha em conceitos mais poderosos e abstratos. Vamos explorar heran\u00e7a com abstract classes , o poder da reutiliza\u00e7\u00e3o de c\u00f3digo com generics , o uso avan\u00e7ado do this , e introduzir decorators para metaprograma\u00e7\u00e3o. Continuaremos nossa miss\u00e3o de eliminar o any com tipos mais sofisticados como never e branded types , e finalizaremos com a introdu\u00e7\u00e3o aos conditional types , uma das ferramentas mais avan\u00e7adas do TypeScript.","title":"Vis\u00e3o Geral da Semana"},{"location":"Ts/Semana2/#dia-8-heranca-e-abstract-classes","text":"","title":"Dia 8: Heran\u00e7a e Abstract Classes"},{"location":"Ts/Semana2/#foco-do-dia","text":"Entender como criar hierarquias de classes usando heran\u00e7a ( extends ) e como definir \"contratos\" de classes com abstract classes .","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada","text":"Heran\u00e7a ( extends ) : Permite que uma classe (subclasse ou classe filha) herde propriedades e m\u00e9todos de outra classe (superclasse ou classe pai). Isso promove a reutiliza\u00e7\u00e3o de c\u00f3digo. super() : Dentro do constructor de uma subclasse, super() \u00e9 usado para chamar o constructor da classe pai. Isso \u00e9 obrigat\u00f3rio antes de usar a palavra-chave this na subclasse. Sobrescrita de M\u00e9todos (Method Overriding) : Uma subclasse pode fornecer sua pr\u00f3pria implementa\u00e7\u00e3o de um m\u00e9todo que j\u00e1 existe na classe pai. Classes Abstratas ( abstract class ) : S\u00e3o classes que n\u00e3o podem ser instanciadas diretamente. Elas servem como um modelo base para outras classes. Podem conter m\u00e9todos abstratos , que s\u00e3o m\u00e9todos sem implementa\u00e7\u00e3o que devem ser implementados pelas subclasses.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial","text":"Heran\u00e7a de Classes (MDN) Abstract Classes and Members (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo","text":"Exemplo 1: Heran\u00e7a Simples class Animal { constructor(public name: string) {} move(distanceInMeters: number = 0) { console.log(`${this.name} moveu ${distanceInMeters}m.`); } } class Dog extends Animal { // O construtor da subclasse constructor(name: string) { super(name); // Chama o construtor da classe Animal } // Sobrescrevendo o m\u00e9todo move move(distanceInMeters: number = 5) { console.log(\"Correndo...\"); super.move(distanceInMeters); } } const myDog = new Dog(\"Rex\"); myDog.move(10); Exemplo 2: Classes Abstratas abstract class Shape { // M\u00e9todo abstrato: sem implementa\u00e7\u00e3o, deve ser definido na subclasse abstract getArea(): number; // M\u00e9todo concreto: j\u00e1 tem implementa\u00e7\u00e3o e \u00e9 herdado printInfo() { console.log(`Esta \u00e9 uma forma com \u00e1rea de ${this.getArea()}`); } } class Circle extends Shape { constructor(private radius: number) { super(); } // Implementa\u00e7\u00e3o obrigat\u00f3ria do m\u00e9todo abstrato getArea(): number { return Math.PI * this.radius ** 2; } } // const shape = new Shape(); // Erro: N\u00e3o se pode criar inst\u00e2ncia de classe abstrata. const myCircle = new Circle(10); myCircle.printInfo();","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes","text":"N\u00edvel 1: B\u00e1sico Crie uma classe base Vehicle com uma propriedade brand (marca) e um m\u00e9todo startEngine() que imprime \"Motor ligado\". Crie uma subclasse Car que herda de Vehicle e adiciona uma propriedade model . O construtor de Car deve receber brand e model . Ver Solu\u00e7\u00e3o class Vehicle { constructor(public brand: string) {} startEngine(): void { console.log(\"Motor ligado.\"); } } class Car extends Vehicle { constructor(brand: string, public model: string) { super(brand); // Passa a marca para o construtor da classe pai } displayInfo(): void { console.log(`Carro: ${this.brand} ${this.model}`); } } // Teste const myCar = new Car(\"Volkswagen\", \"Gol\"); myCar.displayInfo(); // \"Carro: Volkswagen Gol\" myCar.startEngine(); // \"Motor ligado.\" N\u00edvel 2: Intermedi\u00e1rio Crie uma classe abstrata LoggerBase com um m\u00e9todo abstrato log(message: string) . Crie duas classes concretas que herdam de LoggerBase : ConsoleLogger (que imprime a mensagem no console) e FileLogger (que simula a escrita da mensagem em um arquivo, imprimindo \"Escrevendo no arquivo: [mensagem]\"). Ver Solu\u00e7\u00e3o abstract class LoggerBase { abstract log(message: string): void; logWithTimestamp(message: string): void { const timestamp = new Date().toISOString(); this.log(`[${timestamp}] ${message}`); } } class ConsoleLogger extends LoggerBase { log(message: string): void { console.log(message); } } class FileLogger extends LoggerBase { constructor(private filePath: string) { super(); } log(message: string): void { // Simula\u00e7\u00e3o console.log(`Escrevendo em ${this.filePath}: ${message}`); } } // Teste const consoleLogger = new ConsoleLogger(); consoleLogger.logWithTimestamp(\"Esta \u00e9 uma mensagem de teste.\"); const fileLogger = new FileLogger(\"/var/log/app.log\"); fileLogger.logWithTimestamp(\"Erro cr\u00edtico no sistema.\"); N\u00edvel 3: Avan\u00e7ado Recrie a estrutura do seu GetTableDataService usando uma classe abstrata. Crie uma classe BaseService<TResponse, TParams> com um m\u00e9todo abstrato handle(params: TParams): Promise<TResponse> . Crie uma classe concreta FetchUsersService que herda de BaseService e implementa o m\u00e9todo handle para \"buscar\" uma lista de usu\u00e1rios. Ver Solu\u00e7\u00e3o // Defini\u00e7\u00e3o dos tipos para o servi\u00e7o concreto interface User { id: number; name: string; } interface FetchUsersParams { page: number; limit: number; } // A classe abstrata base abstract class BaseService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; // Um m\u00e9todo concreto que pode ser compartilhado protected logRequest(params: TParams): void { console.log(\"Iniciando requisi\u00e7\u00e3o com os par\u00e2metros:\", params); } } // A implementa\u00e7\u00e3o concreta class FetchUsersService extends BaseService<User[], FetchUsersParams> { async handle(params: FetchUsersParams): Promise<User[]> { this.logRequest(params); console.log(`Buscando usu\u00e1rios... P\u00e1gina: ${params.page}, Limite: ${params.limit}`); // Simula uma chamada de API const fakeUsers: User[] = [ { id: 1, name: \"Lucas\" }, { id: 2, name: \"Ana\" }, ]; return Promise.resolve(fakeUsers); } } // Teste async function runService() { const userService = new FetchUsersService(); const users = await userService.handle({ page: 1, limit: 10 }); console.log(\"Usu\u00e1rios recebidos:\", users); } runService();","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia","text":"[ ] Entendi como extends e super() funcionam. [ ] Sei a diferen\u00e7a entre uma classe normal e uma abstrata. [ ] Implementei um m\u00e9todo abstrato em uma subclasse. [ ] Criei uma hierarquia de classes para reutilizar c\u00f3digo.","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-9-generics-em-classes","text":"","title":"Dia 9: Generics em Classes"},{"location":"Ts/Semana2/#foco-do-dia_1","text":"Escrever classes flex\u00edveis e reutiliz\u00e1veis que podem trabalhar com diferentes tipos de dados usando Generics ( <T> ).","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada_1","text":"Generics permitem que voc\u00ea crie componentes que funcionam com qualquer tipo, em vez de um tipo espec\u00edfico. Isso aumenta drasticamente a reutiliza\u00e7\u00e3o de c\u00f3digo e a seguran\u00e7a de tipo. Par\u00e2metros de Tipo ( <T> ) : A letra T \u00e9 uma conven\u00e7\u00e3o para \"Type\". Voc\u00ea pode usar qualquer nome ( <TData> , <TValue> , etc.). Ela atua como uma vari\u00e1vel para o tipo. Constraints ( extends ) : Voc\u00ea pode restringir os tipos que podem ser usados com um generic. class MyClass<T extends SomeType> significa que T deve ser compat\u00edvel com SomeType . M\u00faltiplos Par\u00e2metros de Tipo : Uma classe pode ter v\u00e1rios par\u00e2metros de tipo, como class Pair<K, V> para um par chave-valor. Tipos Padr\u00e3o : Voc\u00ea pode fornecer um tipo padr\u00e3o para um par\u00e2metro gen\u00e9rico: class MyClass<T = string> .","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial_1","text":"Generics (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo_1","text":"Exemplo 1: Uma Caixa Gen\u00e9rica class Box<T> { private content: T; constructor(initialContent: T) { this.content = initialContent; } getContent(): T { return this.content; } } const stringBox = new Box<string>(\"Ol\u00e1, Generics!\"); const numberBox = new Box<number>(123); console.log(stringBox.getContent().toUpperCase()); console.log(numberBox.getContent().toFixed(2)); Exemplo 2: Generic com Constraints interface WithLength { length: number; } // T pode ser qualquer tipo, desde que tenha uma propriedade `length` class LengthReporter<T extends WithLength> { constructor(private value: T) {} report() { console.log(`O comprimento \u00e9 ${this.value.length}`); } } const stringReporter = new LengthReporter(\"uma string\"); const arrayReporter = new LengthReporter([1, 2, 3]); // const numberReporter = new LengthReporter(123); // Erro: `number` n\u00e3o tem a propriedade `length`. stringReporter.report(); arrayReporter.report();","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_1","text":"N\u00edvel 1: B\u00e1sico Crie uma classe gen\u00e9rica DataStore<T> que armazena um array de itens do tipo T . Ela deve ter os m\u00e9todos add(item: T) e getAll(): T[] . Ver Solu\u00e7\u00e3o class DataStore<T> { private data: T[] = []; add(item: T): void { this.data.push(item); } getAll(): T[] { return this.data; } } // Teste com strings const stringStore = new DataStore<string>(); stringStore.add(\"TypeScript\"); stringStore.add(\"Generics\"); console.log(stringStore.getAll()); // [\"TypeScript\", \"Generics\"] // Teste com n\u00fameros const numberStore = new DataStore<number>(); numberStore.add(10); numberStore.add(20); console.log(numberStore.getAll()); // [10, 20] N\u00edvel 2: Intermedi\u00e1rio Crie uma classe gen\u00e9rica Cache<T> que armazena um valor do tipo T e uma data de expira\u00e7\u00e3o. Implemente os m\u00e9todos set(value: T, ttl: number) (ttl em segundos) e get(): T | null . O m\u00e9todo get deve retornar null se o cache tiver expirado. Ver Solu\u00e7\u00e3o class Cache<T> { private value: T | null = null; private expiresAt: Date | null = null; set(value: T, ttlInSeconds: number): void { this.value = value; const now = new Date(); this.expiresAt = new Date(now.getTime() + ttlInSeconds * 1000); console.log(`Valor armazenado no cache. Expira em: ${this.expiresAt.toLocaleTimeString()}`); } get(): T | null { if (this.expiresAt && this.expiresAt > new Date() && this.value) { console.log(\"Valor retornado do cache.\"); return this.value; } console.log(\"Cache expirado ou vazio.\"); this.value = null; this.expiresAt = null; return null; } } // Teste async function testCache() { const userCache = new Cache<{ name: string }>(); userCache.set({ name: \"Lucas\" }, 3); // Expira em 3 segundos console.log(userCache.get()); // Retorna o objeto await new Promise(resolve => setTimeout(resolve, 4000)); // Espera 4 segundos console.log(userCache.get()); // Retorna null } testCache(); N\u00edvel 3: Avan\u00e7ado Crie uma classe DataService<T extends { id: K }, K extends string | number> . Esta classe deve gerenciar uma cole\u00e7\u00e3o de entidades T . Implemente os m\u00e9todos add(item: T) e findById(id: K): T | undefined . O uso de m\u00faltiplos generics ( T e K ) garante que o tipo do id seja consistente. Ver Solu\u00e7\u00e3o // A constraint gen\u00e9rica interface BaseEntity<K extends string | number> { id: K; } class DataService<T extends BaseEntity<K>, K extends string | number> { private items: Record<K, T> = {} as Record<K, T>; add(item: T): void { this.items[item.id] = item; } findById(id: K): T | undefined { return this.items[id]; } getAll(): T[] { return Object.values(this.items); } } // Teste interface Product { id: number; name: string; price: number; } // O TS infere que K \u00e9 `number` a partir de Product['id'] const productService = new DataService<Product, number>(); productService.add({ id: 101, name: \"Laptop\", price: 5000 }); productService.add({ id: 102, name: \"Mouse\", price: 150 }); console.log(productService.findById(101)); console.log(productService.findById(999)); console.log(productService.getAll());","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_1","text":"[ ] Criei uma classe gen\u00e9rica simples. [ ] Usei constraints ( extends ) para limitar os tipos de um generic. [ ] Entendi como usar m\u00faltiplos par\u00e2metros de tipo. [ ] Apliquei generics para criar uma classe de servi\u00e7o reutiliz\u00e1vel.","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-10-contexto-this-parte-2-avancada","text":"","title":"Dia 10: Contexto this - Parte 2 Avan\u00e7ada"},{"location":"Ts/Semana2/#foco-do-dia_2","text":"Explorar t\u00e9cnicas avan\u00e7adas para controlar o this , incluindo this parameters para adicionar tipagem expl\u00edcita ao this em fun\u00e7\u00f5es e ThisType<T> para fornecer contexto a objetos literais.","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada_2","text":"this Parameters : TypeScript permite que voc\u00ea declare o tipo de this como o primeiro par\u00e2metro de uma fun\u00e7\u00e3o. Este par\u00e2metro \u00e9 falso (n\u00e3o existe no JavaScript compilado), mas \u00e9 usado pelo TypeScript para garantir que a fun\u00e7\u00e3o seja chamada com o contexto correto. ThisType<T> : Um tipo utilit\u00e1rio que n\u00e3o retorna um novo tipo, mas sim modifica o contexto de this dentro de um objeto literal. \u00c9 muito \u00fatil para criar APIs onde voc\u00ea define m\u00e9todos em um objeto, mas quer que this se refira a um tipo maior e mais complexo.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial_2","text":"This Parameters (Handbook) ThisType (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo_2","text":"Exemplo 1: this Parameter para Seguran\u00e7a // A fun\u00e7\u00e3o espera que `this` seja um objeto com uma propriedade `name` function sayHello(this: { name: string }) { console.log(`Hello, ${this.name}!`); } const person = { name: \"Lucas\", sayHello }; const anotherPerson = { name: \"Ana\", sayHello }; person.sayHello(); // OK anotherPerson.sayHello(); // OK // sayHello(); // Erro: O `this` da fun\u00e7\u00e3o n\u00e3o \u00e9 do tipo `{ name: string }`. Exemplo 2: ThisType<T> para Objetos de Configura\u00e7\u00e3o interface ComponentOptions<T> { data: () => T; methods: Record<string, (this: T, ...args: any[]) => any>; } // O tipo `T` em `ThisType<T>` define o tipo de `this` nos m\u00e9todos function createComponent<T>(options: ComponentOptions<T> & { methods: ThisType<T> }): void { // L\u00f3gica de cria\u00e7\u00e3o do componente... console.log(\"Component created.\"); } createComponent({ data: () => ({ count: 0, message: \"Hello\" }), methods: { increment() { // Gra\u00e7as a `ThisType`, o TS sabe que `this` tem `count` e `message` this.count++; }, logMessage() { console.log(this.message); } } });","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_2","text":"N\u00edvel 1: B\u00e1sico Crie uma interface User com name: string . Crie uma fun\u00e7\u00e3o printUserName que n\u00e3o recebe argumentos, mas espera que o this seja do tipo User . Demonstre seu uso correto e incorreto. Ver Solu\u00e7\u00e3o interface User { name: string; } function printUserName(this: User): void { console.log(`User name: ${this.name}`); } // Teste const user1: User = { name: \"Alice\" }; const user2: User = { name: \"Bob\" }; // Para chamar a fun\u00e7\u00e3o, precisamos fornecer o contexto `this` printUserName.call(user1); // \"User name: Alice\" printUserName.apply(user2); // \"User name: Bob\" // const standaloneCall = printUserName; // Erro ao tentar chamar standaloneCall() N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Configuration<T> que armazena um objeto de configura\u00e7\u00e3o. Crie um m\u00e9todo update(updater: (this: T, currentConfig: T) => T) . A fun\u00e7\u00e3o updater deve receber a configura\u00e7\u00e3o atual, mas seu this deve ser tipado como a pr\u00f3pria configura\u00e7\u00e3o T , permitindo acesso direto \u00e0s propriedades. Ver Solu\u00e7\u00e3o class Configuration<T> { constructor(private config: T) {} public update(updater: (this: T, currentConfig: T) => T): void { const newConfig = updater.call(this.config, this.config); this.config = newConfig; } public getConfig(): T { return this.config; } } // Teste interface AppConfig { apiUrl: string; timeout: number; } const myConfig = new Configuration<AppConfig>({ apiUrl: \"/api/v1\", timeout: 5000 }); // A fun\u00e7\u00e3o updater pode usar `this` para acessar as propriedades de AppConfig myConfig.update(function(current) { return { ...current, timeout: this.timeout + 1000 // `this` \u00e9 do tipo AppConfig }; }); console.log(myConfig.getConfig()); // { apiUrl: '/api/v1', timeout: 6000 } N\u00edvel 3: Avan\u00e7ado Implemente a classe FormBuilder<T> do plano de estudos. Ela deve ter um m\u00e9todo field<K extends keyof T>(name: K, value: T[K]): this que adiciona um campo ao formul\u00e1rio. O m\u00e9todo field deve retornar this para encadeamento. Crie um m\u00e9todo build(): T que retorna o objeto de formul\u00e1rio completo. Ver Solu\u00e7\u00e3o class FormBuilder<T extends object> { private formData: Partial<T> = {}; // O tipo de retorno `this` permite o encadeamento public field<K extends keyof T>(name: K, value: T[K]): this { this.formData[name] = value; return this; } // O type guard `this is { formData: T }` ajuda o TS a saber que o form est\u00e1 completo private isComplete(): this is { formData: T } { // Em um cen\u00e1rio real, verificar\u00edamos se todas as chaves de T existem em formData return true; // Simplifica\u00e7\u00e3o para o exerc\u00edcio } public build(): T | Error { if (this.isComplete()) { return this.formData; // Gra\u00e7as ao type guard, o TS sabe que formData \u00e9 T, n\u00e3o Partial<T> } return new Error(\"Formul\u00e1rio incompleto.\"); } } // Teste interface UserForm { name: string; email: string; age: number; } const userFormBuilder = new FormBuilder<UserForm>(); const newUser = userFormBuilder .field(\"name\", \"Lucas\") .field(\"email\", \"lucas@ts.com\") .field(\"age\", 30) .build(); console.log(newUser);","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_2","text":"[ ] Entendi o prop\u00f3sito de um this parameter. [ ] Usei um this parameter para adicionar seguran\u00e7a a uma fun\u00e7\u00e3o. [ ] Entendi como ThisType<T> funciona em objetos literais. [ ] Criei uma classe builder usando this para encadeamento.","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-11-decorators","text":"","title":"Dia 11: Decorators"},{"location":"Ts/Semana2/#foco-do-dia_3","text":"Introduzir decorators , uma proposta do ECMAScript para adicionar anota\u00e7\u00f5es e modificar classes e seus membros em tempo de design.","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada_3","text":"Decorators s\u00e3o fun\u00e7\u00f5es especiais que podem ser anexadas a classes, m\u00e9todos, propriedades ou par\u00e2metros. Eles s\u00e3o executados durante a defini\u00e7\u00e3o da classe, n\u00e3o durante a instancia\u00e7\u00e3o. Para usar decorators, voc\u00ea precisa habilitar a op\u00e7\u00e3o experimentalDecorators no seu tsconfig.json . Tipos de Decorators : Class, Method, Accessor, Property, Parameter. F\u00e1brica de Decorators (Decorator Factory) : Uma fun\u00e7\u00e3o que retorna a express\u00e3o do decorator. Isso permite que voc\u00ea configure o decorator, como @log(\"INFO\") . Composi\u00e7\u00e3o : M\u00faltiplos decorators podem ser aplicados a uma declara\u00e7\u00e3o. reflect-metadata : Uma biblioteca usada para adicionar metadados a classes e propriedades, que podem ser lidos posteriormente pelos decorators.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial_3","text":"Decorators (Handbook) (Nota: esta \u00e9 uma feature experimental)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo_3","text":"Exemplo 1: Decorator de M\u00e9todo Simples // O decorator recebe o alvo (a classe), a chave (nome do m\u00e9todo) e o descritor da propriedade function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { console.log(`Chamando o m\u00e9todo ${propertyKey} com os argumentos:`, args); const result = originalMethod.apply(this, args); console.log(`O m\u00e9todo ${propertyKey} retornou:`, result); return result; } } class Calculator { @log add(a: number, b: number): number { return a + b; } } new Calculator().add(2, 3); Exemplo 2: Decorator Factory function Enumerable(isEnumerable: boolean) { return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = isEnumerable; } } class Person { constructor(private name: string) {} @Enumerable(true) getName() { return this.name; } @Enumerable(false) getAge() { return 30; } } // O m\u00e9todo getName aparecer\u00e1 no loop, mas getAge n\u00e3o. for (const key in new Person(\"Lucas\")) { console.log(key); }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_3","text":"N\u00edvel 1: B\u00e1sico Crie um decorator de m\u00e9todo chamado @deprecated . Quando um m\u00e9todo decorado com ele for chamado, ele deve imprimir um aviso no console: Aviso: O m\u00e9todo [nome do m\u00e9todo] est\u00e1 obsoleto e ser\u00e1 removido em futuras vers\u00f5es. Ver Solu\u00e7\u00e3o function deprecated(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { console.warn(`Aviso: O m\u00e9todo ${propertyKey} est\u00e1 obsoleto e ser\u00e1 removido em futuras vers\u00f5es.`); return originalMethod.apply(this, args); } } class OldApiService { @deprecated findUsers() { console.log(\"Buscando usu\u00e1rios...\"); return [{ name: \"Lucas\" }]; } } // Teste new OldApiService().findUsers(); N\u00edvel 2: Intermedi\u00e1rio Crie um decorator de propriedade @min(minValue: number) . Este decorator deve garantir que, sempre que a propriedade for alterada, seu novo valor n\u00e3o seja menor que minValue . Se for, um erro deve ser lan\u00e7ado. Ver Solu\u00e7\u00e3o function min(minValue: number) { return function(target: any, propertyKey: string) { let value = target[propertyKey]; const getter = () => value; const setter = (newValue: number) => { if (newValue < minValue) { throw new Error(`O valor de ${propertyKey} n\u00e3o pode ser menor que ${minValue}.`); } value = newValue; }; Object.defineProperty(target, propertyKey, { get: getter, set: setter, enumerable: true, configurable: true, }); } } class Product { @min(0) price: number; @min(0) stock: number; constructor(price: number, stock: number) { this.price = price; this.stock = stock; } } // Teste const product = new Product(50, 100); console.log(product.price); // 50 product.price = 75; console.log(product.price); // 75 try { product.stock = -10; } catch (e: any) { console.error(e.message); } N\u00edvel 3: Avan\u00e7ado Crie um decorator de m\u00e9todo @cache . Ele deve armazenar o resultado da primeira chamada do m\u00e9todo. Nas chamadas subsequentes com os mesmos argumentos, ele deve retornar o resultado do cache em vez de executar o m\u00e9todo novamente. Use JSON.stringify para criar uma chave de cache a partir dos argumentos. Ver Solu\u00e7\u00e3o function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; const cache = new Map<string, any>(); descriptor.value = function(...args: any[]) { const cacheKey = JSON.stringify(args); if (cache.has(cacheKey)) { console.log(`Retornando do cache para a chave: ${cacheKey}`); return cache.get(cacheKey); } console.log(`Executando o m\u00e9todo pela primeira vez para a chave: ${cacheKey}`); const result = originalMethod.apply(this, args); cache.set(cacheKey, result); return result; } } class MathOperations { @cache heavyCalculation(a: number, b: number): number { // Simula uma opera\u00e7\u00e3o pesada const start = Date.now(); while (Date.now() - start < 1000) {} return a + b; } } // Teste const math = new MathOperations(); console.log(math.heavyCalculation(2, 3)); // Executa, demora 1s, retorna 5 console.log(math.heavyCalculation(5, 10)); // Executa, demora 1s, retorna 15 console.log(math.heavyCalculation(2, 3)); // Retorna do cache, instant\u00e2neo, retorna 5","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_3","text":"[ ] Habilitei experimentalDecorators no tsconfig.json . [ ] Entendi a diferen\u00e7a entre um decorator e uma decorator factory. [ ] Criei um decorator de m\u00e9todo simples. [ ] Criei um decorator de propriedade que modifica seu comportamento.","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-12-eliminando-any-parte-2","text":"","title":"Dia 12: Eliminando any - Parte 2"},{"location":"Ts/Semana2/#foco-do-dia_4","text":"Introduzir tipos avan\u00e7ados para aumentar a seguran\u00e7a: never para c\u00f3digo inalcan\u00e7\u00e1vel e branded types para criar tipos nominais que o TypeScript n\u00e3o suporta nativamente.","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada_4","text":"never : Representa o tipo de valores que nunca ocorrem. \u00c9 usado em dois cen\u00e1rios principais: Em fun\u00e7\u00f5es que nunca retornam (ex: lan\u00e7am uma exce\u00e7\u00e3o ou entram em um loop infinito). Para fazer verifica\u00e7\u00e3o exaustiva (exhaustive checking) em switch ou if/else , garantindo que todos os casos de uma uni\u00e3o foram tratados. Branded Types (ou Opaque Types) : Uma t\u00e9cnica para criar tipos que s\u00e3o estruturalmente id\u00eanticos (ex: ambos s\u00e3o string ), mas nominalmente diferentes para o TypeScript. Isso evita que voc\u00ea passe um UserID para uma fun\u00e7\u00e3o que espera um ProductID . \u00c9 um padr\u00e3o, n\u00e3o uma feature nativa.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial_4","text":"The never Type (Handbook) Exhaustiveness checking (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo_4","text":"Exemplo 1: never para Verifica\u00e7\u00e3o Exaustiva type Shape = { kind: \"circle\"; radius: number } | { kind: \"square\"; sideLength: number }; function getArea(shape: Shape) { switch (shape.kind) { case \"circle\": return Math.PI * shape.radius ** 2; case \"square\": return shape.sideLength ** 2; default: // Se adicionarmos um novo tipo a Shape (ex: triangle), o TS dar\u00e1 um erro aqui, // pois o novo tipo n\u00e3o pode ser atribu\u00eddo a `never`. const _exhaustiveCheck: never = shape; return _exhaustiveCheck; } } Exemplo 2: Branded Types // O \"brand\" que torna o tipo \u00fanico type Brand<K, T> = K & { __brand: T }; // Criando tipos nominais a partir de tipos primitivos type UserId = Brand<string, \"UserId\">; type ProductId = Brand<string, \"ProductId\">; function getUser(id: UserId) { console.log(`Buscando usu\u00e1rio com ID: ${id}`); } const userId = \"user-123\" as UserId; const productId = \"prod-456\" as ProductId; getUser(userId); // OK // getUser(productId); // Erro! O tipo `ProductId` n\u00e3o \u00e9 compat\u00edvel com `UserId`.","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_4","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o fail(message: string): never que sempre lan\u00e7a um erro com a mensagem fornecida. Use-a em uma fun\u00e7\u00e3o que processa um string | number e chama fail se o tipo n\u00e3o for nenhum dos dois. Ver Solu\u00e7\u00e3o function fail(message: string): never { throw new Error(message); } function processValue(value: string | number) { if (typeof value === 'string') { console.log(\"Processando string:\", value.toUpperCase()); } else if (typeof value === 'number') { console.log(\"Processando n\u00famero:\", value.toFixed(2)); } else { // O TS sabe que este c\u00f3digo \u00e9 inalcan\u00e7\u00e1vel fail(\"Valor inesperado!\"); } } // Teste processValue(\"hello\"); processValue(123); N\u00edvel 2: Intermedi\u00e1rio Crie um branded type Email a partir de string . Crie uma fun\u00e7\u00e3o sendEmail(to: Email, subject: string) que s\u00f3 aceita o tipo Email . Crie uma fun\u00e7\u00e3o createEmail(address: string): Email | null que valida se a string cont\u00e9m um @ antes de fazer a asser\u00e7\u00e3o de tipo para Email . Ver Solu\u00e7\u00e3o type Brand<K, T> = K & { __brand: T }; type Email = Brand<string, \"Email\">; function createEmail(address: string): Email | null { if (address.includes(\"@\")) { return address as Email; } return null; } function sendEmail(to: Email, subject: string): void { console.log(`Enviando email para ${to} com o assunto: \"${subject}\"`); } // Teste const userEmail = createEmail(\"lucas@example.com\"); const invalidEmail = createEmail(\"invalid-address\"); const plainString = \"another@test.com\"; if (userEmail) { sendEmail(userEmail, \"Ol\u00e1!\"); // OK } if (invalidEmail === null) { console.log(\"Endere\u00e7o de email inv\u00e1lido detectado.\"); } // sendEmail(plainString, \"Assunto\"); // Erro: `string` n\u00e3o \u00e9 compat\u00edvel com `Email`. N\u00edvel 3: Avan\u00e7ado Crie um wrapper type-safe para uma biblioteca externa falsa. A biblioteca tem um objeto untypedLibrary que \u00e9 any . Crie fun\u00e7\u00f5es safeGetNumber(key: string) e safeGetString(key: string) que usam o untypedLibrary , verificam o tipo do valor retornado, e o retornam com o tipo correto ou undefined se o tipo n\u00e3o corresponder. Ver Solu\u00e7\u00e3o // A biblioteca externa perigosa declare const untypedLibrary: any; const untypedLibrary = { appName: \"Super App\", version: 2.1, userCount: 1500, settings: { theme: \"dark\" } }; // O wrapper seguro class SafeLibraryWrapper { private lib: any; constructor(library: any) { this.lib = library; } public get(key: string): unknown { return this.lib[key]; } public getString(key: string): string | undefined { const value = this.get(key); if (typeof value === 'string') { return value; } return undefined; } public getNumber(key: string): number | undefined { const value = this.get(key); if (typeof value === 'number') { return value; } return undefined; } } // Teste const safeLib = new SafeLibraryWrapper(untypedLibrary); const appName = safeLib.getString(\"appName\"); const version = safeLib.getNumber(\"version\"); const userCount = safeLib.getNumber(\"userCount\"); const settings = safeLib.getString(\"settings\"); // Retorna undefined, pois n\u00e3o \u00e9 string console.log(`App: ${appName}, Vers\u00e3o: ${version}, Usu\u00e1rios: ${userCount}`); console.log(`Settings (string):`, settings);","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_4","text":"[ ] Entendi o prop\u00f3sito do tipo never . [ ] Usei never para fazer verifica\u00e7\u00e3o exaustiva. [ ] Entendi o padr\u00e3o de Branded Types e por que ele \u00e9 \u00fatil. [ ] Criei e usei um branded type para aumentar a seguran\u00e7a de tipo.","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-13-conditional-types","text":"","title":"Dia 13: Conditional Types"},{"location":"Ts/Semana2/#foco-do-dia_5","text":"Entender Conditional Types , que permitem que um tipo seja escolhido com base em uma condi\u00e7\u00e3o, e a palavra-chave infer para extrair tipos de dentro de outros tipos.","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-aprofundada_5","text":"Conditional Types t\u00eam a forma T extends U ? X : Y , que se l\u00ea como: \"Se T for compat\u00edvel com U , ent\u00e3o o tipo \u00e9 X , sen\u00e3o o tipo \u00e9 Y \". infer : A palavra-chave infer pode ser usada dentro da cl\u00e1usula extends para declarar uma nova vari\u00e1vel de tipo gen\u00e9rico. Ela \"captura\" o tipo que est\u00e1 naquela posi\u00e7\u00e3o para que voc\u00ea possa us\u00e1-lo. Exemplo com infer : type UnpackPromise<T> = T extends Promise<infer U> ? U : T; Aqui, infer U captura o tipo que est\u00e1 dentro do Promise (ex: string em Promise<string> ) e o retorna. Se T n\u00e3o for uma Promise , ele retorna T .","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana2/#documentacao-essencial_5","text":"Conditional Types (Handbook) Inferring with infer (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana2/#pratica-guiada-passo-a-passo_5","text":"Exemplo 1: Tipo Condicional Simples type IsString<T> = T extends string ? true : false; type A = IsString<string>; // true type B = IsString<number>; // false Exemplo 2: infer para Obter o Tipo de Retorno de uma Fun\u00e7\u00e3o type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : T; type Fn = () => number; type Num = GetReturnType<Fn>; // number type Str = GetReturnType<string>; // string (cai no caso `Y`)","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_5","text":"N\u00edvel 1: B\u00e1sico Crie um tipo utilit\u00e1rio ElementTypeOf<T> que obt\u00e9m o tipo dos elementos de um array. Se T n\u00e3o for um array, ele deve retornar never . Ex: ElementTypeOf<string[]> deve ser string . Ver Solu\u00e7\u00e3o type ElementTypeOf<T> = T extends (infer E)[] ? E : never; // Teste type A = ElementTypeOf<string[]>; // string type B = ElementTypeOf<number[]>; // number type C = ElementTypeOf<{ name: string }[]>; // { name: string } type D = ElementTypeOf<string>; // never N\u00edvel 2: Intermedi\u00e1rio Implemente seu pr\u00f3prio NonNullable<T> . Este tipo utilit\u00e1rio deve remover null e undefined de um tipo T . Ver Solu\u00e7\u00e3o type MyNonNullable<T> = T extends null | undefined ? never : T; // Teste type A = MyNonNullable<string | null>; // string type B = MyNonNullable<string | number | undefined>; // string | number type C = MyNonNullable<null | undefined>; // never N\u00edvel 3: Avan\u00e7ado Implemente o tipo DeepPartial<T> do plano de estudos. Ele deve tornar todas as propriedades de um objeto e de seus sub-objetos aninhados opcionais. Dica: voc\u00ea precisar\u00e1 de recurs\u00e3o e mapped types. Ver Solu\u00e7\u00e3o type DeepPartial<T> = T extends object ? { // Para cada propriedade P no objeto T [P in keyof T]?: DeepPartial<T[P]>; // Torna a propriedade opcional e aplica DeepPartial recursivamente } : T; // Se T n\u00e3o for um objeto, retorna o pr\u00f3prio tipo // Teste interface UserProfile { id: number; details: { name: string; address: { street: string; city: string; } } } type PartialUserProfile = DeepPartial<UserProfile>; const partialProfile: PartialUserProfile = { id: 1, details: { address: { city: \"S\u00e3o Paulo\" } } };","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_5","text":"[ ] Entendi a sintaxe T extends U ? X : Y . [ ] Usei infer para extrair um tipo de dentro de outro. [ ] Criei um tipo utilit\u00e1rio condicional simples. [ ] Implementei um tipo utilit\u00e1rio recursivo ( DeepPartial ).","title":"Checklist do Dia"},{"location":"Ts/Semana2/#dia-14-projeto-mini-2-sistema-de-autenticacao","text":"","title":"Dia 14: Projeto Mini #2 - Sistema de Autentica\u00e7\u00e3o"},{"location":"Ts/Semana2/#foco-do-dia_6","text":"Consolidar os conceitos da semana (Heran\u00e7a, Generics, Decorators, Conditional Types) para construir um mini-sistema de autentica\u00e7\u00e3o type-safe.","title":"Foco do Dia"},{"location":"Ts/Semana2/#leitura-e-teoria-revisao","text":"Abstract Classes : Para definir um contrato para provedores de autentica\u00e7\u00e3o. Generics : Para lidar com diferentes tipos de dados de usu\u00e1rio (ex: User , Admin ). Decorators : Para adicionar verifica\u00e7\u00e3o de permiss\u00f5es de forma declarativa. Conditional Types : Para criar tipos de permiss\u00e3o din\u00e2micos.","title":"Leitura e Teoria (Revis\u00e3o)"},{"location":"Ts/Semana2/#exercicios-praticos-niveis-crescentes_6","text":"N\u00edvel 1: B\u00e1sico Crie uma classe abstrata AuthProvider com um m\u00e9todo abstrato authenticate(credentials: any): Promise<boolean> . Crie duas classes concretas: EmailProvider e GoogleProvider , que herdam de AuthProvider e implementam o m\u00e9todo authenticate (pode apenas simular a l\u00f3gica e retornar true ). Ver Solu\u00e7\u00e3o abstract class AuthProvider { abstract authenticate(credentials: any): Promise<boolean>; } class EmailProvider extends AuthProvider { async authenticate(credentials: { email: string, pass: string }): Promise<boolean> { console.log(`Autenticando com email: ${credentials.email}`); return true; // Simula\u00e7\u00e3o } } class GoogleProvider extends AuthProvider { async authenticate(credentials: { token: string }): Promise<boolean> { console.log(`Autenticando com token do Google: ${credentials.token.substring(0, 10)}...`); return true; // Simula\u00e7\u00e3o } } // Teste const emailAuth = new EmailProvider(); emailAuth.authenticate({ email: \"test@test.com\", pass: \"123\" }); const googleAuth = new GoogleProvider(); googleAuth.authenticate({ token: \"abc123xyz\" }); N\u00edvel 2: Intermedi\u00e1rio Melhore o sistema do N\u00edvel 1. Torne a classe AuthProvider gen\u00e9rica: AuthProvider<TUser, TCreds> . O m\u00e9todo authenticate deve agora retornar Promise<TUser | null> . Adapte as classes EmailProvider e GoogleProvider para usar tipos espec\u00edficos de usu\u00e1rio e credenciais. Ver Solu\u00e7\u00e3o interface BaseUser { id: number; name: string; } abstract class AuthProvider<TUser extends BaseUser, TCreds> { abstract authenticate(credentials: TCreds): Promise<TUser | null>; } // Tipos para Email interface EmailUser extends BaseUser { email: string; } interface EmailCreds { email: string; pass: string; } class EmailProvider extends AuthProvider<EmailUser, EmailCreds> { async authenticate(credentials: EmailCreds): Promise<EmailUser | null> { console.log(`Autenticando com email: ${credentials.email}`); if (credentials.pass === \"123\") { return { id: 1, name: \"Usu\u00e1rio de Email\", email: credentials.email }; } return null; } } // Tipos para Google interface GoogleUser extends BaseUser { googleId: string; } interface GoogleCreds { token: string; } class GoogleProvider extends AuthProvider<GoogleUser, GoogleCreds> { async authenticate(credentials: GoogleCreds): Promise<GoogleUser | null> { console.log(`Autenticando com token do Google...`); return { id: 2, name: \"Usu\u00e1rio do Google\", googleId: \"g-123\" }; } } // Teste async function testAuth() { const emailAuth = new EmailProvider(); const user1 = await emailAuth.authenticate({ email: \"test@test.com\", pass: \"123\" }); console.log(\"Usu\u00e1rio 1:\", user1); const googleAuth = new GoogleProvider(); const user2 = await googleAuth.authenticate({ token: \"abc123xyz\" }); console.log(\"Usu\u00e1rio 2:\", user2); } testAuth(); N\u00edvel 3: Avan\u00e7ado Crie um decorator de m\u00e9todo @permission(requiredRole: Role) . Crie um enum Role { USER, ADMIN } . Crie uma classe ProtectedService com um usu\u00e1rio logado (que tem uma propriedade role ). Adicione um m\u00e9todo sensitiveData() decorado com @permission('ADMIN') . O decorator deve verificar se o role do usu\u00e1rio na inst\u00e2ncia do servi\u00e7o corresponde ao requiredRole antes de executar o m\u00e9todo. Se n\u00e3o, deve lan\u00e7ar um erro. Ver Solu\u00e7\u00e3o enum Role { USER, ADMIN } interface UserSession { name: string; role: Role; } // Decorator Factory function permission(requiredRole: Role) { return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) { const originalMethod = descriptor.value; descriptor.value = function(...args: any[]) { // `this` aqui se refere \u00e0 inst\u00e2ncia de ProtectedService const user = (this as any).currentUser as UserSession; if (user && user.role === requiredRole) { console.log(`Permiss\u00e3o concedida para ${user.name} (${user.role}).`); return originalMethod.apply(this, args); } else { throw new Error(\"Acesso negado: permiss\u00e3o insuficiente.\"); } } } } class ProtectedService { currentUser: UserSession; constructor(user: UserSession) { this.currentUser = user; } @permission(Role.ADMIN) deleteEverything(): void { console.log(\"Todos os dados foram deletados com sucesso!\"); } @permission(Role.USER) viewDashboard(): void { console.log(\"Bem-vindo ao seu dashboard!\"); } } // Teste const adminService = new ProtectedService({ name: \"Admin\", role: Role.ADMIN }); const userService = new ProtectedService({ name: \"User\", role: Role.USER }); adminService.deleteEverything(); // OK userService.viewDashboard(); // OK try { userService.deleteEverything(); // Lan\u00e7a erro } catch (e: any) { console.error(e.message); }","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana2/#checklist-do-dia_6","text":"[ ] Usei uma classe abstrata para definir um contrato. [ ] Apliquei generics para tornar o sistema de autentica\u00e7\u00e3o flex\u00edvel. [ ] Criei um decorator para lidar com permiss\u00f5es de forma declarativa. [ ] Combinei m\u00faltiplos conceitos da semana em um \u00fanico projeto.","title":"Checklist do Dia"},{"location":"Ts/Semana3/","text":"Semana 3: Patterns Arquiteturais e Function Types Vis\u00e3o Geral da Semana Na terceira semana, mudamos o foco para padr\u00f5es de c\u00f3digo e arquitetura de software em TypeScript. Come\u00e7aremos com t\u00e9cnicas avan\u00e7adas de tipagem de fun\u00e7\u00f5es, como function overloading , e mergulharemos fundo nos mapped types para transforma\u00e7\u00f5es de tipos complexas. Em seguida, aplicaremos esses conceitos para construir uma camada de servi\u00e7o robusta, implementar um sistema de tratamento de erros type-safe (Result Pattern) e dominar padr\u00f5es avan\u00e7ados com Record . A semana culmina na constru\u00e7\u00e3o de um cliente HTTP type-safe, consolidando tudo o que aprendemos. Dia 15: Function Overloading Foco do Dia Definir m\u00faltiplas assinaturas de tipo para uma \u00fanica fun\u00e7\u00e3o, permitindo que ela se comporte de maneira diferente e retorne tipos diferentes com base nos argumentos fornecidos. Leitura e Teoria (Aprofundada) Function Overloading em TypeScript consiste em duas partes: 1. Assinaturas de Sobrecarga (Overload Signatures) : Uma ou mais declara\u00e7\u00f5es do tipo da fun\u00e7\u00e3o, sem corpo. Elas definem as maneiras p\u00fablicas como a fun\u00e7\u00e3o pode ser chamada. 2. Assinatura de Implementa\u00e7\u00e3o (Implementation Signature) : Uma \u00fanica declara\u00e7\u00e3o de fun\u00e7\u00e3o com um corpo. Sua assinatura de tipo deve ser geral o suficiente para ser compat\u00edvel com todas as assinaturas de sobrecarga. O corpo da fun\u00e7\u00e3o geralmente precisa verificar os tipos dos argumentos para executar a l\u00f3gica correta. O TypeScript s\u00f3 verifica a compatibilidade com as assinaturas de sobrecarga ao chamar a fun\u00e7\u00e3o, n\u00e3o com a assinatura de implementa\u00e7\u00e3o. Documenta\u00e7\u00e3o Essencial Function Overloads (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Sobrecarga Simples // Assinatura 1: recebe n\u00famero, retorna n\u00famero function reverse(x: number): number; // Assinatura 2: recebe string, retorna string function reverse(x: string): string; // Assinatura de Implementa\u00e7\u00e3o function reverse(x: number | string): number | string { if (typeof x === 'string') { return x.split('').reverse().join(''); } return Number(x.toString().split('').reverse().join('')); } const reversedString = reverse(\"hello\"); // O TS sabe que o tipo \u00e9 string const reversedNumber = reverse(12345); // O TS sabe que o tipo \u00e9 number Exemplo 2: Sobrecarga com N\u00famero de Argumentos Diferente // Assinatura 1 function makeDate(timestamp: number): Date; // Assinatura 2 function makeDate(year: number, month: number, day: number): Date; // Assinatura de Implementa\u00e7\u00e3o function makeDate(arg1: number, arg2?: number, arg3?: number): Date { if (arg2 !== undefined && arg3 !== undefined) { return new Date(arg1, arg2, arg3); } return new Date(arg1); } const d1 = makeDate(1234567890); const d2 = makeDate(2023, 11, 24); // const d3 = makeDate(2023, 11); // Erro: Nenhuma sobrecarga corresponde a esta chamada. Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o doubleMe que tem duas sobrecargas: se receber um number , retorna um number (o dobro). Se receber um string , retorna uma string (a string concatenada com ela mesma). Ver Solu\u00e7\u00e3o function doubleMe(x: number): number; function doubleMe(x: string): string; function doubleMe(x: any): any { if (typeof x === 'number') { return x * 2; } if (typeof x === 'string') { return x + x; } } // Teste const numResult = doubleMe(10); // 20 (tipo number) const strResult = doubleMe(\"hi\"); // \"hihi\" (tipo string) console.log(typeof numResult, numResult); console.log(typeof strResult, strResult); N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o createElement . Se ela receber um \u00fanico argumento ( 'div' ), ela deve retornar um HTMLDivElement . Se receber 'input' , deve retornar um HTMLInputElement . Use sobrecargas para tipar o retorno corretamente. Ver Solu\u00e7\u00e3o // Tipos de retorno simulados, j\u00e1 que n\u00e3o estamos no DOM interface HTMLDivElement { type: 'div'; } interface HTMLInputElement { type: 'input'; } // Sobrecargas function createElement(tag: 'div'): HTMLDivElement; function createElement(tag: 'input'): HTMLInputElement; // Implementa\u00e7\u00e3o function createElement(tag: 'div' | 'input'): HTMLDivElement | HTMLInputElement { if (tag === 'div') { return { type: 'div' }; } // Se n\u00e3o for 'div', deve ser 'input' return { type: 'input' }; } // Teste const div = createElement('div'); // O tipo de `div` \u00e9 HTMLDivElement const input = createElement('input'); // O tipo de `input` \u00e9 HTMLInputElement console.log(div.type); console.log(input.type); N\u00edvel 3: Avan\u00e7ado Implemente a fun\u00e7\u00e3o getData do plano de estudos. Ela deve ter duas sobrecargas: 1. getData(id: string): Promise<User> : Busca um \u00fanico usu\u00e1rio. 2. getData(filter: Filter): Promise<User[]> : Busca uma lista de usu\u00e1rios. Simule a l\u00f3gica de busca e os tipos User e Filter . Ver Solu\u00e7\u00e3o interface User { id: string; name: string; } interface Filter { status: 'active' | 'inactive'; } // Sobrecarga 1 function getData(id: string): Promise<User>; // Sobrecarga 2 function getData(filter: Filter): Promise<User[]>; // Implementa\u00e7\u00e3o async function getData(arg: string | Filter): Promise<User | User[]> { if (typeof arg === 'string') { console.log(`Buscando usu\u00e1rio com id: ${arg}`); return { id: arg, name: 'Lucas' }; // Simula\u00e7\u00e3o } console.log(`Buscando usu\u00e1rios com filtro:`, arg); return [ { id: '1', name: 'Ana' }, { id: '2', name: 'Beto' }, ]; // Simula\u00e7\u00e3o } // Teste async function testGetData() { const singleUser = await getData('user-1'); console.log('Usu\u00e1rio \u00fanico:', singleUser.name); const userList = await getData({ status: 'active' }); console.log('Lista de usu\u00e1rios:', userList.length); } testGetData(); Checklist do Dia [ ] Entendi a diferen\u00e7a entre assinatura de sobrecarga e de implementa\u00e7\u00e3o. [ ] Criei uma fun\u00e7\u00e3o com m\u00faltiplas assinaturas de tipo. [ ] Usei sobrecargas para retornar tipos diferentes com base nos argumentos. [ ] Implementei uma fun\u00e7\u00e3o ass\u00edncrona com sobrecargas. Dia 16: Mapped Types Avan\u00e7ados Foco do Dia Dominar Mapped Types para criar novos tipos transformando as propriedades de tipos existentes, incluindo key remapping com as para renomear chaves. Leitura e Teoria (Aprofundada) Mapped Types iteram sobre as chaves de um tipo para criar um novo tipo. A sintaxe \u00e9 [P in keyof T]: ... . Modificadores : Voc\u00ea pode adicionar ou remover modificadores como readonly e ? (opcional) durante o mapeamento. -readonly remove, +readonly (ou apenas readonly ) adiciona. Key Remapping com as : Permite transformar os nomes das chaves. [P in keyof T as NewKeyType] . Template Literal Types em Mapped Types : A combina\u00e7\u00e3o mais poderosa. Permite criar novas chaves baseadas em um padr\u00e3o, como adicionar get ou set como prefixo. Documenta\u00e7\u00e3o Essencial Mapped Types (Handbook) Key Remapping via as (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Criando um tipo de Getters interface Person { name: string; age: number; } // Para cada chave P em Person, cria uma chave `getName`, `getAge` // que \u00e9 uma fun\u00e7\u00e3o retornando o tipo da propriedade original. type Getters<T> = { [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P] }; type PersonGetters = Getters<Person>; // Equivale a: { getName: () => string; getAge: () => number; } Exemplo 2: Removendo readonly interface LockedConfig { readonly apiUrl: string; readonly apiKey: string; } type Mutable<T> = { -readonly [P in keyof T]: T[P] }; type UnlockedConfig = Mutable<LockedConfig>; // Equivale a: { apiUrl: string; apiKey: string; } Exemplo 3: Filtrando Chaves interface User { id: number; name: string; email: string; passwordHash: string; } // Filtra chaves cujo valor n\u00e3o \u00e9 do tipo `string` type StringPropertiesOnly<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] }; type UserStringProps = StringPropertiesOnly<User>; // Equivale a: { name: string; email: string; passwordHash: string; } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie um Mapped Type ObjectWithSetters<T> que pega um objeto T e cria um novo tipo onde cada propriedade prop se torna um m\u00e9todo setProp(value: T[prop]): void . Ver Solu\u00e7\u00e3o type ObjectWithSetters<T> = { [P in keyof T as `set${Capitalize<string & P>}`]: (value: T[P]) => void; }; // Teste interface Settings { theme: string; fontSize: number; } type SettingsSetters = ObjectWithSetters<Settings>; // Esperado: { setTheme: (value: string) => void; setFontSize: (value: number) => void; } const setters: SettingsSetters = { setTheme: (s) => console.log(s), setFontSize: (n) => console.log(n), }; N\u00edvel 2: Intermedi\u00e1rio Crie um Mapped Type FilterByType<T, U> que pega um tipo T e remove todas as propriedades que n\u00e3o s\u00e3o do tipo U . Ver Solu\u00e7\u00e3o type FilterByType<T, U> = { [P in keyof T as T[P] extends U ? P : never]: T[P]; }; // Teste interface MixedBag { name: string; count: number; active: boolean; value: number; } type NumberOnlyBag = FilterByType<MixedBag, number>; // Esperado: { count: number; value: number; } const numbers: NumberOnlyBag = { count: 5, value: 10 }; N\u00edvel 3: Avan\u00e7ado Implemente o FormConfig<T> do plano de estudos. Ele deve pegar um tipo T e gerar um novo tipo onde cada chave K \u00e9 transformada em ${string & K}Config e o valor \u00e9 um objeto de configura\u00e7\u00e3o FieldConfig<T[K]> . Ver Solu\u00e7\u00e3o // Tipo auxiliar para a configura\u00e7\u00e3o do campo interface FieldConfig<T> { label: string; type: T extends string ? 'text' : T extends number ? 'number' : 'checkbox'; defaultValue: T; } // O Mapped Type avan\u00e7ado type FormConfig<T> = { [K in keyof T as `${string & K}Config`]: FieldConfig<T[K]>; }; // Teste interface UserForm { name: string; age: number; isAdmin: boolean; } type GeneratedFormConfig = FormConfig<UserForm>; /* Esperado: { nameConfig: FieldConfig<string>; ageConfig: FieldConfig<number>; isAdminConfig: FieldConfig<boolean>; } */ const userFormConfig: GeneratedFormConfig = { nameConfig: { label: 'Nome', type: 'text', defaultValue: '' }, ageConfig: { label: 'Idade', type: 'number', defaultValue: 0 }, isAdminConfig: { label: '\u00c9 Admin?', type: 'checkbox', defaultValue: false }, }; Checklist do Dia [ ] Criei um mapped type simples. [ ] Usei as para renomear chaves (key remapping). [ ] Combinei mapped types com template literals. [ ] Usei um tipo condicional para filtrar chaves em um mapped type. Dia 17: Service Layer Architecture Foco do Dia Aplicar os conceitos de classes abstratas e interfaces para projetar uma camada de servi\u00e7o (Service Layer) desacoplada e test\u00e1vel. Leitura e Teoria (Aprofundada) Service Layer : Uma camada na arquitetura de uma aplica\u00e7\u00e3o que encapsula a l\u00f3gica de neg\u00f3cio. Ela coordena o trabalho entre a camada de apresenta\u00e7\u00e3o (ex: controllers) e a camada de acesso a dados (ex: repositories). Dependency Injection (DI) : Um padr\u00e3o onde as depend\u00eancias de uma classe (outros objetos que ela precisa para funcionar) s\u00e3o \"injetadas\" de fora (geralmente no construtor), em vez de serem criadas dentro da pr\u00f3pria classe. Isso torna as classes mais desacopladas e f\u00e1ceis de testar, pois voc\u00ea pode injetar \"mocks\" (depend\u00eancias falsas) durante os testes. Interface Segregation Principle : Um dos princ\u00edpios SOLID. Diz que \u00e9 melhor ter muitas interfaces pequenas e espec\u00edficas do que uma \u00fanica interface grande e gen\u00e9rica. Em TypeScript, usamos interface ou type para definir os \"contratos\" que as classes devem seguir. Documenta\u00e7\u00e3o Essencial Interfaces (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Injetando um Reposit\u00f3rio em um Servi\u00e7o // Contrato para o reposit\u00f3rio de usu\u00e1rios interface IUserRepository { findById(id: string): Promise<{ id: string, name: string } | null>; } // Servi\u00e7o que depende do reposit\u00f3rio class UserService { // A depend\u00eancia \u00e9 injetada no construtor constructor(private userRepository: IUserRepository) {} async getUserName(id: string): Promise<string> { const user = await this.userRepository.findById(id); if (!user) { return \"Usu\u00e1rio n\u00e3o encontrado\"; } return user.name; } } // Implementa\u00e7\u00e3o real do reposit\u00f3rio class UserRepository implements IUserRepository { async findById(id: string) { return { id, name: \"Lucas da Silva\" }; // Simula\u00e7\u00e3o } } // Implementa\u00e7\u00e3o falsa (mock) para testes class MockUserRepository implements IUserRepository { async findById(id: string) { if (id === '1') return { id: '1', name: 'Mock User' }; return null; } } // Uso em produ\u00e7\u00e3o const realService = new UserService(new UserRepository()); // Uso em testes const testService = new UserService(new MockUserRepository()); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Defina uma interface INotifier com um m\u00e9todo notify(message: string): void . Crie uma classe OrderService que recebe um INotifier no construtor. Crie um m\u00e9todo placeOrder() na OrderService que, ap\u00f3s simular a cria\u00e7\u00e3o de um pedido, chama notifier.notify(\"Pedido realizado com sucesso!\") . Ver Solu\u00e7\u00e3o interface INotifier { notify(message: string): void; } class EmailNotifier implements INotifier { notify(message: string): void { console.log(`Enviando email: ${message}`); } } class OrderService { constructor(private notifier: INotifier) {} placeOrder(): void { console.log(\"Processando pedido...\"); // L\u00f3gica do pedido... console.log(\"Pedido processado.\"); this.notifier.notify(\"Seu pedido foi realizado com sucesso!\"); } } // Teste const emailNotifier = new EmailNotifier(); const orderService = new OrderService(emailNotifier); orderService.placeOrder(); N\u00edvel 2: Intermedi\u00e1rio Crie uma interface IProductRepository com um m\u00e9todo getProductPrice(productId: number): Promise<number> . Crie uma classe PricingService que depende de IProductRepository . O servi\u00e7o deve ter um m\u00e9todo calculateDiscount(productId: number, discountPercentage: number) que busca o pre\u00e7o do produto e retorna o valor do desconto. Ver Solu\u00e7\u00e3o interface IProductRepository { getProductPrice(productId: number): Promise<number>; } // Implementa\u00e7\u00e3o real class ProductRepository implements IProductRepository { async getProductPrice(productId: number): Promise<number> { // Simula busca no banco de dados const prices: Record<number, number> = { 101: 50, 102: 120 }; return prices[productId] || 0; } } class PricingService { constructor(private productRepo: IProductRepository) {} async calculateDiscount(productId: number, discountPercentage: number): Promise<number> { const price = await this.productRepo.getProductPrice(productId); if (price === 0) { console.log(\"Produto n\u00e3o encontrado.\"); return 0; } const discount = price * (discountPercentage / 100); return discount; } } // Teste async function testPricing() { const repo = new ProductRepository(); const service = new PricingService(repo); const discountValue = await service.calculateDiscount(101, 10); // 10% de 50 console.log(`Valor do desconto: R$${discountValue}`); // 5 } testPricing(); N\u00edvel 3: Avan\u00e7ado Recrie e melhore seu GetTableDataService . Defina uma classe abstrata GetTableDataService<TResponse, TParams> com um m\u00e9todo abstrato handle(params: TParams): Promise<TResponse> . Crie uma implementa\u00e7\u00e3o concreta UserTableService que depende de um IUserRepository (com um m\u00e9todo find(params: TParams) ) injetado no construtor. Ver Solu\u00e7\u00e3o // Contratos e Tipos interface User { id: number; name: string; status: string; } interface UserFindParams { page: number; filterByStatus?: string; } interface IUserRepository { find(params: UserFindParams): Promise<User[]>; } // Classe Abstrata do Servi\u00e7o abstract class GetTableDataService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; } // Implementa\u00e7\u00e3o do Reposit\u00f3rio class UserRepository implements IUserRepository { private allUsers: User[] = [ { id: 1, name: 'Alice', status: 'active' }, { id: 2, name: 'Bob', status: 'inactive' }, { id: 3, name: 'Charlie', status: 'active' }, ]; async find(params: UserFindParams): Promise<User[]> { if (params.filterByStatus) { return this.allUsers.filter(u => u.status === params.filterByStatus); } return this.allUsers; } } // Implementa\u00e7\u00e3o Concreta do Servi\u00e7o class UserTableService extends GetTableDataService<User[], UserFindParams> { constructor(private userRepository: IUserRepository) { super(); } handle(params: UserFindParams): Promise<User[]> { console.log(\"Service: buscando dados da tabela de usu\u00e1rios...\"); return this.userRepository.find(params); } } // Teste async function testTableService() { const repo = new UserRepository(); const tableService = new UserTableService(repo); const activeUsers = await tableService.handle({ page: 1, filterByStatus: 'active' }); console.log(\"Usu\u00e1rios ativos:\", activeUsers); } testTableService(); Checklist do Dia [ ] Entendi o que \u00e9 uma camada de servi\u00e7o. [ ] Usei inje\u00e7\u00e3o de depend\u00eancia para desacoplar uma classe. [ ] Defini um contrato com interface para uma depend\u00eancia. [ ] Implementei um servi\u00e7o que depende de um reposit\u00f3rio. Dia 18: Error Handling Type-Safe Foco do Dia Implementar um sistema de tratamento de erros sem usar try/catch em toda parte, utilizando o padr\u00e3o Result (tamb\u00e9m conhecido como Either ) com discriminated unions. Leitura e Teoria (Aprofundada) Lan\u00e7ar exce\u00e7\u00f5es \u00e9 \u00fatil, mas pode tornar o fluxo de controle dif\u00edcil de seguir. Uma alternativa comum em programa\u00e7\u00e3o funcional \u00e9 fazer com que as fun\u00e7\u00f5es retornem um tipo que representa tanto o sucesso quanto o fracasso. Result Pattern : Uma fun\u00e7\u00e3o, em vez de retornar um valor T ou lan\u00e7ar um Error , retorna um objeto Result<T, E> . Este objeto \u00e9 uma uni\u00e3o discriminada de dois tipos: Success<T> : Cont\u00e9m o valor de sucesso. Failure<E> : Cont\u00e9m o valor do erro. Isso for\u00e7a quem chama a fun\u00e7\u00e3o a verificar explicitamente se a opera\u00e7\u00e3o foi bem-sucedida ou n\u00e3o, tornando o c\u00f3digo mais previs\u00edvel e seguro. Documenta\u00e7\u00e3o Essencial Discriminated Unions (Revis\u00e3o) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Definindo e usando o tipo Result // 1. Definir os tipos Success, Failure e Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; // 2. Criar uma fun\u00e7\u00e3o que retorna um Result function safeDivide(a: number, b: number): Result<number, string> { if (b === 0) { return { success: false, error: \"Divis\u00e3o por zero!\" }; } return { success: true, value: a / b }; } // 3. Consumir a fun\u00e7\u00e3o de forma segura const result = safeDivide(10, 2); if (result.success) { // O TS sabe que `result` \u00e9 Success<number> aqui console.log(\"Resultado:\", result.value); } else { // O TS sabe que `result` \u00e9 Failure<string> aqui console.error(\"Erro:\", result.error); } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o parseNumber(s: string): Result<number, string> que tenta converter uma string para um n\u00famero. Se isNaN(result) for verdadeiro, retorne um Failure . Caso contr\u00e1rio, retorne um Success . Ver Solu\u00e7\u00e3o type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; function parseNumber(s: string): Result<number, string> { const num = Number(s); if (isNaN(num)) { return { success: false, error: `\\'${s}\\' n\u00e3o \u00e9 um n\u00famero v\u00e1lido.` }; } return { success: true, value: num }; } // Teste const res1 = parseNumber(\"123\"); if (res1.success) console.log(res1.value); const res2 = parseNumber(\"abc\"); if (!res2.success) console.error(res2.error); N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Result com m\u00e9todos est\u00e1ticos ok<T>(value: T) e fail<E>(error: E) para facilitar a cria\u00e7\u00e3o. Refatore o exerc\u00edcio anterior para usar Result.ok(...) e Result.fail(...) . Ver Solu\u00e7\u00e3o // Tipos auxiliares class Success<T> { readonly value: T; readonly success = true; constructor(value: T) { this.value = value; } } class Failure<E> { readonly error: E; readonly success = false; constructor(error: E) { this.error = error; } } // A classe Result com m\u00e9todos est\u00e1ticos class Result<T, E> { static ok<T, E>(value: T): Result<T, E> { return new Success(value); } static fail<T, E>(error: E): Result<T, E> { return new Failure(error); } } function parseNumber(s: string): Success<number> | Failure<string> { const num = Number(s); if (isNaN(num)) { return new Failure(`\\'${s}\\' n\u00e3o \u00e9 um n\u00famero v\u00e1lido.`); } return new Success(num); } // Teste const res = parseNumber(\"456\"); if (res.success) { console.log(\"Valor parseado:\", res.value); } N\u00edvel 3: Avan\u00e7ado Crie uma fun\u00e7\u00e3o fetchUserProfile(userId: string): Promise<Result<User, Error>> . Esta fun\u00e7\u00e3o deve simular uma chamada de API. Se o userId for '1' , retorne um Success com um objeto User . Se for qualquer outro valor, retorne um Failure com um new Error(\"Usu\u00e1rio n\u00e3o encontrado\") . Ver Solu\u00e7\u00e3o // Reutilizando os tipos do N\u00edvel 1 type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; interface User { id: string; name: string; } async function fetchUserProfile(userId: string): Promise<Result<User, Error>> { console.log(`Buscando perfil para o usu\u00e1rio ${userId}...`); // Simula\u00e7\u00e3o de chamada de API if (userId === '1') { const user: User = { id: '1', name: 'Admin User' }; return { success: true, value: user }; } return { success: false, error: new Error(\"Usu\u00e1rio n\u00e3o encontrado\") }; } // Teste async function testFetch() { const result1 = await fetchUserProfile('1'); if (result1.success) { console.log(\"Bem-vindo,\", result1.value.name); } else { console.error(result1.error.message); } const result2 = await fetchUserProfile('2'); if (result2.success) { console.log(\"Bem-vindo,\", result2.value.name); } else { console.error(result2.error.message); } } testFetch(); Checklist do Dia [ ] Entendi o Result Pattern e suas vantagens. [ ] Criei um tipo Result usando discriminated unions. [ ] Implementei uma fun\u00e7\u00e3o que retorna Success ou Failure . [ ] Consumi uma fun\u00e7\u00e3o que retorna Result de forma type-safe. Dia 19: Advanced Record Patterns Foco do Dia Explorar usos avan\u00e7ados do tipo Record<K, V> , combinando-o com const assertions para imutabilidade e template literal types para criar dicion\u00e1rios mais seguros e expressivos. Leitura e Teoria (Aprofundada) Record<Keys, Type> : Cria um tipo de objeto com um conjunto espec\u00edfico de chaves ( Keys ) e um tipo de valor ( Type ). const Assertions ( as const ) : Quando usado em um objeto literal, diz ao TypeScript para tratar o objeto como profundamente readonly . As propriedades se tornam readonly e os literais (strings, n\u00fameros) se tornam tipos literais, n\u00e3o tipos gerais ( 'myString' se torna tipo 'myString' , n\u00e3o string ). Combina\u00e7\u00e3o : Usar Record para definir a estrutura e as const para garantir imutabilidade e tipos literais precisos \u00e9 um padr\u00e3o poderoso para configura\u00e7\u00f5es, dicion\u00e1rios de tradu\u00e7\u00e3o, etc. Documenta\u00e7\u00e3o Essencial Utility Types (Revis\u00e3o) Const Assertions (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Dicion\u00e1rio de Configura\u00e7\u00e3o com as const const AppConfig = { API_URL: \"/api\", TIMEOUT: 5000, THEME: \"dark\", } as const; // AppConfig.API_URL = \"/api/v2\"; // Erro: Cannot assign to 'API_URL' because it is a read-only property. // O tipo de THEME \u00e9 'dark', n\u00e3o string! type Theme = typeof AppConfig[\"THEME\"]; // 'dark' Exemplo: Record com Template Literals type IconName = 'user' | 'cart' | 'home'; type IconPath = `/icons/${IconName}.svg`; const iconMap: Record<IconName, IconPath> = { user: '/icons/user.svg', cart: '/icons/cart.svg', home: '/icons/home.svg', }; Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie um objeto HttpStatusCodes que mapeia nomes de status ( OK , NOT_FOUND , SERVER_ERROR ) para seus c\u00f3digos num\u00e9ricos (200, 404, 500). Use as const para garantir que os valores n\u00e3o possam ser alterados. Ver Solu\u00e7\u00e3o const HttpStatusCodes = { OK: 200, NOT_FOUND: 404, SERVER_ERROR: 500, } as const; // Teste console.log(HttpStatusCodes.OK); // 200 // HttpStatusCodes.OK = 201; // Erro: Cannot assign to 'OK' because it is a read-only property. // O tipo de HttpStatusCodes.OK \u00e9 200, n\u00e3o number. type OkStatus = typeof HttpStatusCodes.OK; // 200 N\u00edvel 2: Intermedi\u00e1rio Crie um tipo UserAction ( 'create' | 'edit' | 'delete' ). Crie um objeto actionPermissions que mapeia cada UserAction para um n\u00edvel de permiss\u00e3o ( 'admin' | 'editor' | 'guest' ). Use Record para garantir que todas as a\u00e7\u00f5es sejam mapeadas. Ver Solu\u00e7\u00e3o type UserAction = 'create' | 'edit' | 'delete'; type PermissionLevel = 'admin' | 'editor' | 'guest'; const actionPermissions: Record<UserAction, PermissionLevel> = { create: 'admin', edit: 'editor', delete: 'admin', }; // Teste function checkPermission(action: UserAction) { console.log(`A\u00e7\u00e3o '${action}' requer n\u00edvel '${actionPermissions[action]}'.`); } checkPermission('edit'); // const p: Record<UserAction, PermissionLevel> = { create: 'admin' }; // Erro: Faltam 'edit' e 'delete' N\u00edvel 3: Avan\u00e7ado Implemente o tooltipContent do plano de estudos. Crie um enum ColumnType . Crie um tipo DictionaryPath usando template literals. Crie o objeto tooltipContent usando Record para o mapeamento e as const para imutabilidade total. Ver Solu\u00e7\u00e3o enum ColumnType { YIELD = 'yield', PRICE = 'price', } type DictionaryPath = `min_fare.table.tooltips.${string}`; // O tipo garante que todas as chaves de ColumnType existam e que os valores sigam o padr\u00e3o. const tooltipContent: Record<ColumnType, DictionaryPath> = { [ColumnType.YIELD]: 'min_fare.table.tooltips.yield', [ColumnType.PRICE]: 'min_fare.table.tooltips.price', }; // Adicionando `as const` para imutabilidade e tipos literais precisos const immutableTooltipContent = { [ColumnType.YIELD]: 'min_fare.table.tooltips.yield', [ColumnType.PRICE]: 'min_fare.table.tooltips.price', } as const; // immutableTooltipContent.yield = '...'; // Erro: readonly // O tipo do valor \u00e9 literal, n\u00e3o string type YieldTooltipPath = typeof immutableTooltipContent[ColumnType.YIELD]; Checklist do Dia [ ] Usei as const para criar um objeto imut\u00e1vel. [ ] Entendi como as const afeta a infer\u00eancia de tipo. [ ] Combinei Record com enum para criar um dicion\u00e1rio seguro. [ ] Combinei Record , template literals e as const . Dia 20: Utility Types Avan\u00e7ados Foco do Dia Dominar os utility types que operam sobre fun\u00e7\u00f5es: Parameters , ReturnType , ConstructorParameters , e InstanceType . Leitura e Teoria (Aprofundada) Estes tipos permitem extrair \"partes\" de tipos de fun\u00e7\u00e3o, o que \u00e9 extremamente \u00fatil para metaprograma\u00e7\u00e3o e para manter a consist\u00eancia de tipos sem repeti\u00e7\u00e3o. Parameters<T> : Extrai os tipos dos par\u00e2metros de uma fun\u00e7\u00e3o T como uma tupla. ReturnType<T> : Extrai o tipo de retorno de uma fun\u00e7\u00e3o T . ConstructorParameters<T> : Extrai os tipos dos par\u00e2metros do construtor de uma classe T como uma tupla. InstanceType<T> : Extrai o tipo da inst\u00e2ncia de uma classe T . Documenta\u00e7\u00e3o Essencial Advanced Utility Types (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Parameters e ReturnType function greet(name: string, age: number): string { return `Hello ${name}, you are ${age} years old.`; } type GreetParams = Parameters<typeof greet>; // [string, number] type GreetReturn = ReturnType<typeof greet>; // string Exemplo 2: ConstructorParameters e InstanceType class Person { constructor(public name: string, public age: number) {} } type PersonConstructorParams = ConstructorParameters<typeof Person>; // [string, number] type PersonInstance = InstanceType<typeof Person>; // Person Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o log(message: string, level: 'info' | 'warn' | 'error') . Use Parameters<T> para criar um tipo LogParams que represente os par\u00e2metros da fun\u00e7\u00e3o log . Ver Solu\u00e7\u00e3o function log(message: string, level: 'info' | 'warn' | 'error'): void { console.log(`[${level.toUpperCase()}] ${message}`); } type LogParams = Parameters<typeof log>; // [string, 'info' | 'warn' | 'error'] // Teste const params: LogParams = [\"Usu\u00e1rio logado com sucesso\", \"info\"]; log(...params); N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o fetchData(): Promise<{ data: string[] }> que simula uma chamada de API. Use ReturnType<T> para extrair o tipo de retorno. Em seguida, use Awaited<T> (um tipo nativo) para extrair o tipo resolvido da Promise. Ver Solu\u00e7\u00e3o async function fetchData(): Promise<{ data: string[] }> { return { data: ['a', 'b', 'c'] }; } // O tipo de retorno da fun\u00e7\u00e3o em si type FetchDataReturn = ReturnType<typeof fetchData>; // Promise<{ data: string[] }> // O tipo que a Promise resolve type FetchedData = Awaited<FetchDataReturn>; // { data: string[] } // Teste async function processData() { const data: FetchedData = await fetchData(); console.log(data.data.join(', ')); } processData(); N\u00edvel 3: Avan\u00e7ado Implemente o ServiceFactory<T> do plano de estudos. Deve ser um tipo que representa um objeto com um m\u00e9todo create . Este m\u00e9todo create deve aceitar os mesmos par\u00e2metros que o construtor da classe T e retornar uma inst\u00e2ncia de T . Ver Solu\u00e7\u00e3o // O tipo gen\u00e9rico da f\u00e1brica type ServiceFactory<T extends new (...args: any[]) => any> = { create(...args: ConstructorParameters<T>): InstanceType<T>; }; // Classe de exemplo class ProductService { constructor(private apiVersion: string) { console.log(`ProductService inicializado com API v${apiVersion}`); } getProducts() { /* ... */ } } // Implementa\u00e7\u00e3o da f\u00e1brica const ProductServiceFactory: ServiceFactory<typeof ProductService> = { create(...args) { return new ProductService(...args); }, }; // Teste const productServiceInstance = ProductServiceFactory.create(\"2.0\"); console.log(productServiceInstance instanceof ProductService); // true Checklist do Dia [ ] Usei Parameters para extrair os tipos dos par\u00e2metros de uma fun\u00e7\u00e3o. [ ] Usei ReturnType para extrair o tipo de retorno. [ ] Usei ConstructorParameters e InstanceType em uma classe. [ ] Criei um tipo de f\u00e1brica gen\u00e9rico usando utility types de fun\u00e7\u00e3o. Dia 21: Projeto Mini #3 - HTTP Client Type-Safe Foco do Dia Consolidar os conceitos da semana (Function Overloading, Mapped Types, Service Layer, Result Pattern) para construir um cliente HTTP type-safe. Leitura e Teoria (Revis\u00e3o) Function Overloading : Para criar m\u00e9todos como client.get(...) que podem ter assinaturas diferentes. Result Pattern : Para tratar erros de rede (ex: 404, 500) de forma expl\u00edcita. Generics : Para tipar a resposta esperada da API ( TResponse ). Record Patterns : Para configurar headers e par\u00e2metros. Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma classe HttpClient com um \u00fanico m\u00e9todo get<T>(url: string): Promise<T> . Este m\u00e9todo deve simular uma chamada de rede e retornar um objeto T . N\u00e3o se preocupe com erros ainda. Ver Solu\u00e7\u00e3o class HttpClient { async get<T>(url: string): Promise<T> { console.log(`Fazendo GET para: ${url}`); // Simula\u00e7\u00e3o const response = { data: { id: 1, name: \"Item Falso\" } }; return response as T; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const response = await client.get<UserResponse>(\"/api/users/1\"); console.log(response.data.name); } testClient(); N\u00edvel 2: Intermedi\u00e1rio Melhore o HttpClient do N\u00edvel 1 para usar o Result pattern. O m\u00e9todo get<T>(url: string) deve agora retornar Promise<Result<T, Error>> . Se a URL contiver a palavra 'fail' , simule um erro e retorne um Failure . Caso contr\u00e1rio, retorne um Success . Ver Solu\u00e7\u00e3o // Reutilizando o tipo Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; class HttpClient { async get<T>(url: string): Promise<Result<T, Error>> { console.log(`Fazendo GET para: ${url}`); // Simula\u00e7\u00e3o de erro if (url.includes('fail')) { return { success: false, error: new Error(\"Erro de Rede 404\") }; } // Simula\u00e7\u00e3o de sucesso const response = { data: { id: 1, name: \"Item Falso\" } }; return { success: true, value: response as T }; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const successResult = await client.get<UserResponse>(\"/api/users/1\"); if (successResult.success) { console.log(\"Sucesso:\", successResult.value.data.name); } const errorResult = await client.get<UserResponse>(\"/api/fail/users/1\"); if (!errorResult.success) { console.error(\"Erro:\", errorResult.error.message); } } testClient(); N\u00edvel 3: Avan\u00e7ado Adicione sobrecarga de fun\u00e7\u00e3o ao HttpClient . Crie um m\u00e9todo request com duas sobrecargas: 1. request<T>(method: 'GET', url: string): Promise<Result<T, Error>> 2. request<T>(method: 'POST', url: string, body: any): Promise<Result<T, Error>> Implemente a l\u00f3gica na assinatura de implementa\u00e7\u00e3o para lidar com ambos os casos. Ver Solu\u00e7\u00e3o // Reutilizando o tipo Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; class HttpClient { // Sobrecarga para GET request<T>(method: 'GET', url: string): Promise<Result<T, Error>>; // Sobrecarga para POST request<T>(method: 'POST', url: string, body: any): Promise<Result<T, Error>>; // Implementa\u00e7\u00e3o async request< T >( method: 'GET' | 'POST', url: string, body?: any ): Promise<Result<T, Error>> { console.log(`Fazendo ${method} para: ${url}`); if (method === 'POST') { console.log(\"Corpo da requisi\u00e7\u00e3o:\", body); } // Simula\u00e7\u00e3o de erro if (url.includes('fail')) { return { success: false, error: new Error(`Erro de Rede ${method === 'GET' ? 404 : 500}`) }; } // Simula\u00e7\u00e3o de sucesso const response = { data: { id: 1, name: \"Item Falso\" } }; return { success: true, value: response as T }; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const getResult = await client.request<UserResponse>('GET', \"/api/users/1\"); if (getResult.success) console.log(\"GET Sucesso:\", getResult.value.data.name); const postResult = await client.request<UserResponse>('POST', \"/api/users\", { name: 'Novo Usu\u00e1rio' }); if (postResult.success) console.log(\"POST Sucesso:\", postResult.value.data.name); } testClient(); Checklist do Dia [ ] Usei sobrecarga de fun\u00e7\u00e3o para um m\u00e9todo de cliente HTTP. [ ] Integrei o Result Pattern no tratamento de erros de rede. [ ] Usei generics para tipar a resposta da API. [ ] Combinei m\u00faltiplos conceitos da semana em um \u00fanico projeto.","title":"Semana 3"},{"location":"Ts/Semana3/#semana-3-patterns-arquiteturais-e-function-types","text":"","title":"Semana 3: Patterns Arquiteturais e Function Types"},{"location":"Ts/Semana3/#visao-geral-da-semana","text":"Na terceira semana, mudamos o foco para padr\u00f5es de c\u00f3digo e arquitetura de software em TypeScript. Come\u00e7aremos com t\u00e9cnicas avan\u00e7adas de tipagem de fun\u00e7\u00f5es, como function overloading , e mergulharemos fundo nos mapped types para transforma\u00e7\u00f5es de tipos complexas. Em seguida, aplicaremos esses conceitos para construir uma camada de servi\u00e7o robusta, implementar um sistema de tratamento de erros type-safe (Result Pattern) e dominar padr\u00f5es avan\u00e7ados com Record . A semana culmina na constru\u00e7\u00e3o de um cliente HTTP type-safe, consolidando tudo o que aprendemos.","title":"Vis\u00e3o Geral da Semana"},{"location":"Ts/Semana3/#dia-15-function-overloading","text":"","title":"Dia 15: Function Overloading"},{"location":"Ts/Semana3/#foco-do-dia","text":"Definir m\u00faltiplas assinaturas de tipo para uma \u00fanica fun\u00e7\u00e3o, permitindo que ela se comporte de maneira diferente e retorne tipos diferentes com base nos argumentos fornecidos.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada","text":"Function Overloading em TypeScript consiste em duas partes: 1. Assinaturas de Sobrecarga (Overload Signatures) : Uma ou mais declara\u00e7\u00f5es do tipo da fun\u00e7\u00e3o, sem corpo. Elas definem as maneiras p\u00fablicas como a fun\u00e7\u00e3o pode ser chamada. 2. Assinatura de Implementa\u00e7\u00e3o (Implementation Signature) : Uma \u00fanica declara\u00e7\u00e3o de fun\u00e7\u00e3o com um corpo. Sua assinatura de tipo deve ser geral o suficiente para ser compat\u00edvel com todas as assinaturas de sobrecarga. O corpo da fun\u00e7\u00e3o geralmente precisa verificar os tipos dos argumentos para executar a l\u00f3gica correta. O TypeScript s\u00f3 verifica a compatibilidade com as assinaturas de sobrecarga ao chamar a fun\u00e7\u00e3o, n\u00e3o com a assinatura de implementa\u00e7\u00e3o.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial","text":"Function Overloads (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo","text":"Exemplo 1: Sobrecarga Simples // Assinatura 1: recebe n\u00famero, retorna n\u00famero function reverse(x: number): number; // Assinatura 2: recebe string, retorna string function reverse(x: string): string; // Assinatura de Implementa\u00e7\u00e3o function reverse(x: number | string): number | string { if (typeof x === 'string') { return x.split('').reverse().join(''); } return Number(x.toString().split('').reverse().join('')); } const reversedString = reverse(\"hello\"); // O TS sabe que o tipo \u00e9 string const reversedNumber = reverse(12345); // O TS sabe que o tipo \u00e9 number Exemplo 2: Sobrecarga com N\u00famero de Argumentos Diferente // Assinatura 1 function makeDate(timestamp: number): Date; // Assinatura 2 function makeDate(year: number, month: number, day: number): Date; // Assinatura de Implementa\u00e7\u00e3o function makeDate(arg1: number, arg2?: number, arg3?: number): Date { if (arg2 !== undefined && arg3 !== undefined) { return new Date(arg1, arg2, arg3); } return new Date(arg1); } const d1 = makeDate(1234567890); const d2 = makeDate(2023, 11, 24); // const d3 = makeDate(2023, 11); // Erro: Nenhuma sobrecarga corresponde a esta chamada.","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o doubleMe que tem duas sobrecargas: se receber um number , retorna um number (o dobro). Se receber um string , retorna uma string (a string concatenada com ela mesma). Ver Solu\u00e7\u00e3o function doubleMe(x: number): number; function doubleMe(x: string): string; function doubleMe(x: any): any { if (typeof x === 'number') { return x * 2; } if (typeof x === 'string') { return x + x; } } // Teste const numResult = doubleMe(10); // 20 (tipo number) const strResult = doubleMe(\"hi\"); // \"hihi\" (tipo string) console.log(typeof numResult, numResult); console.log(typeof strResult, strResult); N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o createElement . Se ela receber um \u00fanico argumento ( 'div' ), ela deve retornar um HTMLDivElement . Se receber 'input' , deve retornar um HTMLInputElement . Use sobrecargas para tipar o retorno corretamente. Ver Solu\u00e7\u00e3o // Tipos de retorno simulados, j\u00e1 que n\u00e3o estamos no DOM interface HTMLDivElement { type: 'div'; } interface HTMLInputElement { type: 'input'; } // Sobrecargas function createElement(tag: 'div'): HTMLDivElement; function createElement(tag: 'input'): HTMLInputElement; // Implementa\u00e7\u00e3o function createElement(tag: 'div' | 'input'): HTMLDivElement | HTMLInputElement { if (tag === 'div') { return { type: 'div' }; } // Se n\u00e3o for 'div', deve ser 'input' return { type: 'input' }; } // Teste const div = createElement('div'); // O tipo de `div` \u00e9 HTMLDivElement const input = createElement('input'); // O tipo de `input` \u00e9 HTMLInputElement console.log(div.type); console.log(input.type); N\u00edvel 3: Avan\u00e7ado Implemente a fun\u00e7\u00e3o getData do plano de estudos. Ela deve ter duas sobrecargas: 1. getData(id: string): Promise<User> : Busca um \u00fanico usu\u00e1rio. 2. getData(filter: Filter): Promise<User[]> : Busca uma lista de usu\u00e1rios. Simule a l\u00f3gica de busca e os tipos User e Filter . Ver Solu\u00e7\u00e3o interface User { id: string; name: string; } interface Filter { status: 'active' | 'inactive'; } // Sobrecarga 1 function getData(id: string): Promise<User>; // Sobrecarga 2 function getData(filter: Filter): Promise<User[]>; // Implementa\u00e7\u00e3o async function getData(arg: string | Filter): Promise<User | User[]> { if (typeof arg === 'string') { console.log(`Buscando usu\u00e1rio com id: ${arg}`); return { id: arg, name: 'Lucas' }; // Simula\u00e7\u00e3o } console.log(`Buscando usu\u00e1rios com filtro:`, arg); return [ { id: '1', name: 'Ana' }, { id: '2', name: 'Beto' }, ]; // Simula\u00e7\u00e3o } // Teste async function testGetData() { const singleUser = await getData('user-1'); console.log('Usu\u00e1rio \u00fanico:', singleUser.name); const userList = await getData({ status: 'active' }); console.log('Lista de usu\u00e1rios:', userList.length); } testGetData();","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia","text":"[ ] Entendi a diferen\u00e7a entre assinatura de sobrecarga e de implementa\u00e7\u00e3o. [ ] Criei uma fun\u00e7\u00e3o com m\u00faltiplas assinaturas de tipo. [ ] Usei sobrecargas para retornar tipos diferentes com base nos argumentos. [ ] Implementei uma fun\u00e7\u00e3o ass\u00edncrona com sobrecargas.","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-16-mapped-types-avancados","text":"","title":"Dia 16: Mapped Types Avan\u00e7ados"},{"location":"Ts/Semana3/#foco-do-dia_1","text":"Dominar Mapped Types para criar novos tipos transformando as propriedades de tipos existentes, incluindo key remapping com as para renomear chaves.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada_1","text":"Mapped Types iteram sobre as chaves de um tipo para criar um novo tipo. A sintaxe \u00e9 [P in keyof T]: ... . Modificadores : Voc\u00ea pode adicionar ou remover modificadores como readonly e ? (opcional) durante o mapeamento. -readonly remove, +readonly (ou apenas readonly ) adiciona. Key Remapping com as : Permite transformar os nomes das chaves. [P in keyof T as NewKeyType] . Template Literal Types em Mapped Types : A combina\u00e7\u00e3o mais poderosa. Permite criar novas chaves baseadas em um padr\u00e3o, como adicionar get ou set como prefixo.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial_1","text":"Mapped Types (Handbook) Key Remapping via as (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo_1","text":"Exemplo 1: Criando um tipo de Getters interface Person { name: string; age: number; } // Para cada chave P em Person, cria uma chave `getName`, `getAge` // que \u00e9 uma fun\u00e7\u00e3o retornando o tipo da propriedade original. type Getters<T> = { [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P] }; type PersonGetters = Getters<Person>; // Equivale a: { getName: () => string; getAge: () => number; } Exemplo 2: Removendo readonly interface LockedConfig { readonly apiUrl: string; readonly apiKey: string; } type Mutable<T> = { -readonly [P in keyof T]: T[P] }; type UnlockedConfig = Mutable<LockedConfig>; // Equivale a: { apiUrl: string; apiKey: string; } Exemplo 3: Filtrando Chaves interface User { id: number; name: string; email: string; passwordHash: string; } // Filtra chaves cujo valor n\u00e3o \u00e9 do tipo `string` type StringPropertiesOnly<T> = { [K in keyof T as T[K] extends string ? K : never]: T[K] }; type UserStringProps = StringPropertiesOnly<User>; // Equivale a: { name: string; email: string; passwordHash: string; }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_1","text":"N\u00edvel 1: B\u00e1sico Crie um Mapped Type ObjectWithSetters<T> que pega um objeto T e cria um novo tipo onde cada propriedade prop se torna um m\u00e9todo setProp(value: T[prop]): void . Ver Solu\u00e7\u00e3o type ObjectWithSetters<T> = { [P in keyof T as `set${Capitalize<string & P>}`]: (value: T[P]) => void; }; // Teste interface Settings { theme: string; fontSize: number; } type SettingsSetters = ObjectWithSetters<Settings>; // Esperado: { setTheme: (value: string) => void; setFontSize: (value: number) => void; } const setters: SettingsSetters = { setTheme: (s) => console.log(s), setFontSize: (n) => console.log(n), }; N\u00edvel 2: Intermedi\u00e1rio Crie um Mapped Type FilterByType<T, U> que pega um tipo T e remove todas as propriedades que n\u00e3o s\u00e3o do tipo U . Ver Solu\u00e7\u00e3o type FilterByType<T, U> = { [P in keyof T as T[P] extends U ? P : never]: T[P]; }; // Teste interface MixedBag { name: string; count: number; active: boolean; value: number; } type NumberOnlyBag = FilterByType<MixedBag, number>; // Esperado: { count: number; value: number; } const numbers: NumberOnlyBag = { count: 5, value: 10 }; N\u00edvel 3: Avan\u00e7ado Implemente o FormConfig<T> do plano de estudos. Ele deve pegar um tipo T e gerar um novo tipo onde cada chave K \u00e9 transformada em ${string & K}Config e o valor \u00e9 um objeto de configura\u00e7\u00e3o FieldConfig<T[K]> . Ver Solu\u00e7\u00e3o // Tipo auxiliar para a configura\u00e7\u00e3o do campo interface FieldConfig<T> { label: string; type: T extends string ? 'text' : T extends number ? 'number' : 'checkbox'; defaultValue: T; } // O Mapped Type avan\u00e7ado type FormConfig<T> = { [K in keyof T as `${string & K}Config`]: FieldConfig<T[K]>; }; // Teste interface UserForm { name: string; age: number; isAdmin: boolean; } type GeneratedFormConfig = FormConfig<UserForm>; /* Esperado: { nameConfig: FieldConfig<string>; ageConfig: FieldConfig<number>; isAdminConfig: FieldConfig<boolean>; } */ const userFormConfig: GeneratedFormConfig = { nameConfig: { label: 'Nome', type: 'text', defaultValue: '' }, ageConfig: { label: 'Idade', type: 'number', defaultValue: 0 }, isAdminConfig: { label: '\u00c9 Admin?', type: 'checkbox', defaultValue: false }, };","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_1","text":"[ ] Criei um mapped type simples. [ ] Usei as para renomear chaves (key remapping). [ ] Combinei mapped types com template literals. [ ] Usei um tipo condicional para filtrar chaves em um mapped type.","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-17-service-layer-architecture","text":"","title":"Dia 17: Service Layer Architecture"},{"location":"Ts/Semana3/#foco-do-dia_2","text":"Aplicar os conceitos de classes abstratas e interfaces para projetar uma camada de servi\u00e7o (Service Layer) desacoplada e test\u00e1vel.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada_2","text":"Service Layer : Uma camada na arquitetura de uma aplica\u00e7\u00e3o que encapsula a l\u00f3gica de neg\u00f3cio. Ela coordena o trabalho entre a camada de apresenta\u00e7\u00e3o (ex: controllers) e a camada de acesso a dados (ex: repositories). Dependency Injection (DI) : Um padr\u00e3o onde as depend\u00eancias de uma classe (outros objetos que ela precisa para funcionar) s\u00e3o \"injetadas\" de fora (geralmente no construtor), em vez de serem criadas dentro da pr\u00f3pria classe. Isso torna as classes mais desacopladas e f\u00e1ceis de testar, pois voc\u00ea pode injetar \"mocks\" (depend\u00eancias falsas) durante os testes. Interface Segregation Principle : Um dos princ\u00edpios SOLID. Diz que \u00e9 melhor ter muitas interfaces pequenas e espec\u00edficas do que uma \u00fanica interface grande e gen\u00e9rica. Em TypeScript, usamos interface ou type para definir os \"contratos\" que as classes devem seguir.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial_2","text":"Interfaces (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo_2","text":"Exemplo: Injetando um Reposit\u00f3rio em um Servi\u00e7o // Contrato para o reposit\u00f3rio de usu\u00e1rios interface IUserRepository { findById(id: string): Promise<{ id: string, name: string } | null>; } // Servi\u00e7o que depende do reposit\u00f3rio class UserService { // A depend\u00eancia \u00e9 injetada no construtor constructor(private userRepository: IUserRepository) {} async getUserName(id: string): Promise<string> { const user = await this.userRepository.findById(id); if (!user) { return \"Usu\u00e1rio n\u00e3o encontrado\"; } return user.name; } } // Implementa\u00e7\u00e3o real do reposit\u00f3rio class UserRepository implements IUserRepository { async findById(id: string) { return { id, name: \"Lucas da Silva\" }; // Simula\u00e7\u00e3o } } // Implementa\u00e7\u00e3o falsa (mock) para testes class MockUserRepository implements IUserRepository { async findById(id: string) { if (id === '1') return { id: '1', name: 'Mock User' }; return null; } } // Uso em produ\u00e7\u00e3o const realService = new UserService(new UserRepository()); // Uso em testes const testService = new UserService(new MockUserRepository());","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_2","text":"N\u00edvel 1: B\u00e1sico Defina uma interface INotifier com um m\u00e9todo notify(message: string): void . Crie uma classe OrderService que recebe um INotifier no construtor. Crie um m\u00e9todo placeOrder() na OrderService que, ap\u00f3s simular a cria\u00e7\u00e3o de um pedido, chama notifier.notify(\"Pedido realizado com sucesso!\") . Ver Solu\u00e7\u00e3o interface INotifier { notify(message: string): void; } class EmailNotifier implements INotifier { notify(message: string): void { console.log(`Enviando email: ${message}`); } } class OrderService { constructor(private notifier: INotifier) {} placeOrder(): void { console.log(\"Processando pedido...\"); // L\u00f3gica do pedido... console.log(\"Pedido processado.\"); this.notifier.notify(\"Seu pedido foi realizado com sucesso!\"); } } // Teste const emailNotifier = new EmailNotifier(); const orderService = new OrderService(emailNotifier); orderService.placeOrder(); N\u00edvel 2: Intermedi\u00e1rio Crie uma interface IProductRepository com um m\u00e9todo getProductPrice(productId: number): Promise<number> . Crie uma classe PricingService que depende de IProductRepository . O servi\u00e7o deve ter um m\u00e9todo calculateDiscount(productId: number, discountPercentage: number) que busca o pre\u00e7o do produto e retorna o valor do desconto. Ver Solu\u00e7\u00e3o interface IProductRepository { getProductPrice(productId: number): Promise<number>; } // Implementa\u00e7\u00e3o real class ProductRepository implements IProductRepository { async getProductPrice(productId: number): Promise<number> { // Simula busca no banco de dados const prices: Record<number, number> = { 101: 50, 102: 120 }; return prices[productId] || 0; } } class PricingService { constructor(private productRepo: IProductRepository) {} async calculateDiscount(productId: number, discountPercentage: number): Promise<number> { const price = await this.productRepo.getProductPrice(productId); if (price === 0) { console.log(\"Produto n\u00e3o encontrado.\"); return 0; } const discount = price * (discountPercentage / 100); return discount; } } // Teste async function testPricing() { const repo = new ProductRepository(); const service = new PricingService(repo); const discountValue = await service.calculateDiscount(101, 10); // 10% de 50 console.log(`Valor do desconto: R$${discountValue}`); // 5 } testPricing(); N\u00edvel 3: Avan\u00e7ado Recrie e melhore seu GetTableDataService . Defina uma classe abstrata GetTableDataService<TResponse, TParams> com um m\u00e9todo abstrato handle(params: TParams): Promise<TResponse> . Crie uma implementa\u00e7\u00e3o concreta UserTableService que depende de um IUserRepository (com um m\u00e9todo find(params: TParams) ) injetado no construtor. Ver Solu\u00e7\u00e3o // Contratos e Tipos interface User { id: number; name: string; status: string; } interface UserFindParams { page: number; filterByStatus?: string; } interface IUserRepository { find(params: UserFindParams): Promise<User[]>; } // Classe Abstrata do Servi\u00e7o abstract class GetTableDataService<TResponse, TParams> { abstract handle(params: TParams): Promise<TResponse>; } // Implementa\u00e7\u00e3o do Reposit\u00f3rio class UserRepository implements IUserRepository { private allUsers: User[] = [ { id: 1, name: 'Alice', status: 'active' }, { id: 2, name: 'Bob', status: 'inactive' }, { id: 3, name: 'Charlie', status: 'active' }, ]; async find(params: UserFindParams): Promise<User[]> { if (params.filterByStatus) { return this.allUsers.filter(u => u.status === params.filterByStatus); } return this.allUsers; } } // Implementa\u00e7\u00e3o Concreta do Servi\u00e7o class UserTableService extends GetTableDataService<User[], UserFindParams> { constructor(private userRepository: IUserRepository) { super(); } handle(params: UserFindParams): Promise<User[]> { console.log(\"Service: buscando dados da tabela de usu\u00e1rios...\"); return this.userRepository.find(params); } } // Teste async function testTableService() { const repo = new UserRepository(); const tableService = new UserTableService(repo); const activeUsers = await tableService.handle({ page: 1, filterByStatus: 'active' }); console.log(\"Usu\u00e1rios ativos:\", activeUsers); } testTableService();","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_2","text":"[ ] Entendi o que \u00e9 uma camada de servi\u00e7o. [ ] Usei inje\u00e7\u00e3o de depend\u00eancia para desacoplar uma classe. [ ] Defini um contrato com interface para uma depend\u00eancia. [ ] Implementei um servi\u00e7o que depende de um reposit\u00f3rio.","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-18-error-handling-type-safe","text":"","title":"Dia 18: Error Handling Type-Safe"},{"location":"Ts/Semana3/#foco-do-dia_3","text":"Implementar um sistema de tratamento de erros sem usar try/catch em toda parte, utilizando o padr\u00e3o Result (tamb\u00e9m conhecido como Either ) com discriminated unions.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada_3","text":"Lan\u00e7ar exce\u00e7\u00f5es \u00e9 \u00fatil, mas pode tornar o fluxo de controle dif\u00edcil de seguir. Uma alternativa comum em programa\u00e7\u00e3o funcional \u00e9 fazer com que as fun\u00e7\u00f5es retornem um tipo que representa tanto o sucesso quanto o fracasso. Result Pattern : Uma fun\u00e7\u00e3o, em vez de retornar um valor T ou lan\u00e7ar um Error , retorna um objeto Result<T, E> . Este objeto \u00e9 uma uni\u00e3o discriminada de dois tipos: Success<T> : Cont\u00e9m o valor de sucesso. Failure<E> : Cont\u00e9m o valor do erro. Isso for\u00e7a quem chama a fun\u00e7\u00e3o a verificar explicitamente se a opera\u00e7\u00e3o foi bem-sucedida ou n\u00e3o, tornando o c\u00f3digo mais previs\u00edvel e seguro.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial_3","text":"Discriminated Unions (Revis\u00e3o)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo_3","text":"Exemplo: Definindo e usando o tipo Result // 1. Definir os tipos Success, Failure e Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; // 2. Criar uma fun\u00e7\u00e3o que retorna um Result function safeDivide(a: number, b: number): Result<number, string> { if (b === 0) { return { success: false, error: \"Divis\u00e3o por zero!\" }; } return { success: true, value: a / b }; } // 3. Consumir a fun\u00e7\u00e3o de forma segura const result = safeDivide(10, 2); if (result.success) { // O TS sabe que `result` \u00e9 Success<number> aqui console.log(\"Resultado:\", result.value); } else { // O TS sabe que `result` \u00e9 Failure<string> aqui console.error(\"Erro:\", result.error); }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_3","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o parseNumber(s: string): Result<number, string> que tenta converter uma string para um n\u00famero. Se isNaN(result) for verdadeiro, retorne um Failure . Caso contr\u00e1rio, retorne um Success . Ver Solu\u00e7\u00e3o type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; function parseNumber(s: string): Result<number, string> { const num = Number(s); if (isNaN(num)) { return { success: false, error: `\\'${s}\\' n\u00e3o \u00e9 um n\u00famero v\u00e1lido.` }; } return { success: true, value: num }; } // Teste const res1 = parseNumber(\"123\"); if (res1.success) console.log(res1.value); const res2 = parseNumber(\"abc\"); if (!res2.success) console.error(res2.error); N\u00edvel 2: Intermedi\u00e1rio Crie uma classe Result com m\u00e9todos est\u00e1ticos ok<T>(value: T) e fail<E>(error: E) para facilitar a cria\u00e7\u00e3o. Refatore o exerc\u00edcio anterior para usar Result.ok(...) e Result.fail(...) . Ver Solu\u00e7\u00e3o // Tipos auxiliares class Success<T> { readonly value: T; readonly success = true; constructor(value: T) { this.value = value; } } class Failure<E> { readonly error: E; readonly success = false; constructor(error: E) { this.error = error; } } // A classe Result com m\u00e9todos est\u00e1ticos class Result<T, E> { static ok<T, E>(value: T): Result<T, E> { return new Success(value); } static fail<T, E>(error: E): Result<T, E> { return new Failure(error); } } function parseNumber(s: string): Success<number> | Failure<string> { const num = Number(s); if (isNaN(num)) { return new Failure(`\\'${s}\\' n\u00e3o \u00e9 um n\u00famero v\u00e1lido.`); } return new Success(num); } // Teste const res = parseNumber(\"456\"); if (res.success) { console.log(\"Valor parseado:\", res.value); } N\u00edvel 3: Avan\u00e7ado Crie uma fun\u00e7\u00e3o fetchUserProfile(userId: string): Promise<Result<User, Error>> . Esta fun\u00e7\u00e3o deve simular uma chamada de API. Se o userId for '1' , retorne um Success com um objeto User . Se for qualquer outro valor, retorne um Failure com um new Error(\"Usu\u00e1rio n\u00e3o encontrado\") . Ver Solu\u00e7\u00e3o // Reutilizando os tipos do N\u00edvel 1 type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; interface User { id: string; name: string; } async function fetchUserProfile(userId: string): Promise<Result<User, Error>> { console.log(`Buscando perfil para o usu\u00e1rio ${userId}...`); // Simula\u00e7\u00e3o de chamada de API if (userId === '1') { const user: User = { id: '1', name: 'Admin User' }; return { success: true, value: user }; } return { success: false, error: new Error(\"Usu\u00e1rio n\u00e3o encontrado\") }; } // Teste async function testFetch() { const result1 = await fetchUserProfile('1'); if (result1.success) { console.log(\"Bem-vindo,\", result1.value.name); } else { console.error(result1.error.message); } const result2 = await fetchUserProfile('2'); if (result2.success) { console.log(\"Bem-vindo,\", result2.value.name); } else { console.error(result2.error.message); } } testFetch();","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_3","text":"[ ] Entendi o Result Pattern e suas vantagens. [ ] Criei um tipo Result usando discriminated unions. [ ] Implementei uma fun\u00e7\u00e3o que retorna Success ou Failure . [ ] Consumi uma fun\u00e7\u00e3o que retorna Result de forma type-safe.","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-19-advanced-record-patterns","text":"","title":"Dia 19: Advanced Record Patterns"},{"location":"Ts/Semana3/#foco-do-dia_4","text":"Explorar usos avan\u00e7ados do tipo Record<K, V> , combinando-o com const assertions para imutabilidade e template literal types para criar dicion\u00e1rios mais seguros e expressivos.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada_4","text":"Record<Keys, Type> : Cria um tipo de objeto com um conjunto espec\u00edfico de chaves ( Keys ) e um tipo de valor ( Type ). const Assertions ( as const ) : Quando usado em um objeto literal, diz ao TypeScript para tratar o objeto como profundamente readonly . As propriedades se tornam readonly e os literais (strings, n\u00fameros) se tornam tipos literais, n\u00e3o tipos gerais ( 'myString' se torna tipo 'myString' , n\u00e3o string ). Combina\u00e7\u00e3o : Usar Record para definir a estrutura e as const para garantir imutabilidade e tipos literais precisos \u00e9 um padr\u00e3o poderoso para configura\u00e7\u00f5es, dicion\u00e1rios de tradu\u00e7\u00e3o, etc.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial_4","text":"Utility Types (Revis\u00e3o) Const Assertions (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo_4","text":"Exemplo: Dicion\u00e1rio de Configura\u00e7\u00e3o com as const const AppConfig = { API_URL: \"/api\", TIMEOUT: 5000, THEME: \"dark\", } as const; // AppConfig.API_URL = \"/api/v2\"; // Erro: Cannot assign to 'API_URL' because it is a read-only property. // O tipo de THEME \u00e9 'dark', n\u00e3o string! type Theme = typeof AppConfig[\"THEME\"]; // 'dark' Exemplo: Record com Template Literals type IconName = 'user' | 'cart' | 'home'; type IconPath = `/icons/${IconName}.svg`; const iconMap: Record<IconName, IconPath> = { user: '/icons/user.svg', cart: '/icons/cart.svg', home: '/icons/home.svg', };","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_4","text":"N\u00edvel 1: B\u00e1sico Crie um objeto HttpStatusCodes que mapeia nomes de status ( OK , NOT_FOUND , SERVER_ERROR ) para seus c\u00f3digos num\u00e9ricos (200, 404, 500). Use as const para garantir que os valores n\u00e3o possam ser alterados. Ver Solu\u00e7\u00e3o const HttpStatusCodes = { OK: 200, NOT_FOUND: 404, SERVER_ERROR: 500, } as const; // Teste console.log(HttpStatusCodes.OK); // 200 // HttpStatusCodes.OK = 201; // Erro: Cannot assign to 'OK' because it is a read-only property. // O tipo de HttpStatusCodes.OK \u00e9 200, n\u00e3o number. type OkStatus = typeof HttpStatusCodes.OK; // 200 N\u00edvel 2: Intermedi\u00e1rio Crie um tipo UserAction ( 'create' | 'edit' | 'delete' ). Crie um objeto actionPermissions que mapeia cada UserAction para um n\u00edvel de permiss\u00e3o ( 'admin' | 'editor' | 'guest' ). Use Record para garantir que todas as a\u00e7\u00f5es sejam mapeadas. Ver Solu\u00e7\u00e3o type UserAction = 'create' | 'edit' | 'delete'; type PermissionLevel = 'admin' | 'editor' | 'guest'; const actionPermissions: Record<UserAction, PermissionLevel> = { create: 'admin', edit: 'editor', delete: 'admin', }; // Teste function checkPermission(action: UserAction) { console.log(`A\u00e7\u00e3o '${action}' requer n\u00edvel '${actionPermissions[action]}'.`); } checkPermission('edit'); // const p: Record<UserAction, PermissionLevel> = { create: 'admin' }; // Erro: Faltam 'edit' e 'delete' N\u00edvel 3: Avan\u00e7ado Implemente o tooltipContent do plano de estudos. Crie um enum ColumnType . Crie um tipo DictionaryPath usando template literals. Crie o objeto tooltipContent usando Record para o mapeamento e as const para imutabilidade total. Ver Solu\u00e7\u00e3o enum ColumnType { YIELD = 'yield', PRICE = 'price', } type DictionaryPath = `min_fare.table.tooltips.${string}`; // O tipo garante que todas as chaves de ColumnType existam e que os valores sigam o padr\u00e3o. const tooltipContent: Record<ColumnType, DictionaryPath> = { [ColumnType.YIELD]: 'min_fare.table.tooltips.yield', [ColumnType.PRICE]: 'min_fare.table.tooltips.price', }; // Adicionando `as const` para imutabilidade e tipos literais precisos const immutableTooltipContent = { [ColumnType.YIELD]: 'min_fare.table.tooltips.yield', [ColumnType.PRICE]: 'min_fare.table.tooltips.price', } as const; // immutableTooltipContent.yield = '...'; // Erro: readonly // O tipo do valor \u00e9 literal, n\u00e3o string type YieldTooltipPath = typeof immutableTooltipContent[ColumnType.YIELD];","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_4","text":"[ ] Usei as const para criar um objeto imut\u00e1vel. [ ] Entendi como as const afeta a infer\u00eancia de tipo. [ ] Combinei Record com enum para criar um dicion\u00e1rio seguro. [ ] Combinei Record , template literals e as const .","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-20-utility-types-avancados","text":"","title":"Dia 20: Utility Types Avan\u00e7ados"},{"location":"Ts/Semana3/#foco-do-dia_5","text":"Dominar os utility types que operam sobre fun\u00e7\u00f5es: Parameters , ReturnType , ConstructorParameters , e InstanceType .","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-aprofundada_5","text":"Estes tipos permitem extrair \"partes\" de tipos de fun\u00e7\u00e3o, o que \u00e9 extremamente \u00fatil para metaprograma\u00e7\u00e3o e para manter a consist\u00eancia de tipos sem repeti\u00e7\u00e3o. Parameters<T> : Extrai os tipos dos par\u00e2metros de uma fun\u00e7\u00e3o T como uma tupla. ReturnType<T> : Extrai o tipo de retorno de uma fun\u00e7\u00e3o T . ConstructorParameters<T> : Extrai os tipos dos par\u00e2metros do construtor de uma classe T como uma tupla. InstanceType<T> : Extrai o tipo da inst\u00e2ncia de uma classe T .","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana3/#documentacao-essencial_5","text":"Advanced Utility Types (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana3/#pratica-guiada-passo-a-passo_5","text":"Exemplo 1: Parameters e ReturnType function greet(name: string, age: number): string { return `Hello ${name}, you are ${age} years old.`; } type GreetParams = Parameters<typeof greet>; // [string, number] type GreetReturn = ReturnType<typeof greet>; // string Exemplo 2: ConstructorParameters e InstanceType class Person { constructor(public name: string, public age: number) {} } type PersonConstructorParams = ConstructorParameters<typeof Person>; // [string, number] type PersonInstance = InstanceType<typeof Person>; // Person","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_5","text":"N\u00edvel 1: B\u00e1sico Crie uma fun\u00e7\u00e3o log(message: string, level: 'info' | 'warn' | 'error') . Use Parameters<T> para criar um tipo LogParams que represente os par\u00e2metros da fun\u00e7\u00e3o log . Ver Solu\u00e7\u00e3o function log(message: string, level: 'info' | 'warn' | 'error'): void { console.log(`[${level.toUpperCase()}] ${message}`); } type LogParams = Parameters<typeof log>; // [string, 'info' | 'warn' | 'error'] // Teste const params: LogParams = [\"Usu\u00e1rio logado com sucesso\", \"info\"]; log(...params); N\u00edvel 2: Intermedi\u00e1rio Crie uma fun\u00e7\u00e3o fetchData(): Promise<{ data: string[] }> que simula uma chamada de API. Use ReturnType<T> para extrair o tipo de retorno. Em seguida, use Awaited<T> (um tipo nativo) para extrair o tipo resolvido da Promise. Ver Solu\u00e7\u00e3o async function fetchData(): Promise<{ data: string[] }> { return { data: ['a', 'b', 'c'] }; } // O tipo de retorno da fun\u00e7\u00e3o em si type FetchDataReturn = ReturnType<typeof fetchData>; // Promise<{ data: string[] }> // O tipo que a Promise resolve type FetchedData = Awaited<FetchDataReturn>; // { data: string[] } // Teste async function processData() { const data: FetchedData = await fetchData(); console.log(data.data.join(', ')); } processData(); N\u00edvel 3: Avan\u00e7ado Implemente o ServiceFactory<T> do plano de estudos. Deve ser um tipo que representa um objeto com um m\u00e9todo create . Este m\u00e9todo create deve aceitar os mesmos par\u00e2metros que o construtor da classe T e retornar uma inst\u00e2ncia de T . Ver Solu\u00e7\u00e3o // O tipo gen\u00e9rico da f\u00e1brica type ServiceFactory<T extends new (...args: any[]) => any> = { create(...args: ConstructorParameters<T>): InstanceType<T>; }; // Classe de exemplo class ProductService { constructor(private apiVersion: string) { console.log(`ProductService inicializado com API v${apiVersion}`); } getProducts() { /* ... */ } } // Implementa\u00e7\u00e3o da f\u00e1brica const ProductServiceFactory: ServiceFactory<typeof ProductService> = { create(...args) { return new ProductService(...args); }, }; // Teste const productServiceInstance = ProductServiceFactory.create(\"2.0\"); console.log(productServiceInstance instanceof ProductService); // true","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_5","text":"[ ] Usei Parameters para extrair os tipos dos par\u00e2metros de uma fun\u00e7\u00e3o. [ ] Usei ReturnType para extrair o tipo de retorno. [ ] Usei ConstructorParameters e InstanceType em uma classe. [ ] Criei um tipo de f\u00e1brica gen\u00e9rico usando utility types de fun\u00e7\u00e3o.","title":"Checklist do Dia"},{"location":"Ts/Semana3/#dia-21-projeto-mini-3-http-client-type-safe","text":"","title":"Dia 21: Projeto Mini #3 - HTTP Client Type-Safe"},{"location":"Ts/Semana3/#foco-do-dia_6","text":"Consolidar os conceitos da semana (Function Overloading, Mapped Types, Service Layer, Result Pattern) para construir um cliente HTTP type-safe.","title":"Foco do Dia"},{"location":"Ts/Semana3/#leitura-e-teoria-revisao","text":"Function Overloading : Para criar m\u00e9todos como client.get(...) que podem ter assinaturas diferentes. Result Pattern : Para tratar erros de rede (ex: 404, 500) de forma expl\u00edcita. Generics : Para tipar a resposta esperada da API ( TResponse ). Record Patterns : Para configurar headers e par\u00e2metros.","title":"Leitura e Teoria (Revis\u00e3o)"},{"location":"Ts/Semana3/#exercicios-praticos-niveis-crescentes_6","text":"N\u00edvel 1: B\u00e1sico Crie uma classe HttpClient com um \u00fanico m\u00e9todo get<T>(url: string): Promise<T> . Este m\u00e9todo deve simular uma chamada de rede e retornar um objeto T . N\u00e3o se preocupe com erros ainda. Ver Solu\u00e7\u00e3o class HttpClient { async get<T>(url: string): Promise<T> { console.log(`Fazendo GET para: ${url}`); // Simula\u00e7\u00e3o const response = { data: { id: 1, name: \"Item Falso\" } }; return response as T; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const response = await client.get<UserResponse>(\"/api/users/1\"); console.log(response.data.name); } testClient(); N\u00edvel 2: Intermedi\u00e1rio Melhore o HttpClient do N\u00edvel 1 para usar o Result pattern. O m\u00e9todo get<T>(url: string) deve agora retornar Promise<Result<T, Error>> . Se a URL contiver a palavra 'fail' , simule um erro e retorne um Failure . Caso contr\u00e1rio, retorne um Success . Ver Solu\u00e7\u00e3o // Reutilizando o tipo Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; class HttpClient { async get<T>(url: string): Promise<Result<T, Error>> { console.log(`Fazendo GET para: ${url}`); // Simula\u00e7\u00e3o de erro if (url.includes('fail')) { return { success: false, error: new Error(\"Erro de Rede 404\") }; } // Simula\u00e7\u00e3o de sucesso const response = { data: { id: 1, name: \"Item Falso\" } }; return { success: true, value: response as T }; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const successResult = await client.get<UserResponse>(\"/api/users/1\"); if (successResult.success) { console.log(\"Sucesso:\", successResult.value.data.name); } const errorResult = await client.get<UserResponse>(\"/api/fail/users/1\"); if (!errorResult.success) { console.error(\"Erro:\", errorResult.error.message); } } testClient(); N\u00edvel 3: Avan\u00e7ado Adicione sobrecarga de fun\u00e7\u00e3o ao HttpClient . Crie um m\u00e9todo request com duas sobrecargas: 1. request<T>(method: 'GET', url: string): Promise<Result<T, Error>> 2. request<T>(method: 'POST', url: string, body: any): Promise<Result<T, Error>> Implemente a l\u00f3gica na assinatura de implementa\u00e7\u00e3o para lidar com ambos os casos. Ver Solu\u00e7\u00e3o // Reutilizando o tipo Result type Success<T> = { success: true; value: T }; type Failure<E> = { success: false; error: E }; type Result<T, E> = Success<T> | Failure<E>; class HttpClient { // Sobrecarga para GET request<T>(method: 'GET', url: string): Promise<Result<T, Error>>; // Sobrecarga para POST request<T>(method: 'POST', url: string, body: any): Promise<Result<T, Error>>; // Implementa\u00e7\u00e3o async request< T >( method: 'GET' | 'POST', url: string, body?: any ): Promise<Result<T, Error>> { console.log(`Fazendo ${method} para: ${url}`); if (method === 'POST') { console.log(\"Corpo da requisi\u00e7\u00e3o:\", body); } // Simula\u00e7\u00e3o de erro if (url.includes('fail')) { return { success: false, error: new Error(`Erro de Rede ${method === 'GET' ? 404 : 500}`) }; } // Simula\u00e7\u00e3o de sucesso const response = { data: { id: 1, name: \"Item Falso\" } }; return { success: true, value: response as T }; } } // Teste interface UserResponse { data: { id: number; name: string; } } async function testClient() { const client = new HttpClient(); const getResult = await client.request<UserResponse>('GET', \"/api/users/1\"); if (getResult.success) console.log(\"GET Sucesso:\", getResult.value.data.name); const postResult = await client.request<UserResponse>('POST', \"/api/users\", { name: 'Novo Usu\u00e1rio' }); if (postResult.success) console.log(\"POST Sucesso:\", postResult.value.data.name); } testClient();","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana3/#checklist-do-dia_6","text":"[ ] Usei sobrecarga de fun\u00e7\u00e3o para um m\u00e9todo de cliente HTTP. [ ] Integrei o Result Pattern no tratamento de erros de rede. [ ] Usei generics para tipar a resposta da API. [ ] Combinei m\u00faltiplos conceitos da semana em um \u00fanico projeto.","title":"Checklist do Dia"},{"location":"Ts/Semana4/","text":"Semana 4: Integra\u00e7\u00e3o e Refinamento Vis\u00e3o Geral da Semana Na \u00faltima semana, nosso foco \u00e9 a aplica\u00e7\u00e3o pr\u00e1tica e a integra\u00e7\u00e3o do TypeScript em ecossistemas do mundo real. Vamos aprender a integrar com bibliotecas externas como o React Hook Form, gerenciar estado de forma segura, organizar nosso c\u00f3digo com m\u00f3dulos e path mapping, e escrever testes que tamb\u00e9m validam nossos tipos. Finalizaremos com uma olhada em otimiza\u00e7\u00e3o de performance e padr\u00f5es de design avan\u00e7ados, culminando em um projeto final que une todo o conhecimento adquirido. Dia 22: Form Integration (React Hook Form) Foco do Dia Integrar TypeScript com bibliotecas externas, usando o React Hook Form como exemplo, e aprender a usar Module Augmentation para estender tipos de bibliotecas de terceiros. Leitura e Teoria (Aprofundada) Integra\u00e7\u00e3o com Bibliotecas : Muitas bibliotecas populares (React, Vue, etc.) s\u00e3o escritas em TypeScript ou fornecem seus pr\u00f3prios arquivos de declara\u00e7\u00e3o de tipo ( .d.ts ). Isso nos permite usar a biblioteca de forma type-safe. Tipos Utilit\u00e1rios de Bibliotecas : Bibliotecas como React Hook Form exportam seus pr\u00f3prios tipos utilit\u00e1rios (ex: Control , FieldErrors , UseFormSetValue ) que s\u00e3o gen\u00e9ricos e devem ser usados com os tipos do nosso formul\u00e1rio. Module Augmentation : Permite que voc\u00ea \"adicione\" declara\u00e7\u00f5es a um m\u00f3dulo existente. \u00c9 \u00fatil para estender interfaces de bibliotecas de terceiros para adicionar propriedades customizadas sem precisar criar um fork da biblioteca. Documenta\u00e7\u00e3o Essencial TypeScript com React (React Docs) TypeScript com React Hook Form (RHF Docs) Module Augmentation (Handbook) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Tipando um Formul\u00e1rio Simples com React Hook Form import { useForm, Control, FieldErrors, UseFormSetValue } from 'react-hook-form'; // 1. Definir o tipo dos valores do formul\u00e1rio interface MyFormValues { firstName: string; age: number; } // 2. Usar o tipo com o hook `useForm` function MyForm() { const { control, formState: { errors }, setValue } = useForm<MyFormValues>(); // O tipo de `control` \u00e9 Control<MyFormValues> // O tipo de `errors` \u00e9 FieldErrors<MyFormValues> // O tipo de `setValue` \u00e9 UseFormSetValue<MyFormValues> // ... resto do componente JSX } Exemplo: Recriando seu tipo RenderMinFareForm import { Control, FieldErrors, UseFormSetValue, UseFormClearErrors } from 'react-hook-form'; // O tipo que define os valores do seu formul\u00e1rio interface MinFareFormValue { yield: number; price: number; } // O tipo que agrupa todos os props necess\u00e1rios para renderizar o form export type RenderMinFareForm = { control: Control<MinFareFormValue>; errors: FieldErrors<MinFareFormValue>; setValue: UseFormSetValue<MinFareFormValue>; clearErrors: UseFormClearErrors<MinFareFormValue>; }; Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Defina um tipo para um formul\u00e1rio de login, LoginFormValues , que cont\u00e9m email (string) e password (string). Em seguida, crie um tipo LoginProps que represente as propriedades que um componente de formul\u00e1rio de login receberia, incluindo onSubmit que \u00e9 uma fun\u00e7\u00e3o que recebe os LoginFormValues . Ver Solu\u00e7\u00e3o interface LoginFormValues { email: string; password: string; } type LoginProps = { onSubmit: (data: LoginFormValues) => void; }; // Exemplo de uso em um componente (simulado) function LoginForm(props: LoginProps) { // const { handleSubmit } = useForm<LoginFormValues>(); // return <form onSubmit={handleSubmit(props.onSubmit)}>...</form> console.log(\"Componente de formul\u00e1rio de login renderizado.\"); } N\u00edvel 2: Intermedi\u00e1rio Crie um tipo ProfileFormValues com name (string) e bio (string, opcional). Crie um tipo ProfileFormProps que agrupa as propriedades control e errors do React Hook Form, devidamente tipadas com ProfileFormValues . Ver Solu\u00e7\u00e3o import { Control, FieldErrors } from 'react-hook-form'; interface ProfileFormValues { name: string; bio?: string; } type ProfileFormProps = { control: Control<ProfileFormValues>; errors: FieldErrors<ProfileFormValues>; }; // Simula\u00e7\u00e3o de um componente que recebe esses props function ProfileFormComponent(props: ProfileFormProps) { // <Controller name=\"name\" control={props.control} ... /> // {props.errors.name && <p>Erro no nome</p>} console.log(\"Componente de perfil renderizado.\"); } N\u00edvel 3: Avan\u00e7ado Usando Module Augmentation , estenda a interface DefaultTheme de uma biblioteca de estiliza\u00e7\u00e3o (ex: styled-components ). Adicione uma propriedade customColors que \u00e9 um objeto com chaves primary e secondary . Ver Solu\u00e7\u00e3o // Em um arquivo, ex: styled.d.ts // 1. Importe o tipo original da biblioteca import 'styled-components'; // 2. Declare o m\u00f3dulo novamente para estend\u00ea-lo declare module 'styled-components' { // 3. Estenda a interface DefaultTheme export interface DefaultTheme { customColors: { primary: string; secondary: string; background: string; }; } } // Em outro arquivo, ex: theme.ts import { DefaultTheme } from 'styled-components'; const myTheme: DefaultTheme = { // Agora o TS espera a propriedade customColors customColors: { primary: '#007bff', secondary: '#6c757d', background: '#f8f9fa', }, }; Checklist do Dia [ ] Entendi como usar tipos gen\u00e9ricos de bibliotecas externas. [ ] Criei um tipo para os valores de um formul\u00e1rio. [ ] Agrupei os props de um formul\u00e1rio em um \u00fanico tipo. [ ] Usei Module Augmentation para estender uma interface de biblioteca. Dia 23: State Management Type-Safe Foco do Dia Projetar um sistema de gerenciamento de estado (como Redux ou Zustand) de forma totalmente type-safe, com foco em action creators e selectors tipados. Leitura e Teoria (Aprofundada) Store : Um objeto \u00fanico que cont\u00e9m todo o estado da aplica\u00e7\u00e3o. Actions : Objetos que descrevem uma inten\u00e7\u00e3o de mudar o estado. Geralmente t\u00eam uma propriedade type (uma string literal) e um payload opcional. Reducers : Fun\u00e7\u00f5es puras que recebem o estado atual e uma a\u00e7\u00e3o, e retornam o novo estado. (currentState, action) => newState . Action Creators : Fun\u00e7\u00f5es que criam e retornam objetos de a\u00e7\u00e3o. Ajuda a evitar erros de digita\u00e7\u00e3o no type da a\u00e7\u00e3o. Selectors : Fun\u00e7\u00f5es que extraem e computam dados derivados do estado do store. Memoiza\u00e7\u00e3o (como na biblioteca reselect ) \u00e9 frequentemente usada para performance. Documenta\u00e7\u00e3o Essencial Static Typing com Redux (Redux Docs) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Tipando A\u00e7\u00f5es e Reducer do Redux // 1. Definir o tipo do estado interface CounterState { value: number; } // 2. Definir os tipos das a\u00e7\u00f5es const INCREMENT = 'counter/increment'; const ADD = 'counter/add'; interface IncrementAction { type: typeof INCREMENT; } interface AddAction { type: typeof ADD; payload: number; } type CounterAction = IncrementAction | AddAction; // 3. Criar o reducer const initialState: CounterState = { value: 0 }; function counterReducer(state = initialState, action: CounterAction): CounterState { switch (action.type) { case INCREMENT: return { ...state, value: state.value + 1 }; case ADD: // O TS sabe que `action` tem `payload` aqui return { ...state, value: state.value + action.payload }; default: return state; } } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie os action creators para as a\u00e7\u00f5es IncrementAction e AddAction do exemplo guiado. As fun\u00e7\u00f5es devem retornar os objetos de a\u00e7\u00e3o devidamente tipados. Ver Solu\u00e7\u00e3o // Tipos do exemplo anterior... const INCREMENT = 'counter/increment'; const ADD = 'counter/add'; interface IncrementAction { type: typeof INCREMENT; } interface AddAction { type: typeof ADD; payload: number; } // Action Creators function increment(): IncrementAction { return { type: INCREMENT }; } function add(amount: number): AddAction { return { type: ADD, payload: amount }; } // Teste const incrementAction = increment(); // tipo IncrementAction const addAction = add(5); // tipo AddAction console.log(incrementAction); console.log(addAction); N\u00edvel 2: Intermedi\u00e1rio Defina um estado para uma lista de tarefas ( todos ). Crie os tipos de a\u00e7\u00e3o e o reducer para adicionar uma nova tarefa ( ADD_TODO ) e marcar uma tarefa como completa ( TOGGLE_TODO ). Ver Solu\u00e7\u00e3o // 1. Tipos de Estado interface Todo { id: number; text: string; completed: boolean; } interface TodosState { todos: Todo[]; } // 2. Tipos de A\u00e7\u00e3o const ADD_TODO = 'todos/add'; const TOGGLE_TODO = 'todos/toggle'; interface AddTodoAction { type: typeof ADD_TODO; payload: { text: string } } interface ToggleTodoAction { type: typeof TOGGLE_TODO; payload: { id: number } } type TodoAction = AddTodoAction | ToggleTodoAction; // 3. Reducer const initialTodosState: TodosState = { todos: [] }; let nextTodoId = 0; function todosReducer(state = initialTodosState, action: TodoAction): TodosState { switch (action.type) { case ADD_TODO: return { ...state, todos: [...state.todos, { id: nextTodoId++, text: action.payload.text, completed: false }] }; case TOGGLE_TODO: return { ...state, todos: state.todos.map(todo => todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo ) }; default: return state; } } N\u00edvel 3: Avan\u00e7ado Crie um seletor tipado selectCompletedTodos que recebe o estado completo da aplica\u00e7\u00e3o (que cont\u00e9m todosState ) e retorna apenas a lista de tarefas completas. Ver Solu\u00e7\u00e3o // Reutilizando os tipos do N\u00edvel 2 interface Todo { id: number; text: string; completed: boolean; } interface TodosState { todos: Todo[]; } // Estado global da aplica\u00e7\u00e3o interface AppState { todosState: TodosState; // ... outros estados } // O seletor function selectCompletedTodos(state: AppState): Todo[] { return state.todosState.todos.filter(todo => todo.completed); } // Teste const testState: AppState = { todosState: { todos: [ { id: 0, text: 'Aprender TS', completed: true }, { id: 1, text: 'Dominar o mundo', completed: false }, { id: 2, text: 'Tomar caf\u00e9', completed: true }, ] } }; const completed = selectCompletedTodos(testState); console.log(completed); Checklist do Dia [ ] Defini o tipo para uma fatia (slice) do estado. [ ] Criei tipos de a\u00e7\u00e3o usando discriminated unions. [ ] Implementei um reducer type-safe. [ ] Criei action creators e seletores tipados. Dia 24: Module System e Path Mapping Foco do Dia Organizar a arquitetura de c\u00f3digo usando o sistema de m\u00f3dulos do TypeScript, incluindo barrel exports e path mapping para imports mais limpos. Leitura e Teoria (Aprofundada) M\u00f3dulos : Cada arquivo em TypeScript \u00e9 um m\u00f3dulo. export torna vari\u00e1veis, fun\u00e7\u00f5es e classes dispon\u00edveis para outros m\u00f3dulos. import as consome. Barrel Exports : Um arquivo, geralmente chamado index.ts , que re-exporta todos os exports de um diret\u00f3rio. Isso permite que os consumidores importem tudo de um \u00fanico local, em vez de m\u00faltiplos caminhos. import { ServiceA, ServiceB } from './services'; em vez de ... from './services/ServiceA' e ... from './services/ServiceB' . Path Mapping : Uma feature do tsconfig.json que permite criar aliases para caminhos de importa\u00e7\u00e3o. Isso evita imports relativos longos como ../../../../components e os substitui por aliases como @components . Documenta\u00e7\u00e3o Essencial Modules (Handbook) Path mapping (tsconfig Reference) Pr\u00e1tica Guiada (Passo a Passo) Exemplo 1: Barrel Exports // Em src/utils/stringUtils.ts export const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1); // Em src/utils/numberUtils.ts export const isEven = (n: number) => n % 2 === 0; // Em src/utils/index.ts (o \"barrel\") export * from './stringUtils'; export * from './numberUtils'; // Em outro arquivo import { capitalize, isEven } from '../utils'; // Importa de um \u00fanico lugar Exemplo 2: Configurando Path Mapping No tsconfig.json : { \"compilerOptions\": { \"baseUrl\": \"./src\", // Essencial para o path mapping \"paths\": { \"@components/*\": [\"components/*\"], \"@services/*\": [\"services/*\"], \"@domain/*\": [\"domain/*\"] } } } Uso no c\u00f3digo: // Em vez de: import { User } from '../../domain/models/User'; import { User } from '@domain/models/User'; // Em vez de: import { Button } from '../components/Button'; import { Button } from '@components/Button'; Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma estrutura de pastas domain/errors . Dentro, crie dois arquivos: UnexpectedError.ts e NotFoundError.ts , cada um exportando uma classe de erro. Crie um arquivo index.ts em domain/errors que exporta ambas as classes. Ver Solu\u00e7\u00e3o // Em domain/errors/UnexpectedError.ts export class UnexpectedError extends Error { constructor() { super('Um erro inesperado aconteceu.'); this.name = 'UnexpectedError'; } } // Em domain/errors/NotFoundError.ts export class NotFoundError extends Error { constructor() { super('Recurso n\u00e3o encontrado.'); this.name = 'NotFoundError'; } } // Em domain/errors/index.ts export * from './UnexpectedError'; export * from './NotFoundError'; // Em outro arquivo (ex: app.ts) // import { UnexpectedError, NotFoundError } from './domain/errors'; N\u00edvel 2: Intermedi\u00e1rio Configure o path mapping no seu tsconfig.json para criar um alias @/ que aponte para o diret\u00f3rio src/ . Refatore um import que usa um caminho relativo (ex: ../utils ) para usar o novo alias ( @/utils ). Ver Solu\u00e7\u00e3o No `tsconfig.json`: { \"compilerOptions\": { \"baseUrl\": \".\", // ou \"./src\" \"paths\": { \"@/*\": [\"src/*\"] } } } No c\u00f3digo: // Antes: // import { capitalize } from '../../utils/stringUtils'; // Depois: // import { capitalize } from '@/utils/stringUtils'; N\u00edvel 3: Avan\u00e7ado Crie uma estrutura de m\u00f3dulos para a sua camada de dados, como no seu exemplo. Crie data/protocols/http/ com um index.ts e um http-client.ts . O http-client.ts deve exportar um HttpStatusCode (enum) e uma interface HttpClient . O index.ts deve exportar tudo de http-client.ts . Configure um alias @data para a pasta data . Ver Solu\u00e7\u00e3o No `tsconfig.json`: { \"compilerOptions\": { \"baseUrl\": \"./src\", \"paths\": { \"@data/*\": [\"data/*\"] } } } Estrutura de arquivos: src/ data/ protocols/ http/ http-client.ts index.ts Em `src/data/protocols/http/http-client.ts`: export enum HttpStatusCode { ok = 200, noContent = 204, badRequest = 400, notFound = 404, serverError = 500, } export interface HttpClient<R = any> { request: (data: HttpRequest) => Promise<HttpResponse<R>>; } export type HttpRequest = { url: string; method: string; body?: any; headers?: any; }; export type HttpResponse<R = any> = { statusCode: HttpStatusCode; body?: R; }; Em `src/data/protocols/http/index.ts`: export * from './http-client'; Em outro arquivo: import { HttpStatusCode, HttpClient } from '@data/protocols/http'; Checklist do Dia [ ] Entendi a diferen\u00e7a entre export e export default . [ ] Criei um barrel export ( index.ts ) para simplificar imports. [ ] Configurei baseUrl e paths no tsconfig.json . [ ] Refatorei imports relativos para usar aliases de caminho. Dia 25: Testing Types Foco do Dia Escrever testes que n\u00e3o apenas validam a l\u00f3gica de execu\u00e7\u00e3o, mas tamb\u00e9m a corre\u00e7\u00e3o dos tipos, usando mocks type-safe e testes de asser\u00e7\u00e3o de tipo. Leitura e Teoria (Aprofundada) Mocks Type-Safe : Ao mockar (simular) m\u00f3dulos ou classes, \u00e9 crucial que o mock tenha o mesmo tipo do original. Ferramentas como jest.Mocked<T> ajudam a garantir isso. Testando Tipos : \u00c0s vezes, queremos testar apenas o tipo, n\u00e3o o valor. Por exemplo, garantir que uma fun\u00e7\u00e3o n\u00e3o pode ser chamada com argumentos errados. Isso geralmente \u00e9 feito em arquivos .test-d.ts (testes de declara\u00e7\u00e3o) com ferramentas como tsd ou expect-type . Mock Factories : Criar fun\u00e7\u00f5es que geram mocks consistentes e tipados para os seus testes. Isso reduz a duplica\u00e7\u00e3o de c\u00f3digo nos testes. Documenta\u00e7\u00e3o Essencial TypeScript com Jest Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Mockando um Servi\u00e7o com Tipagem // Em user.service.ts export class UserService { async getUserName(id: string): Promise<string> { // ... l\u00f3gica real return \"Nome Real\"; } } // Em user.controller.test.ts import { UserService } from './user.service'; import { jest } from '@jest/globals'; // Mocka o m\u00f3dulo inteiro jest.mock('./user.service'); // Cria uma vers\u00e3o tipada da classe mockada const MockedUserService = UserService as jest.MockedClass<typeof UserService>; // Teste it('should return user name', async () => { // O TS sabe que `mock.instances[0].getUserName` existe e \u00e9 um mock MockedUserService.prototype.getUserName.mockResolvedValue(\"Nome Mockado\"); const serviceInstance = new UserService(); const name = await serviceInstance.getUserName('1'); expect(name).toBe(\"Nome Mockado\"); }); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Crie uma interface INotifier com um m\u00e9todo notify(message: string) . Crie um mock simples para esta interface em um teste, garantindo que o mock satisfa\u00e7a a interface. Ver Solu\u00e7\u00e3o // Interface original interface INotifier { notify(message: string): void; } // Teste describe('Notifier Test', () => { it('should be called with the correct message', () => { // O mock \u00e9 tipado como a interface const mockNotifier: INotifier = { notify: jest.fn(), // jest.fn() cria uma fun\u00e7\u00e3o mock }; // Simula o uso do notifier mockNotifier.notify(\"hello\"); expect(mockNotifier.notify).toHaveBeenCalledWith(\"hello\"); }); }); N\u00edvel 2: Intermedi\u00e1rio Crie uma \"mock factory\" para um objeto User . A factory deve ser uma fun\u00e7\u00e3o createMockUser(overrides: Partial<User>): User que cria um usu\u00e1rio padr\u00e3o e permite sobrescrever propriedades espec\u00edficas para cada teste. Ver Solu\u00e7\u00e3o interface User { id: string; name: string; email: string; isAdmin: boolean; } function createMockUser(overrides?: Partial<User>): User { const defaultUser: User = { id: 'user-1', name: 'Usu\u00e1rio Padr\u00e3o', email: 'default@test.com', isAdmin: false, }; return { ...defaultUser, ...overrides }; } // Teste describe('Mock User Factory', () => { it('should create a default user', () => { const user = createMockUser(); expect(user.name).toBe('Usu\u00e1rio Padr\u00e3o'); }); it('should override properties', () => { const adminUser = createMockUser({ name: 'Admin', isAdmin: true }); expect(adminUser.name).toBe('Admin'); expect(adminUser.isAdmin).toBe(true); }); }); N\u00edvel 3: Avan\u00e7ado Usando uma ferramenta como expect-type (ou apenas com coment\u00e1rios, se n\u00e3o estiver configurada), escreva um teste de tipo para garantir que uma fun\u00e7\u00e3o add(a: number, b: number) n\u00e3o pode ser chamada com strings. Ver Solu\u00e7\u00e3o import { expectTypeOf } from 'expect-type'; function add(a: number, b: number): number { return a + b; } // Teste de tipo test('type tests for add function', () => { // Verifica se a fun\u00e7\u00e3o aceita n\u00fameros expectTypeOf(add).toBeCallableWith(1, 2); // Verifica se a fun\u00e7\u00e3o N\u00c3O aceita strings expectTypeOf(add).not.toBeCallableWith('1', '2'); // Verifica o tipo de retorno expectTypeOf(add).returns.toBeNumber(); }); **Solu\u00e7\u00e3o sem biblioteca (usando coment\u00e1rios de erro esperado):** function add(a: number, b: number): number { return a + b; } // @ts-expect-error - Testando que isso deve dar um erro de tipo add('1', '2'); const result = add(1, 2); // @ts-expect-error - Testando que o resultado n\u00e3o \u00e9 uma string const resultIsString: string = result; Checklist do Dia [ ] Criei um mock tipado para uma interface. [ ] Usei jest.MockedClass para mockar uma classe. [ ] Criei uma factory para gerar mocks consistentes. [ ] Entendi como testar a corre\u00e7\u00e3o de tipos, n\u00e3o apenas de valores. Dia 26: Performance e Optimization Foco do Dia Entender como tipos complexos podem impactar a performance do compilador TypeScript e aprender t\u00e9cnicas para otimiz\u00e1-los. Leitura e Teoria (Aprofundada) Custo da Tipagem : Tipos muito complexos, especialmente os recursivos ou que geram uni\u00f5es muito grandes, podem deixar o tsc (compilador do TypeScript) e o IntelliSense lentos. An\u00e1lise de Performance : O compilador do TypeScript tem flags para ajudar a diagnosticar problemas de performance, como --diagnostics e --generateTrace . T\u00e9cnicas de Otimiza\u00e7\u00e3o : Evitar Recurs\u00e3o Infinita : Cuidado com tipos recursivos que n\u00e3o t\u00eam um caso base claro. Interfaces vs. Types : Interfaces s\u00e3o geralmente melhores para objetos, pois s\u00e3o extens\u00edveis e podem ser ligeiramente mais perform\u00e1ticas em alguns casos devido \u00e0 forma como s\u00e3o cacheadas internamente. Simplificar Tipos Condicionais : Tente quebrar tipos condicionais complexos em tipos auxiliares menores. Adiar Computa\u00e7\u00e3o de Tipos : Em vez de um tipo que calcula tudo de uma vez, use um tipo gen\u00e9rico que \u00e9 resolvido apenas quando usado. Documenta\u00e7\u00e3o Essencial TypeScript Performance Wiki Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Tipo Recursivo que Pode Ser Lento // Este tipo pode ser lento se a profundidade for grande type DeeplyNested<T> = { content: T; next?: DeeplyNested<T> }; // Uma alternativa pode ser limitar a profundidade, se poss\u00edvel type LimitedDepth<T, D extends number> = D extends 0 ? T : { content: T; next?: LimitedDepth<T, any /* D-1 */> }; // (A matem\u00e1tica de tipos para subtrair 1 \u00e9 complexa, mas a ideia \u00e9 limitar a recurs\u00e3o) Exemplo: Simplificando Uni\u00f5es Grandes // Lento: Gera uma uni\u00e3o de 1000 tipos literais type Thousand = 1 | 2 | 3 | ... | 1000; // Mais perform\u00e1tico: Usa um tipo mais geral e valida em tempo de execu\u00e7\u00e3o type SmallNumber = number & { __brand: 'SmallNumber' }; function createSmallNumber(n: number): SmallNumber | null { if (n > 0 && n <= 1000) return n as SmallNumber; return null; } Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Refatore um tipo que usa type para um objeto para usar interface . Explique por que interface pode ser prefer\u00edvel para objetos que podem ser estendidos. Ver Solu\u00e7\u00e3o // Antes type UserType = { id: number; name: string; }; // Depois (Refatorado) interface UserInterface { id: number; name: string; } // Interfaces podem ser estendidas por outras interfaces e aumentadas (module augmentation). // Isso as torna mais flex\u00edveis para objetos, especialmente em APIs p\u00fablicas. interface AdminUser extends UserInterface { permissions: string[]; } N\u00edvel 2: Intermedi\u00e1rio Dado um tipo ComplexMappedType que faz v\u00e1rias opera\u00e7\u00f5es, quebre-o em tipos utilit\u00e1rios menores e mais leg\u00edveis. Ver Solu\u00e7\u00e3o interface Props { name: string; age: number; onNameChange: (name: string) => void; onAgeChange: (age: number) => void; } // Antes: Um tipo monol\u00edtico type CallbacksOnlyBefore<T> = { [K in keyof T as T[K] extends (...args: any[]) => any ? K : never]: T[K] }; // Depois: Refatorado em tipos menores // 1. Pega as chaves cujos valores s\u00e3o fun\u00e7\u00f5es type FunctionKeys<T> = { [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never }[keyof T]; // 2. Usa Pick para criar o tipo final type CallbacksOnlyAfter<T> = Pick<T, FunctionKeys<T>>; // Teste type PropCallbacks = CallbacksOnlyAfter<Props>; // { onNameChange: (name: string) => void; onAgeChange: (age: number) => void; } N\u00edvel 3: Avan\u00e7ado Crie um tipo Path<T> que gera todas as chaves de um objeto aninhado como uma string com pontos (ex: 'details.address.city' ). Este \u00e9 um tipo inerentemente recursivo e pesado. Pense em como voc\u00ea poderia otimiz\u00e1-lo ou quais seriam seus gargalos de performance. Ver Solu\u00e7\u00e3o // Este tipo \u00e9 conhecido por ser pesado e pode causar lentid\u00e3o no compilador // com objetos muito grandes ou profundos. type Path<T, K extends keyof T = keyof T> = K extends string ? T[K] extends Record<string, any> ? `${K}.${Path<T[K]>}` | K : K : never; // Teste interface UserProfile { id: number; details: { name: string; address: { street: string; city: string; } } } type UserProfilePaths = Path<UserProfile>; // \"id\" | \"details\" | \"details.name\" | \"details.address\" | \"details.address.street\" | \"details.address.city\" /* Otimiza\u00e7\u00e3o/Gargalos: 1. Profundidade da Recurs\u00e3o: A principal causa de lentid\u00e3o. Uma otimiza\u00e7\u00e3o seria adicionar um par\u00e2metro de profundidade para limitar a recurs\u00e3o. 2. Largura do Objeto: Muitos campos em cada n\u00edvel aumentam o n\u00famero de uni\u00f5es geradas. 3. Tipos Condicionais: Cada verifica\u00e7\u00e3o `T[K] extends Record<string, any>` adiciona custo computacional. Uma otimiza\u00e7\u00e3o real em um projeto seria talvez n\u00e3o usar este tipo e preferir uma valida\u00e7\u00e3o em tempo de execu\u00e7\u00e3o para caminhos de objetos. */ Checklist do Dia [ ] Entendi que tipos complexos podem impactar a performance. [ ] Sei a diferen\u00e7a entre interface e type e quando usar cada um. [ ] Refatorei um tipo complexo em tipos auxiliares menores. [ ] Analisei um tipo recursivo e identifiquei seus poss\u00edveis gargalos. Dia 27: Advanced Patterns Foco do Dia Implementar padr\u00f5es de design de software cl\u00e1ssicos (Design Patterns) em TypeScript, aproveitando o sistema de tipos para torn\u00e1-los mais seguros e expressivos. Leitura e Teoria (Aprofundada) Builder Pattern : Usado para construir objetos complexos passo a passo. Permite produzir diferentes tipos e representa\u00e7\u00f5es de um objeto usando o mesmo processo de constru\u00e7\u00e3o. Ideal para objetos com muitos par\u00e2metros de configura\u00e7\u00e3o. Factory Pattern : Usado para criar objetos sem expor a l\u00f3gica de cria\u00e7\u00e3o ao cliente. Uma fun\u00e7\u00e3o ou m\u00e9todo \"f\u00e1brica\" decide qual classe concreta instanciar com base em algum par\u00e2metro. Observer Pattern : Usado para criar uma rela\u00e7\u00e3o de um-para-muitos entre objetos. Quando um objeto (o subject ) muda de estado, todos os seus dependentes (os observers ) s\u00e3o notificados e atualizados automaticamente. Documenta\u00e7\u00e3o Essencial Design Patterns (Refactoring Guru) Pr\u00e1tica Guiada (Passo a Passo) Exemplo: Observer Pattern // A interface para os observadores interface Observer<T> { update(data: T): void; } // O sujeito que os observadores observam class Subject<T> { private observers = new Set<Observer<T>>(); subscribe(observer: Observer<T>) { this.observers.add(observer); } unsubscribe(observer: Observer<T>) { this.observers.delete(observer); } notify(data: T) { this.observers.forEach(observer => observer.update(data)); } } // Exemplo de uso const newsFeed = new Subject<string>(); const observerA = { update: (data: string) => console.log(`Observer A: ${data}`) }; const observerB = { update: (data: string) => console.log(`Observer B: ${data}`) }; newsFeed.subscribe(observerA); newsFeed.subscribe(observerB); newsFeed.notify(\"Nova not\u00edcia importante!\"); Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes) N\u00edvel 1: B\u00e1sico Implemente uma SimpleFactory para criar objetos Logger . A factory deve ter um m\u00e9todo createLogger(type: 'console' | 'file') que retorna uma inst\u00e2ncia de ConsoleLogger ou FileLogger , ambas implementando uma interface ILogger . Ver Solu\u00e7\u00e3o interface ILogger { log(message: string): void; } class ConsoleLogger implements ILogger { log(message: string) { console.log(message); } } class FileLogger implements ILogger { log(message: string) { console.log(`File: ${message}`); } } class LoggerFactory { public createLogger(type: 'console' | 'file'): ILogger { if (type === 'file') { return new FileLogger(); } return new ConsoleLogger(); } } // Teste const factory = new LoggerFactory(); const consoleLogger = factory.createLogger('console'); const fileLogger = factory.createLogger('file'); consoleLogger.log(\"Teste console\"); fileLogger.log(\"Teste arquivo\"); N\u00edvel 2: Intermedi\u00e1rio Implemente o Builder Pattern para criar um objeto Pizza . A classe PizzaBuilder deve ter m\u00e9todos como setCheese(cheese: string) , addTopping(topping: string) , e um m\u00e9todo build() que retorna o objeto Pizza final. Ver Solu\u00e7\u00e3o class Pizza { public cheese?: string; public toppings: string[] = []; describe(): void { console.log(`Pizza com queijo ${this.cheese} e coberturas: ${this.toppings.join(', ')}`); } } class PizzaBuilder { private pizza: Pizza; constructor() { this.pizza = new Pizza(); } setCheese(cheese: string): this { this.pizza.cheese = cheese; return this; } addTopping(topping: string): this { this.pizza.toppings.push(topping); return this; } build(): Pizza { return this.pizza; } } // Teste const myPizza = new PizzaBuilder() .setCheese('mussarela') .addTopping('calabresa') .addTopping('cebola') .build(); myPizza.describe(); N\u00edvel 3: Avan\u00e7ado Crie um sistema de eventos type-safe usando o Observer Pattern. Crie uma classe EventManager que permite se inscrever ( on ) e emitir ( emit ) eventos. O sistema deve ser tipado de forma que, ao emitir um evento, o payload seja do tipo correto esperado pelos listeners daquele evento. Ver Solu\u00e7\u00e3o // Mapeia nomes de eventos para os tipos de seus payloads interface EventMap { 'user:created': { userId: string; name: string; }; 'user:deleted': { userId: string; }; 'product:viewed': { productId: string; }; } type EventKey = keyof EventMap; class EventManager { private listeners: { [K in EventKey]?: ((payload: EventMap[K]) => void)[] } = {}; // Se inscreve em um evento public on<K extends EventKey>(eventName: K, listener: (payload: EventMap[K]) => void): void { if (!this.listeners[eventName]) { this.listeners[eventName] = []; } this.listeners[eventName]?.push(listener); } // Emite um evento public emit<K extends EventKey>(eventName: K, payload: EventMap[K]): void { this.listeners[eventName]?.forEach(listener => listener(payload)); } } // Teste const events = new EventManager(); events.on('user:created', (payload) => { // O tipo de `payload` \u00e9 { userId: string; name: string; } console.log(`Novo usu\u00e1rio criado: ${payload.name} (ID: ${payload.userId})`); }); events.on('user:deleted', (payload) => { // O tipo de `payload` \u00e9 { userId: string; } console.log(`Usu\u00e1rio deletado: ${payload.userId}`); }); events.emit('user:created', { userId: 'u-123', name: 'Lucas' }); events.emit('user:deleted', { userId: 'u-456' }); // events.emit('user:created', { userId: 'u-789' }); // Erro: a propriedade 'name' est\u00e1 faltando. Checklist do Dia [ ] Implementei o Factory Pattern para criar objetos. [ ] Implementei o Builder Pattern para construir um objeto complexo. [ ] Implementei o Observer Pattern para notifica\u00e7\u00e3o de eventos. [ ] Usei os recursos de tipo do TypeScript para tornar os padr\u00f5es mais seguros. Dias 28-30: Projeto Final Foco do Projeto Consolidar todo o conhecimento adquirido ao longo das 4 semanas para planejar, implementar e refinar uma pequena aplica\u00e7\u00e3o ou um componente de sistema complexo. O objetivo \u00e9 aplicar os padr\u00f5es e t\u00e9cnicas aprendidas em um contexto coeso. Ideia do Projeto: Um Mini-Framework de Formul\u00e1rios Type-Safe Vamos construir um pequeno framework para gerenciar o estado de formul\u00e1rios, inspirado em bibliotecas como Formik ou React Hook Form, mas muito mais simples. Ele ir\u00e1 demonstrar o uso de classes, generics, mapped types, e mais. Dia 28: Planejamento e Estrutura Exerc\u00edcio: Defina os tipos e a classe principal. 1. Crie uma classe FormStore<T extends object> que ser\u00e1 o cora\u00e7\u00e3o do nosso framework. 2. No construtor, ela deve receber um initialValues: T . 3. Ela deve ter propriedades para armazenar os valores ( values: T ), os erros ( errors: FormErrors<T> ) e o estado de \"tocado\" ( touched: FormTouched<T> ). 4. Defina os tipos utilit\u00e1rios FormErrors<T> e FormTouched<T> usando Mapped Types. FormErrors deve ter as mesmas chaves de T , mas com valores string | undefined . FormTouched deve ter valores boolean | undefined . Ver Solu\u00e7\u00e3o // Tipos utilit\u00e1rios type FormErrors<T> = { [P in keyof T]?: string; }; type FormTouched<T> = { [P in keyof T]?: boolean; }; class FormStore<T extends object> { public values: T; public errors: FormErrors<T> = {}; public touched: FormTouched<T> = {}; constructor(initialValues: T) { this.values = initialValues; } public getState() { return { values: this.values, errors: this.errors, touched: this.touched, }; } } // Teste da estrutura const form = new FormStore({ name: '', email: '' }); console.log(form.getState()); Dia 29: Implementa\u00e7\u00e3o dos M\u00e9todos Exerc\u00edcio: Adicione os m\u00e9todos para interagir com o formul\u00e1rio. 1. Adicione um m\u00e9todo setFieldValue<K extends keyof T>(field: K, value: T[K]): void que atualiza um valor no values . 2. Adicione um m\u00e9todo setFieldTouched<K extends keyof T>(field: K, isTouched: boolean): void . 3. Adicione um m\u00e9todo setErrors(errors: FormErrors<T>): void que substitui o objeto de erros. 4. Adicione um m\u00e9todo de valida\u00e7\u00e3o validate(validationSchema: ValidationSchema<T>): boolean . O validationSchema deve ser um objeto onde cada chave de T tem uma fun\u00e7\u00e3o que recebe o valor do campo e retorna uma string de erro ou undefined . Ver Solu\u00e7\u00e3o // Tipos do dia anterior... type FormErrors<T> = { [P in keyof T]?: string; }; type FormTouched<T> = { [P in keyof T]?: boolean; }; // Novo tipo para o esquema de valida\u00e7\u00e3o type ValidationSchema<T> = { [K in keyof T]?: (value: T[K]) => string | undefined; }; class FormStore<T extends object> { public values: T; public errors: FormErrors<T> = {}; public touched: FormTouched<T> = {}; constructor(initialValues: T) { this.values = initialValues; } public setFieldValue<K extends keyof T>(field: K, value: T[K]): void { this.values[field] = value; } public setFieldTouched<K extends keyof T>(field: K, isTouched: boolean = true): void { this.touched[field] = isTouched; } public setErrors(errors: FormErrors<T>): void { this.errors = errors; } public validate(validationSchema: ValidationSchema<T>): boolean { const newErrors: FormErrors<T> = {}; let isValid = true; for (const key in validationSchema) { const validator = validationSchema[key]; if (validator) { const error = validator(this.values[key]); if (error) { newErrors[key] = error; isValid = false; } } } this.setErrors(newErrors); return isValid; } } Dia 30: Refinamento e Uso Exerc\u00edcio: Use o FormStore para gerenciar um formul\u00e1rio de registro de usu\u00e1rio. 1. Defina a interface UserSignupForm com name , email , e password . 2. Crie uma inst\u00e2ncia do FormStore com os valores iniciais. 3. Crie um ValidationSchema para o formul\u00e1rio (ex: nome \u00e9 obrigat\u00f3rio, email deve conter @ , senha deve ter mais de 6 caracteres). 4. Simule a intera\u00e7\u00e3o do usu\u00e1rio: mude valores, toque em campos e chame a valida\u00e7\u00e3o. Imprima o estado ( values , errors , touched ) no console a cada passo. Ver Solu\u00e7\u00e3o // Classe e tipos do dia anterior... // 1. Definir a interface do formul\u00e1rio interface UserSignupForm { name: string; email: string; password: string; } // 2. Criar a inst\u00e2ncia do FormStore const signupForm = new FormStore<UserSignupForm>({ name: '', email: '', password: '', }); // 3. Criar o esquema de valida\u00e7\u00e3o const signupValidationSchema: ValidationSchema<UserSignupForm> = { name: (value) => (value ? undefined : 'Nome \u00e9 obrigat\u00f3rio'), email: (value) => (value.includes('@') ? undefined : 'Email inv\u00e1lido'), password: (value) => (value.length > 6 ? undefined : 'Senha muito curta'), }; // 4. Simular a intera\u00e7\u00e3o console.log(\"Estado Inicial:\", signupForm.errors); // Usu\u00e1rio digita o nome signupForm.setFieldValue('name', 'Lucas'); signupForm.setFieldTouched('name'); // Usu\u00e1rio digita um email inv\u00e1lido e sai do campo signupForm.setFieldValue('email', 'lucas.com'); signupForm.setFieldTouched('email'); // Valida o formul\u00e1rio signupForm.validate(signupValidationSchema); console.log(\"Estado ap\u00f3s valida\u00e7\u00e3o 1:\", signupForm.errors); // { email: 'Email inv\u00e1lido', password: 'Senha muito curta' } // Usu\u00e1rio corrige o email e a senha signupForm.setFieldValue('email', 'lucas@ts.com'); signupForm.setFieldValue('password', '1234567'); // Valida novamente signupForm.validate(signupValidationSchema); console.log(\"Estado ap\u00f3s valida\u00e7\u00e3o 2:\", signupForm.errors); // {} Checklist Final [ ] Planejei a estrutura de uma classe complexa com tipos gen\u00e9ricos. [ ] Usei Mapped Types para criar tipos de estado derivados. [ ] Implementei a l\u00f3gica de neg\u00f3cio em m\u00e9todos de classe. [ ] Usei a classe final para resolver um problema pr\u00e1tico. [ ] Sinto-me confiante para arquitetar aplica\u00e7\u00f5es TypeScript intermedi\u00e1rias.","title":"Semana 4"},{"location":"Ts/Semana4/#semana-4-integracao-e-refinamento","text":"","title":"Semana 4: Integra\u00e7\u00e3o e Refinamento"},{"location":"Ts/Semana4/#visao-geral-da-semana","text":"Na \u00faltima semana, nosso foco \u00e9 a aplica\u00e7\u00e3o pr\u00e1tica e a integra\u00e7\u00e3o do TypeScript em ecossistemas do mundo real. Vamos aprender a integrar com bibliotecas externas como o React Hook Form, gerenciar estado de forma segura, organizar nosso c\u00f3digo com m\u00f3dulos e path mapping, e escrever testes que tamb\u00e9m validam nossos tipos. Finalizaremos com uma olhada em otimiza\u00e7\u00e3o de performance e padr\u00f5es de design avan\u00e7ados, culminando em um projeto final que une todo o conhecimento adquirido.","title":"Vis\u00e3o Geral da Semana"},{"location":"Ts/Semana4/#dia-22-form-integration-react-hook-form","text":"","title":"Dia 22: Form Integration (React Hook Form)"},{"location":"Ts/Semana4/#foco-do-dia","text":"Integrar TypeScript com bibliotecas externas, usando o React Hook Form como exemplo, e aprender a usar Module Augmentation para estender tipos de bibliotecas de terceiros.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada","text":"Integra\u00e7\u00e3o com Bibliotecas : Muitas bibliotecas populares (React, Vue, etc.) s\u00e3o escritas em TypeScript ou fornecem seus pr\u00f3prios arquivos de declara\u00e7\u00e3o de tipo ( .d.ts ). Isso nos permite usar a biblioteca de forma type-safe. Tipos Utilit\u00e1rios de Bibliotecas : Bibliotecas como React Hook Form exportam seus pr\u00f3prios tipos utilit\u00e1rios (ex: Control , FieldErrors , UseFormSetValue ) que s\u00e3o gen\u00e9ricos e devem ser usados com os tipos do nosso formul\u00e1rio. Module Augmentation : Permite que voc\u00ea \"adicione\" declara\u00e7\u00f5es a um m\u00f3dulo existente. \u00c9 \u00fatil para estender interfaces de bibliotecas de terceiros para adicionar propriedades customizadas sem precisar criar um fork da biblioteca.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial","text":"TypeScript com React (React Docs) TypeScript com React Hook Form (RHF Docs) Module Augmentation (Handbook)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo","text":"Exemplo: Tipando um Formul\u00e1rio Simples com React Hook Form import { useForm, Control, FieldErrors, UseFormSetValue } from 'react-hook-form'; // 1. Definir o tipo dos valores do formul\u00e1rio interface MyFormValues { firstName: string; age: number; } // 2. Usar o tipo com o hook `useForm` function MyForm() { const { control, formState: { errors }, setValue } = useForm<MyFormValues>(); // O tipo de `control` \u00e9 Control<MyFormValues> // O tipo de `errors` \u00e9 FieldErrors<MyFormValues> // O tipo de `setValue` \u00e9 UseFormSetValue<MyFormValues> // ... resto do componente JSX } Exemplo: Recriando seu tipo RenderMinFareForm import { Control, FieldErrors, UseFormSetValue, UseFormClearErrors } from 'react-hook-form'; // O tipo que define os valores do seu formul\u00e1rio interface MinFareFormValue { yield: number; price: number; } // O tipo que agrupa todos os props necess\u00e1rios para renderizar o form export type RenderMinFareForm = { control: Control<MinFareFormValue>; errors: FieldErrors<MinFareFormValue>; setValue: UseFormSetValue<MinFareFormValue>; clearErrors: UseFormClearErrors<MinFareFormValue>; };","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes","text":"N\u00edvel 1: B\u00e1sico Defina um tipo para um formul\u00e1rio de login, LoginFormValues , que cont\u00e9m email (string) e password (string). Em seguida, crie um tipo LoginProps que represente as propriedades que um componente de formul\u00e1rio de login receberia, incluindo onSubmit que \u00e9 uma fun\u00e7\u00e3o que recebe os LoginFormValues . Ver Solu\u00e7\u00e3o interface LoginFormValues { email: string; password: string; } type LoginProps = { onSubmit: (data: LoginFormValues) => void; }; // Exemplo de uso em um componente (simulado) function LoginForm(props: LoginProps) { // const { handleSubmit } = useForm<LoginFormValues>(); // return <form onSubmit={handleSubmit(props.onSubmit)}>...</form> console.log(\"Componente de formul\u00e1rio de login renderizado.\"); } N\u00edvel 2: Intermedi\u00e1rio Crie um tipo ProfileFormValues com name (string) e bio (string, opcional). Crie um tipo ProfileFormProps que agrupa as propriedades control e errors do React Hook Form, devidamente tipadas com ProfileFormValues . Ver Solu\u00e7\u00e3o import { Control, FieldErrors } from 'react-hook-form'; interface ProfileFormValues { name: string; bio?: string; } type ProfileFormProps = { control: Control<ProfileFormValues>; errors: FieldErrors<ProfileFormValues>; }; // Simula\u00e7\u00e3o de um componente que recebe esses props function ProfileFormComponent(props: ProfileFormProps) { // <Controller name=\"name\" control={props.control} ... /> // {props.errors.name && <p>Erro no nome</p>} console.log(\"Componente de perfil renderizado.\"); } N\u00edvel 3: Avan\u00e7ado Usando Module Augmentation , estenda a interface DefaultTheme de uma biblioteca de estiliza\u00e7\u00e3o (ex: styled-components ). Adicione uma propriedade customColors que \u00e9 um objeto com chaves primary e secondary . Ver Solu\u00e7\u00e3o // Em um arquivo, ex: styled.d.ts // 1. Importe o tipo original da biblioteca import 'styled-components'; // 2. Declare o m\u00f3dulo novamente para estend\u00ea-lo declare module 'styled-components' { // 3. Estenda a interface DefaultTheme export interface DefaultTheme { customColors: { primary: string; secondary: string; background: string; }; } } // Em outro arquivo, ex: theme.ts import { DefaultTheme } from 'styled-components'; const myTheme: DefaultTheme = { // Agora o TS espera a propriedade customColors customColors: { primary: '#007bff', secondary: '#6c757d', background: '#f8f9fa', }, };","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia","text":"[ ] Entendi como usar tipos gen\u00e9ricos de bibliotecas externas. [ ] Criei um tipo para os valores de um formul\u00e1rio. [ ] Agrupei os props de um formul\u00e1rio em um \u00fanico tipo. [ ] Usei Module Augmentation para estender uma interface de biblioteca.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dia-23-state-management-type-safe","text":"","title":"Dia 23: State Management Type-Safe"},{"location":"Ts/Semana4/#foco-do-dia_1","text":"Projetar um sistema de gerenciamento de estado (como Redux ou Zustand) de forma totalmente type-safe, com foco em action creators e selectors tipados.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada_1","text":"Store : Um objeto \u00fanico que cont\u00e9m todo o estado da aplica\u00e7\u00e3o. Actions : Objetos que descrevem uma inten\u00e7\u00e3o de mudar o estado. Geralmente t\u00eam uma propriedade type (uma string literal) e um payload opcional. Reducers : Fun\u00e7\u00f5es puras que recebem o estado atual e uma a\u00e7\u00e3o, e retornam o novo estado. (currentState, action) => newState . Action Creators : Fun\u00e7\u00f5es que criam e retornam objetos de a\u00e7\u00e3o. Ajuda a evitar erros de digita\u00e7\u00e3o no type da a\u00e7\u00e3o. Selectors : Fun\u00e7\u00f5es que extraem e computam dados derivados do estado do store. Memoiza\u00e7\u00e3o (como na biblioteca reselect ) \u00e9 frequentemente usada para performance.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial_1","text":"Static Typing com Redux (Redux Docs)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo_1","text":"Exemplo: Tipando A\u00e7\u00f5es e Reducer do Redux // 1. Definir o tipo do estado interface CounterState { value: number; } // 2. Definir os tipos das a\u00e7\u00f5es const INCREMENT = 'counter/increment'; const ADD = 'counter/add'; interface IncrementAction { type: typeof INCREMENT; } interface AddAction { type: typeof ADD; payload: number; } type CounterAction = IncrementAction | AddAction; // 3. Criar o reducer const initialState: CounterState = { value: 0 }; function counterReducer(state = initialState, action: CounterAction): CounterState { switch (action.type) { case INCREMENT: return { ...state, value: state.value + 1 }; case ADD: // O TS sabe que `action` tem `payload` aqui return { ...state, value: state.value + action.payload }; default: return state; } }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes_1","text":"N\u00edvel 1: B\u00e1sico Crie os action creators para as a\u00e7\u00f5es IncrementAction e AddAction do exemplo guiado. As fun\u00e7\u00f5es devem retornar os objetos de a\u00e7\u00e3o devidamente tipados. Ver Solu\u00e7\u00e3o // Tipos do exemplo anterior... const INCREMENT = 'counter/increment'; const ADD = 'counter/add'; interface IncrementAction { type: typeof INCREMENT; } interface AddAction { type: typeof ADD; payload: number; } // Action Creators function increment(): IncrementAction { return { type: INCREMENT }; } function add(amount: number): AddAction { return { type: ADD, payload: amount }; } // Teste const incrementAction = increment(); // tipo IncrementAction const addAction = add(5); // tipo AddAction console.log(incrementAction); console.log(addAction); N\u00edvel 2: Intermedi\u00e1rio Defina um estado para uma lista de tarefas ( todos ). Crie os tipos de a\u00e7\u00e3o e o reducer para adicionar uma nova tarefa ( ADD_TODO ) e marcar uma tarefa como completa ( TOGGLE_TODO ). Ver Solu\u00e7\u00e3o // 1. Tipos de Estado interface Todo { id: number; text: string; completed: boolean; } interface TodosState { todos: Todo[]; } // 2. Tipos de A\u00e7\u00e3o const ADD_TODO = 'todos/add'; const TOGGLE_TODO = 'todos/toggle'; interface AddTodoAction { type: typeof ADD_TODO; payload: { text: string } } interface ToggleTodoAction { type: typeof TOGGLE_TODO; payload: { id: number } } type TodoAction = AddTodoAction | ToggleTodoAction; // 3. Reducer const initialTodosState: TodosState = { todos: [] }; let nextTodoId = 0; function todosReducer(state = initialTodosState, action: TodoAction): TodosState { switch (action.type) { case ADD_TODO: return { ...state, todos: [...state.todos, { id: nextTodoId++, text: action.payload.text, completed: false }] }; case TOGGLE_TODO: return { ...state, todos: state.todos.map(todo => todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo ) }; default: return state; } } N\u00edvel 3: Avan\u00e7ado Crie um seletor tipado selectCompletedTodos que recebe o estado completo da aplica\u00e7\u00e3o (que cont\u00e9m todosState ) e retorna apenas a lista de tarefas completas. Ver Solu\u00e7\u00e3o // Reutilizando os tipos do N\u00edvel 2 interface Todo { id: number; text: string; completed: boolean; } interface TodosState { todos: Todo[]; } // Estado global da aplica\u00e7\u00e3o interface AppState { todosState: TodosState; // ... outros estados } // O seletor function selectCompletedTodos(state: AppState): Todo[] { return state.todosState.todos.filter(todo => todo.completed); } // Teste const testState: AppState = { todosState: { todos: [ { id: 0, text: 'Aprender TS', completed: true }, { id: 1, text: 'Dominar o mundo', completed: false }, { id: 2, text: 'Tomar caf\u00e9', completed: true }, ] } }; const completed = selectCompletedTodos(testState); console.log(completed);","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia_1","text":"[ ] Defini o tipo para uma fatia (slice) do estado. [ ] Criei tipos de a\u00e7\u00e3o usando discriminated unions. [ ] Implementei um reducer type-safe. [ ] Criei action creators e seletores tipados.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dia-24-module-system-e-path-mapping","text":"","title":"Dia 24: Module System e Path Mapping"},{"location":"Ts/Semana4/#foco-do-dia_2","text":"Organizar a arquitetura de c\u00f3digo usando o sistema de m\u00f3dulos do TypeScript, incluindo barrel exports e path mapping para imports mais limpos.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada_2","text":"M\u00f3dulos : Cada arquivo em TypeScript \u00e9 um m\u00f3dulo. export torna vari\u00e1veis, fun\u00e7\u00f5es e classes dispon\u00edveis para outros m\u00f3dulos. import as consome. Barrel Exports : Um arquivo, geralmente chamado index.ts , que re-exporta todos os exports de um diret\u00f3rio. Isso permite que os consumidores importem tudo de um \u00fanico local, em vez de m\u00faltiplos caminhos. import { ServiceA, ServiceB } from './services'; em vez de ... from './services/ServiceA' e ... from './services/ServiceB' . Path Mapping : Uma feature do tsconfig.json que permite criar aliases para caminhos de importa\u00e7\u00e3o. Isso evita imports relativos longos como ../../../../components e os substitui por aliases como @components .","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial_2","text":"Modules (Handbook) Path mapping (tsconfig Reference)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo_2","text":"Exemplo 1: Barrel Exports // Em src/utils/stringUtils.ts export const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1); // Em src/utils/numberUtils.ts export const isEven = (n: number) => n % 2 === 0; // Em src/utils/index.ts (o \"barrel\") export * from './stringUtils'; export * from './numberUtils'; // Em outro arquivo import { capitalize, isEven } from '../utils'; // Importa de um \u00fanico lugar Exemplo 2: Configurando Path Mapping No tsconfig.json : { \"compilerOptions\": { \"baseUrl\": \"./src\", // Essencial para o path mapping \"paths\": { \"@components/*\": [\"components/*\"], \"@services/*\": [\"services/*\"], \"@domain/*\": [\"domain/*\"] } } } Uso no c\u00f3digo: // Em vez de: import { User } from '../../domain/models/User'; import { User } from '@domain/models/User'; // Em vez de: import { Button } from '../components/Button'; import { Button } from '@components/Button';","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes_2","text":"N\u00edvel 1: B\u00e1sico Crie uma estrutura de pastas domain/errors . Dentro, crie dois arquivos: UnexpectedError.ts e NotFoundError.ts , cada um exportando uma classe de erro. Crie um arquivo index.ts em domain/errors que exporta ambas as classes. Ver Solu\u00e7\u00e3o // Em domain/errors/UnexpectedError.ts export class UnexpectedError extends Error { constructor() { super('Um erro inesperado aconteceu.'); this.name = 'UnexpectedError'; } } // Em domain/errors/NotFoundError.ts export class NotFoundError extends Error { constructor() { super('Recurso n\u00e3o encontrado.'); this.name = 'NotFoundError'; } } // Em domain/errors/index.ts export * from './UnexpectedError'; export * from './NotFoundError'; // Em outro arquivo (ex: app.ts) // import { UnexpectedError, NotFoundError } from './domain/errors'; N\u00edvel 2: Intermedi\u00e1rio Configure o path mapping no seu tsconfig.json para criar um alias @/ que aponte para o diret\u00f3rio src/ . Refatore um import que usa um caminho relativo (ex: ../utils ) para usar o novo alias ( @/utils ). Ver Solu\u00e7\u00e3o No `tsconfig.json`: { \"compilerOptions\": { \"baseUrl\": \".\", // ou \"./src\" \"paths\": { \"@/*\": [\"src/*\"] } } } No c\u00f3digo: // Antes: // import { capitalize } from '../../utils/stringUtils'; // Depois: // import { capitalize } from '@/utils/stringUtils'; N\u00edvel 3: Avan\u00e7ado Crie uma estrutura de m\u00f3dulos para a sua camada de dados, como no seu exemplo. Crie data/protocols/http/ com um index.ts e um http-client.ts . O http-client.ts deve exportar um HttpStatusCode (enum) e uma interface HttpClient . O index.ts deve exportar tudo de http-client.ts . Configure um alias @data para a pasta data . Ver Solu\u00e7\u00e3o No `tsconfig.json`: { \"compilerOptions\": { \"baseUrl\": \"./src\", \"paths\": { \"@data/*\": [\"data/*\"] } } } Estrutura de arquivos: src/ data/ protocols/ http/ http-client.ts index.ts Em `src/data/protocols/http/http-client.ts`: export enum HttpStatusCode { ok = 200, noContent = 204, badRequest = 400, notFound = 404, serverError = 500, } export interface HttpClient<R = any> { request: (data: HttpRequest) => Promise<HttpResponse<R>>; } export type HttpRequest = { url: string; method: string; body?: any; headers?: any; }; export type HttpResponse<R = any> = { statusCode: HttpStatusCode; body?: R; }; Em `src/data/protocols/http/index.ts`: export * from './http-client'; Em outro arquivo: import { HttpStatusCode, HttpClient } from '@data/protocols/http';","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia_2","text":"[ ] Entendi a diferen\u00e7a entre export e export default . [ ] Criei um barrel export ( index.ts ) para simplificar imports. [ ] Configurei baseUrl e paths no tsconfig.json . [ ] Refatorei imports relativos para usar aliases de caminho.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dia-25-testing-types","text":"","title":"Dia 25: Testing Types"},{"location":"Ts/Semana4/#foco-do-dia_3","text":"Escrever testes que n\u00e3o apenas validam a l\u00f3gica de execu\u00e7\u00e3o, mas tamb\u00e9m a corre\u00e7\u00e3o dos tipos, usando mocks type-safe e testes de asser\u00e7\u00e3o de tipo.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada_3","text":"Mocks Type-Safe : Ao mockar (simular) m\u00f3dulos ou classes, \u00e9 crucial que o mock tenha o mesmo tipo do original. Ferramentas como jest.Mocked<T> ajudam a garantir isso. Testando Tipos : \u00c0s vezes, queremos testar apenas o tipo, n\u00e3o o valor. Por exemplo, garantir que uma fun\u00e7\u00e3o n\u00e3o pode ser chamada com argumentos errados. Isso geralmente \u00e9 feito em arquivos .test-d.ts (testes de declara\u00e7\u00e3o) com ferramentas como tsd ou expect-type . Mock Factories : Criar fun\u00e7\u00f5es que geram mocks consistentes e tipados para os seus testes. Isso reduz a duplica\u00e7\u00e3o de c\u00f3digo nos testes.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial_3","text":"TypeScript com Jest","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo_3","text":"Exemplo: Mockando um Servi\u00e7o com Tipagem // Em user.service.ts export class UserService { async getUserName(id: string): Promise<string> { // ... l\u00f3gica real return \"Nome Real\"; } } // Em user.controller.test.ts import { UserService } from './user.service'; import { jest } from '@jest/globals'; // Mocka o m\u00f3dulo inteiro jest.mock('./user.service'); // Cria uma vers\u00e3o tipada da classe mockada const MockedUserService = UserService as jest.MockedClass<typeof UserService>; // Teste it('should return user name', async () => { // O TS sabe que `mock.instances[0].getUserName` existe e \u00e9 um mock MockedUserService.prototype.getUserName.mockResolvedValue(\"Nome Mockado\"); const serviceInstance = new UserService(); const name = await serviceInstance.getUserName('1'); expect(name).toBe(\"Nome Mockado\"); });","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes_3","text":"N\u00edvel 1: B\u00e1sico Crie uma interface INotifier com um m\u00e9todo notify(message: string) . Crie um mock simples para esta interface em um teste, garantindo que o mock satisfa\u00e7a a interface. Ver Solu\u00e7\u00e3o // Interface original interface INotifier { notify(message: string): void; } // Teste describe('Notifier Test', () => { it('should be called with the correct message', () => { // O mock \u00e9 tipado como a interface const mockNotifier: INotifier = { notify: jest.fn(), // jest.fn() cria uma fun\u00e7\u00e3o mock }; // Simula o uso do notifier mockNotifier.notify(\"hello\"); expect(mockNotifier.notify).toHaveBeenCalledWith(\"hello\"); }); }); N\u00edvel 2: Intermedi\u00e1rio Crie uma \"mock factory\" para um objeto User . A factory deve ser uma fun\u00e7\u00e3o createMockUser(overrides: Partial<User>): User que cria um usu\u00e1rio padr\u00e3o e permite sobrescrever propriedades espec\u00edficas para cada teste. Ver Solu\u00e7\u00e3o interface User { id: string; name: string; email: string; isAdmin: boolean; } function createMockUser(overrides?: Partial<User>): User { const defaultUser: User = { id: 'user-1', name: 'Usu\u00e1rio Padr\u00e3o', email: 'default@test.com', isAdmin: false, }; return { ...defaultUser, ...overrides }; } // Teste describe('Mock User Factory', () => { it('should create a default user', () => { const user = createMockUser(); expect(user.name).toBe('Usu\u00e1rio Padr\u00e3o'); }); it('should override properties', () => { const adminUser = createMockUser({ name: 'Admin', isAdmin: true }); expect(adminUser.name).toBe('Admin'); expect(adminUser.isAdmin).toBe(true); }); }); N\u00edvel 3: Avan\u00e7ado Usando uma ferramenta como expect-type (ou apenas com coment\u00e1rios, se n\u00e3o estiver configurada), escreva um teste de tipo para garantir que uma fun\u00e7\u00e3o add(a: number, b: number) n\u00e3o pode ser chamada com strings. Ver Solu\u00e7\u00e3o import { expectTypeOf } from 'expect-type'; function add(a: number, b: number): number { return a + b; } // Teste de tipo test('type tests for add function', () => { // Verifica se a fun\u00e7\u00e3o aceita n\u00fameros expectTypeOf(add).toBeCallableWith(1, 2); // Verifica se a fun\u00e7\u00e3o N\u00c3O aceita strings expectTypeOf(add).not.toBeCallableWith('1', '2'); // Verifica o tipo de retorno expectTypeOf(add).returns.toBeNumber(); }); **Solu\u00e7\u00e3o sem biblioteca (usando coment\u00e1rios de erro esperado):** function add(a: number, b: number): number { return a + b; } // @ts-expect-error - Testando que isso deve dar um erro de tipo add('1', '2'); const result = add(1, 2); // @ts-expect-error - Testando que o resultado n\u00e3o \u00e9 uma string const resultIsString: string = result;","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia_3","text":"[ ] Criei um mock tipado para uma interface. [ ] Usei jest.MockedClass para mockar uma classe. [ ] Criei uma factory para gerar mocks consistentes. [ ] Entendi como testar a corre\u00e7\u00e3o de tipos, n\u00e3o apenas de valores.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dia-26-performance-e-optimization","text":"","title":"Dia 26: Performance e Optimization"},{"location":"Ts/Semana4/#foco-do-dia_4","text":"Entender como tipos complexos podem impactar a performance do compilador TypeScript e aprender t\u00e9cnicas para otimiz\u00e1-los.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada_4","text":"Custo da Tipagem : Tipos muito complexos, especialmente os recursivos ou que geram uni\u00f5es muito grandes, podem deixar o tsc (compilador do TypeScript) e o IntelliSense lentos. An\u00e1lise de Performance : O compilador do TypeScript tem flags para ajudar a diagnosticar problemas de performance, como --diagnostics e --generateTrace . T\u00e9cnicas de Otimiza\u00e7\u00e3o : Evitar Recurs\u00e3o Infinita : Cuidado com tipos recursivos que n\u00e3o t\u00eam um caso base claro. Interfaces vs. Types : Interfaces s\u00e3o geralmente melhores para objetos, pois s\u00e3o extens\u00edveis e podem ser ligeiramente mais perform\u00e1ticas em alguns casos devido \u00e0 forma como s\u00e3o cacheadas internamente. Simplificar Tipos Condicionais : Tente quebrar tipos condicionais complexos em tipos auxiliares menores. Adiar Computa\u00e7\u00e3o de Tipos : Em vez de um tipo que calcula tudo de uma vez, use um tipo gen\u00e9rico que \u00e9 resolvido apenas quando usado.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial_4","text":"TypeScript Performance Wiki","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo_4","text":"Exemplo: Tipo Recursivo que Pode Ser Lento // Este tipo pode ser lento se a profundidade for grande type DeeplyNested<T> = { content: T; next?: DeeplyNested<T> }; // Uma alternativa pode ser limitar a profundidade, se poss\u00edvel type LimitedDepth<T, D extends number> = D extends 0 ? T : { content: T; next?: LimitedDepth<T, any /* D-1 */> }; // (A matem\u00e1tica de tipos para subtrair 1 \u00e9 complexa, mas a ideia \u00e9 limitar a recurs\u00e3o) Exemplo: Simplificando Uni\u00f5es Grandes // Lento: Gera uma uni\u00e3o de 1000 tipos literais type Thousand = 1 | 2 | 3 | ... | 1000; // Mais perform\u00e1tico: Usa um tipo mais geral e valida em tempo de execu\u00e7\u00e3o type SmallNumber = number & { __brand: 'SmallNumber' }; function createSmallNumber(n: number): SmallNumber | null { if (n > 0 && n <= 1000) return n as SmallNumber; return null; }","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes_4","text":"N\u00edvel 1: B\u00e1sico Refatore um tipo que usa type para um objeto para usar interface . Explique por que interface pode ser prefer\u00edvel para objetos que podem ser estendidos. Ver Solu\u00e7\u00e3o // Antes type UserType = { id: number; name: string; }; // Depois (Refatorado) interface UserInterface { id: number; name: string; } // Interfaces podem ser estendidas por outras interfaces e aumentadas (module augmentation). // Isso as torna mais flex\u00edveis para objetos, especialmente em APIs p\u00fablicas. interface AdminUser extends UserInterface { permissions: string[]; } N\u00edvel 2: Intermedi\u00e1rio Dado um tipo ComplexMappedType que faz v\u00e1rias opera\u00e7\u00f5es, quebre-o em tipos utilit\u00e1rios menores e mais leg\u00edveis. Ver Solu\u00e7\u00e3o interface Props { name: string; age: number; onNameChange: (name: string) => void; onAgeChange: (age: number) => void; } // Antes: Um tipo monol\u00edtico type CallbacksOnlyBefore<T> = { [K in keyof T as T[K] extends (...args: any[]) => any ? K : never]: T[K] }; // Depois: Refatorado em tipos menores // 1. Pega as chaves cujos valores s\u00e3o fun\u00e7\u00f5es type FunctionKeys<T> = { [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never }[keyof T]; // 2. Usa Pick para criar o tipo final type CallbacksOnlyAfter<T> = Pick<T, FunctionKeys<T>>; // Teste type PropCallbacks = CallbacksOnlyAfter<Props>; // { onNameChange: (name: string) => void; onAgeChange: (age: number) => void; } N\u00edvel 3: Avan\u00e7ado Crie um tipo Path<T> que gera todas as chaves de um objeto aninhado como uma string com pontos (ex: 'details.address.city' ). Este \u00e9 um tipo inerentemente recursivo e pesado. Pense em como voc\u00ea poderia otimiz\u00e1-lo ou quais seriam seus gargalos de performance. Ver Solu\u00e7\u00e3o // Este tipo \u00e9 conhecido por ser pesado e pode causar lentid\u00e3o no compilador // com objetos muito grandes ou profundos. type Path<T, K extends keyof T = keyof T> = K extends string ? T[K] extends Record<string, any> ? `${K}.${Path<T[K]>}` | K : K : never; // Teste interface UserProfile { id: number; details: { name: string; address: { street: string; city: string; } } } type UserProfilePaths = Path<UserProfile>; // \"id\" | \"details\" | \"details.name\" | \"details.address\" | \"details.address.street\" | \"details.address.city\" /* Otimiza\u00e7\u00e3o/Gargalos: 1. Profundidade da Recurs\u00e3o: A principal causa de lentid\u00e3o. Uma otimiza\u00e7\u00e3o seria adicionar um par\u00e2metro de profundidade para limitar a recurs\u00e3o. 2. Largura do Objeto: Muitos campos em cada n\u00edvel aumentam o n\u00famero de uni\u00f5es geradas. 3. Tipos Condicionais: Cada verifica\u00e7\u00e3o `T[K] extends Record<string, any>` adiciona custo computacional. Uma otimiza\u00e7\u00e3o real em um projeto seria talvez n\u00e3o usar este tipo e preferir uma valida\u00e7\u00e3o em tempo de execu\u00e7\u00e3o para caminhos de objetos. */","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia_4","text":"[ ] Entendi que tipos complexos podem impactar a performance. [ ] Sei a diferen\u00e7a entre interface e type e quando usar cada um. [ ] Refatorei um tipo complexo em tipos auxiliares menores. [ ] Analisei um tipo recursivo e identifiquei seus poss\u00edveis gargalos.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dia-27-advanced-patterns","text":"","title":"Dia 27: Advanced Patterns"},{"location":"Ts/Semana4/#foco-do-dia_5","text":"Implementar padr\u00f5es de design de software cl\u00e1ssicos (Design Patterns) em TypeScript, aproveitando o sistema de tipos para torn\u00e1-los mais seguros e expressivos.","title":"Foco do Dia"},{"location":"Ts/Semana4/#leitura-e-teoria-aprofundada_5","text":"Builder Pattern : Usado para construir objetos complexos passo a passo. Permite produzir diferentes tipos e representa\u00e7\u00f5es de um objeto usando o mesmo processo de constru\u00e7\u00e3o. Ideal para objetos com muitos par\u00e2metros de configura\u00e7\u00e3o. Factory Pattern : Usado para criar objetos sem expor a l\u00f3gica de cria\u00e7\u00e3o ao cliente. Uma fun\u00e7\u00e3o ou m\u00e9todo \"f\u00e1brica\" decide qual classe concreta instanciar com base em algum par\u00e2metro. Observer Pattern : Usado para criar uma rela\u00e7\u00e3o de um-para-muitos entre objetos. Quando um objeto (o subject ) muda de estado, todos os seus dependentes (os observers ) s\u00e3o notificados e atualizados automaticamente.","title":"Leitura e Teoria (Aprofundada)"},{"location":"Ts/Semana4/#documentacao-essencial_5","text":"Design Patterns (Refactoring Guru)","title":"Documenta\u00e7\u00e3o Essencial"},{"location":"Ts/Semana4/#pratica-guiada-passo-a-passo_5","text":"Exemplo: Observer Pattern // A interface para os observadores interface Observer<T> { update(data: T): void; } // O sujeito que os observadores observam class Subject<T> { private observers = new Set<Observer<T>>(); subscribe(observer: Observer<T>) { this.observers.add(observer); } unsubscribe(observer: Observer<T>) { this.observers.delete(observer); } notify(data: T) { this.observers.forEach(observer => observer.update(data)); } } // Exemplo de uso const newsFeed = new Subject<string>(); const observerA = { update: (data: string) => console.log(`Observer A: ${data}`) }; const observerB = { update: (data: string) => console.log(`Observer B: ${data}`) }; newsFeed.subscribe(observerA); newsFeed.subscribe(observerB); newsFeed.notify(\"Nova not\u00edcia importante!\");","title":"Pr\u00e1tica Guiada (Passo a Passo)"},{"location":"Ts/Semana4/#exercicios-praticos-niveis-crescentes_5","text":"N\u00edvel 1: B\u00e1sico Implemente uma SimpleFactory para criar objetos Logger . A factory deve ter um m\u00e9todo createLogger(type: 'console' | 'file') que retorna uma inst\u00e2ncia de ConsoleLogger ou FileLogger , ambas implementando uma interface ILogger . Ver Solu\u00e7\u00e3o interface ILogger { log(message: string): void; } class ConsoleLogger implements ILogger { log(message: string) { console.log(message); } } class FileLogger implements ILogger { log(message: string) { console.log(`File: ${message}`); } } class LoggerFactory { public createLogger(type: 'console' | 'file'): ILogger { if (type === 'file') { return new FileLogger(); } return new ConsoleLogger(); } } // Teste const factory = new LoggerFactory(); const consoleLogger = factory.createLogger('console'); const fileLogger = factory.createLogger('file'); consoleLogger.log(\"Teste console\"); fileLogger.log(\"Teste arquivo\"); N\u00edvel 2: Intermedi\u00e1rio Implemente o Builder Pattern para criar um objeto Pizza . A classe PizzaBuilder deve ter m\u00e9todos como setCheese(cheese: string) , addTopping(topping: string) , e um m\u00e9todo build() que retorna o objeto Pizza final. Ver Solu\u00e7\u00e3o class Pizza { public cheese?: string; public toppings: string[] = []; describe(): void { console.log(`Pizza com queijo ${this.cheese} e coberturas: ${this.toppings.join(', ')}`); } } class PizzaBuilder { private pizza: Pizza; constructor() { this.pizza = new Pizza(); } setCheese(cheese: string): this { this.pizza.cheese = cheese; return this; } addTopping(topping: string): this { this.pizza.toppings.push(topping); return this; } build(): Pizza { return this.pizza; } } // Teste const myPizza = new PizzaBuilder() .setCheese('mussarela') .addTopping('calabresa') .addTopping('cebola') .build(); myPizza.describe(); N\u00edvel 3: Avan\u00e7ado Crie um sistema de eventos type-safe usando o Observer Pattern. Crie uma classe EventManager que permite se inscrever ( on ) e emitir ( emit ) eventos. O sistema deve ser tipado de forma que, ao emitir um evento, o payload seja do tipo correto esperado pelos listeners daquele evento. Ver Solu\u00e7\u00e3o // Mapeia nomes de eventos para os tipos de seus payloads interface EventMap { 'user:created': { userId: string; name: string; }; 'user:deleted': { userId: string; }; 'product:viewed': { productId: string; }; } type EventKey = keyof EventMap; class EventManager { private listeners: { [K in EventKey]?: ((payload: EventMap[K]) => void)[] } = {}; // Se inscreve em um evento public on<K extends EventKey>(eventName: K, listener: (payload: EventMap[K]) => void): void { if (!this.listeners[eventName]) { this.listeners[eventName] = []; } this.listeners[eventName]?.push(listener); } // Emite um evento public emit<K extends EventKey>(eventName: K, payload: EventMap[K]): void { this.listeners[eventName]?.forEach(listener => listener(payload)); } } // Teste const events = new EventManager(); events.on('user:created', (payload) => { // O tipo de `payload` \u00e9 { userId: string; name: string; } console.log(`Novo usu\u00e1rio criado: ${payload.name} (ID: ${payload.userId})`); }); events.on('user:deleted', (payload) => { // O tipo de `payload` \u00e9 { userId: string; } console.log(`Usu\u00e1rio deletado: ${payload.userId}`); }); events.emit('user:created', { userId: 'u-123', name: 'Lucas' }); events.emit('user:deleted', { userId: 'u-456' }); // events.emit('user:created', { userId: 'u-789' }); // Erro: a propriedade 'name' est\u00e1 faltando.","title":"Exerc\u00edcios Pr\u00e1ticos (N\u00edveis Crescentes)"},{"location":"Ts/Semana4/#checklist-do-dia_5","text":"[ ] Implementei o Factory Pattern para criar objetos. [ ] Implementei o Builder Pattern para construir um objeto complexo. [ ] Implementei o Observer Pattern para notifica\u00e7\u00e3o de eventos. [ ] Usei os recursos de tipo do TypeScript para tornar os padr\u00f5es mais seguros.","title":"Checklist do Dia"},{"location":"Ts/Semana4/#dias-28-30-projeto-final","text":"","title":"Dias 28-30: Projeto Final"},{"location":"Ts/Semana4/#foco-do-projeto","text":"Consolidar todo o conhecimento adquirido ao longo das 4 semanas para planejar, implementar e refinar uma pequena aplica\u00e7\u00e3o ou um componente de sistema complexo. O objetivo \u00e9 aplicar os padr\u00f5es e t\u00e9cnicas aprendidas em um contexto coeso.","title":"Foco do Projeto"},{"location":"Ts/Semana4/#ideia-do-projeto-um-mini-framework-de-formularios-type-safe","text":"Vamos construir um pequeno framework para gerenciar o estado de formul\u00e1rios, inspirado em bibliotecas como Formik ou React Hook Form, mas muito mais simples. Ele ir\u00e1 demonstrar o uso de classes, generics, mapped types, e mais.","title":"Ideia do Projeto: Um Mini-Framework de Formul\u00e1rios Type-Safe"},{"location":"Ts/Semana4/#dia-28-planejamento-e-estrutura","text":"Exerc\u00edcio: Defina os tipos e a classe principal. 1. Crie uma classe FormStore<T extends object> que ser\u00e1 o cora\u00e7\u00e3o do nosso framework. 2. No construtor, ela deve receber um initialValues: T . 3. Ela deve ter propriedades para armazenar os valores ( values: T ), os erros ( errors: FormErrors<T> ) e o estado de \"tocado\" ( touched: FormTouched<T> ). 4. Defina os tipos utilit\u00e1rios FormErrors<T> e FormTouched<T> usando Mapped Types. FormErrors deve ter as mesmas chaves de T , mas com valores string | undefined . FormTouched deve ter valores boolean | undefined . Ver Solu\u00e7\u00e3o // Tipos utilit\u00e1rios type FormErrors<T> = { [P in keyof T]?: string; }; type FormTouched<T> = { [P in keyof T]?: boolean; }; class FormStore<T extends object> { public values: T; public errors: FormErrors<T> = {}; public touched: FormTouched<T> = {}; constructor(initialValues: T) { this.values = initialValues; } public getState() { return { values: this.values, errors: this.errors, touched: this.touched, }; } } // Teste da estrutura const form = new FormStore({ name: '', email: '' }); console.log(form.getState());","title":"Dia 28: Planejamento e Estrutura"},{"location":"Ts/Semana4/#dia-29-implementacao-dos-metodos","text":"Exerc\u00edcio: Adicione os m\u00e9todos para interagir com o formul\u00e1rio. 1. Adicione um m\u00e9todo setFieldValue<K extends keyof T>(field: K, value: T[K]): void que atualiza um valor no values . 2. Adicione um m\u00e9todo setFieldTouched<K extends keyof T>(field: K, isTouched: boolean): void . 3. Adicione um m\u00e9todo setErrors(errors: FormErrors<T>): void que substitui o objeto de erros. 4. Adicione um m\u00e9todo de valida\u00e7\u00e3o validate(validationSchema: ValidationSchema<T>): boolean . O validationSchema deve ser um objeto onde cada chave de T tem uma fun\u00e7\u00e3o que recebe o valor do campo e retorna uma string de erro ou undefined . Ver Solu\u00e7\u00e3o // Tipos do dia anterior... type FormErrors<T> = { [P in keyof T]?: string; }; type FormTouched<T> = { [P in keyof T]?: boolean; }; // Novo tipo para o esquema de valida\u00e7\u00e3o type ValidationSchema<T> = { [K in keyof T]?: (value: T[K]) => string | undefined; }; class FormStore<T extends object> { public values: T; public errors: FormErrors<T> = {}; public touched: FormTouched<T> = {}; constructor(initialValues: T) { this.values = initialValues; } public setFieldValue<K extends keyof T>(field: K, value: T[K]): void { this.values[field] = value; } public setFieldTouched<K extends keyof T>(field: K, isTouched: boolean = true): void { this.touched[field] = isTouched; } public setErrors(errors: FormErrors<T>): void { this.errors = errors; } public validate(validationSchema: ValidationSchema<T>): boolean { const newErrors: FormErrors<T> = {}; let isValid = true; for (const key in validationSchema) { const validator = validationSchema[key]; if (validator) { const error = validator(this.values[key]); if (error) { newErrors[key] = error; isValid = false; } } } this.setErrors(newErrors); return isValid; } }","title":"Dia 29: Implementa\u00e7\u00e3o dos M\u00e9todos"},{"location":"Ts/Semana4/#dia-30-refinamento-e-uso","text":"Exerc\u00edcio: Use o FormStore para gerenciar um formul\u00e1rio de registro de usu\u00e1rio. 1. Defina a interface UserSignupForm com name , email , e password . 2. Crie uma inst\u00e2ncia do FormStore com os valores iniciais. 3. Crie um ValidationSchema para o formul\u00e1rio (ex: nome \u00e9 obrigat\u00f3rio, email deve conter @ , senha deve ter mais de 6 caracteres). 4. Simule a intera\u00e7\u00e3o do usu\u00e1rio: mude valores, toque em campos e chame a valida\u00e7\u00e3o. Imprima o estado ( values , errors , touched ) no console a cada passo. Ver Solu\u00e7\u00e3o // Classe e tipos do dia anterior... // 1. Definir a interface do formul\u00e1rio interface UserSignupForm { name: string; email: string; password: string; } // 2. Criar a inst\u00e2ncia do FormStore const signupForm = new FormStore<UserSignupForm>({ name: '', email: '', password: '', }); // 3. Criar o esquema de valida\u00e7\u00e3o const signupValidationSchema: ValidationSchema<UserSignupForm> = { name: (value) => (value ? undefined : 'Nome \u00e9 obrigat\u00f3rio'), email: (value) => (value.includes('@') ? undefined : 'Email inv\u00e1lido'), password: (value) => (value.length > 6 ? undefined : 'Senha muito curta'), }; // 4. Simular a intera\u00e7\u00e3o console.log(\"Estado Inicial:\", signupForm.errors); // Usu\u00e1rio digita o nome signupForm.setFieldValue('name', 'Lucas'); signupForm.setFieldTouched('name'); // Usu\u00e1rio digita um email inv\u00e1lido e sai do campo signupForm.setFieldValue('email', 'lucas.com'); signupForm.setFieldTouched('email'); // Valida o formul\u00e1rio signupForm.validate(signupValidationSchema); console.log(\"Estado ap\u00f3s valida\u00e7\u00e3o 1:\", signupForm.errors); // { email: 'Email inv\u00e1lido', password: 'Senha muito curta' } // Usu\u00e1rio corrige o email e a senha signupForm.setFieldValue('email', 'lucas@ts.com'); signupForm.setFieldValue('password', '1234567'); // Valida novamente signupForm.validate(signupValidationSchema); console.log(\"Estado ap\u00f3s valida\u00e7\u00e3o 2:\", signupForm.errors); // {}","title":"Dia 30: Refinamento e Uso"},{"location":"Ts/Semana4/#checklist-final","text":"[ ] Planejei a estrutura de uma classe complexa com tipos gen\u00e9ricos. [ ] Usei Mapped Types para criar tipos de estado derivados. [ ] Implementei a l\u00f3gica de neg\u00f3cio em m\u00e9todos de classe. [ ] Usei a classe final para resolver um problema pr\u00e1tico. [ ] Sinto-me confiante para arquitetar aplica\u00e7\u00f5es TypeScript intermedi\u00e1rias.","title":"Checklist Final"},{"location":"Ts/estrutura-plano/","text":"Principais Focos Integrados: Classes e this (Dias 1-2, 8-10, 17) Context binding em cen\u00e1rios reais Method chaining type-safe Abstract classes para arquitetura this parameters para APIs fluentes Elimina\u00e7\u00e3o de any (Dias 3-4, 12, 26) unknown como substituto seguro Type guards customizados Narrowing autom\u00e1tico Branded types para type safety Records e Funcionalidades Nativas (Dias 5, 19-20) Record<K,V> com template literals Utility types avan\u00e7ados ( ReturnType , Parameters , etc.) Const assertions para immutability Dictionary patterns como seu exemplo Progress\u00e3o Natural: Semana 1 : Fundamentos s\u00f3lidos (classes, this , elimina\u00e7\u00e3o de any ) Semana 2 : Conceitos avan\u00e7ados (generics, decorators, conditional types) Semana 3 : Patterns arquiteturais (como seu GetTableDataService ) Semana 4 : Integra\u00e7\u00e3o real (React Hook Form, m\u00f3dulos, projeto final) O plano est\u00e1 estruturado para que ao final dos 30 dias voc\u00ea seja capaz de: Implementar services complexos como o seu GetTableDataService Criar tipagens robustas para forms como RenderMinFareForm Dominar patterns com Record como seu tooltipContent Arquitetar aplica\u00e7\u00f5es sem usar any","title":"Vis\u00e3o Geral"},{"location":"Ts/estrutura-plano/#principais-focos-integrados","text":"","title":"Principais Focos Integrados:"},{"location":"Ts/estrutura-plano/#classes-e-this-dias-1-2-8-10-17","text":"Context binding em cen\u00e1rios reais Method chaining type-safe Abstract classes para arquitetura this parameters para APIs fluentes","title":"Classes e this (Dias 1-2, 8-10, 17)"},{"location":"Ts/estrutura-plano/#eliminacao-de-any-dias-3-4-12-26","text":"unknown como substituto seguro Type guards customizados Narrowing autom\u00e1tico Branded types para type safety","title":"Elimina\u00e7\u00e3o de any (Dias 3-4, 12, 26)"},{"location":"Ts/estrutura-plano/#records-e-funcionalidades-nativas-dias-5-19-20","text":"Record<K,V> com template literals Utility types avan\u00e7ados ( ReturnType , Parameters , etc.) Const assertions para immutability Dictionary patterns como seu exemplo","title":"Records e Funcionalidades Nativas (Dias 5, 19-20)"},{"location":"Ts/estrutura-plano/#progressao-natural","text":"Semana 1 : Fundamentos s\u00f3lidos (classes, this , elimina\u00e7\u00e3o de any ) Semana 2 : Conceitos avan\u00e7ados (generics, decorators, conditional types) Semana 3 : Patterns arquiteturais (como seu GetTableDataService ) Semana 4 : Integra\u00e7\u00e3o real (React Hook Form, m\u00f3dulos, projeto final)","title":"Progress\u00e3o Natural:"},{"location":"Ts/estrutura-plano/#o-plano-esta-estruturado-para-que-ao-final-dos-30-dias-voce-seja-capaz-de","text":"Implementar services complexos como o seu GetTableDataService Criar tipagens robustas para forms como RenderMinFareForm Dominar patterns com Record como seu tooltipContent Arquitetar aplica\u00e7\u00f5es sem usar any","title":"O plano est\u00e1 estruturado para que ao final dos 30 dias voc\u00ea seja capaz de:"}]}