<!doctype html>
<html lang="en">

<head>
        <title>Armazenamento Web - Meus Estudos</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">Meus Estudos</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Início
                </a>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#requisitos-collapse" aria-expanded="false">
                    Requisitos
                </a>
                <div class="collapse" id="requisitos-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Requisitos/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#lógica-collapse" aria-expanded="false">
                    Lógica
                </a>
                <div class="collapse" id="lógica-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Logica/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Lógica de Programação
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class=" active 
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#web-collapse" aria-expanded="false">
                    Web
                </a>
                <div class="collapse" id="web-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="./"
            class=" active 
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Armazenamento Web
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#typescript-collapse" aria-expanded="false">
                    TypeScript
                </a>
                <div class="collapse" id="typescript-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Ts/estrutura-plano/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../Ts/Semana1/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 1
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../Ts/Semana2/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 2
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../Ts/Semana3/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 3
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../Ts/Semana4/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 4
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#mongo-collapse" aria-expanded="false">
                    Mongo
                </a>
                <div class="collapse" id="mongo-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Apostila
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/respostas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Respostas
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/tarefas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Tarefas
        </a>
    </li>
                    </ul>
                </div>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../../Logica/apostila/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a href="../../Ts/estrutura-plano/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><p>📚 <strong>APOSTILA: ARMAZENAMENTO WEB MODERNO</strong></p>
<p><strong>Disciplina: Tecnologias de Armazenamento Client-Side</strong></p>
<p>📋 <strong>SUMÁRIO</strong></p>
<ol>
<li>localStorage</li>
<li>sessionStorage</li>
<li>Cookies</li>
<li>IndexedDB</li>
<li>Cache API (Service Workers)</li>
<li>OPFS (Origin Private File System)</li>
<li>Projeto Final</li>
</ol>
<p>🎯 <strong>OBJETIVOS DE APRENDIZAGEM</strong></p>
<p>Ao final desta disciplina, o aluno será capaz de:</p>
<ul>
<li>Compreender as diferenças entre os tipos de storage do navegador</li>
<li>Implementar soluções de armazenamento adequadas para cada cenário</li>
<li>Desenvolver aplicações offline-first</li>
<li>Otimizar performance através de cache inteligente</li>
<li>Trabalhar com grandes volumes de dados no client-side</li>
</ul>
<hr />
<h2 id="1-localstorage">1. localStorage</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>O localStorage é uma API de armazenamento web que permite salvar dados no navegador de forma <strong>persistente</strong>. Os dados permanecem disponíveis mesmo após fechar o navegador.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: ~5-10MB por origem</li>
<li><strong>Persistência</strong>: Permanente (até ser limpo manualmente)</li>
<li><strong>Escopo</strong>: Por origem (protocolo + domínio + porta)</li>
<li><strong>Sincronismo</strong>: API síncrona</li>
<li><strong>Tipo de dados</strong>: Apenas strings</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Preferências do usuário</li>
<li>Configurações da aplicação</li>
<li>Cache de dados pequenos</li>
<li>Estado da aplicação que deve persistir</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Operações Básicas:</p>
<pre><code class="language-javascript">// Salvar dados
localStorage.setItem('usuario', 'João Silva');
localStorage.setItem('configuracoes', JSON.stringify({
  tema: 'dark',
  idioma: 'pt-BR'
}));

// Recuperar dados
const usuario = localStorage.getItem('usuario');
const config = JSON.parse(localStorage.getItem('configuracoes') || '{}');

// Verificar se existe
if (localStorage.getItem('token')) {
  console.log('Usuário logado');
}

// Remover item específico
localStorage.removeItem('usuario');

// Limpar tudo
localStorage.clear();

// Obter número de itens
console.log(localStorage.length);

// Iterar pelos itens
for (let i = 0; i &lt; localStorage.length; i++) {
  const key = localStorage.key(i);
  const value = localStorage.getItem(key);
  console.log(key, value);
}
</code></pre>
<p>Service Angular para localStorage:</p>
<pre><code class="language-typescript">import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LocalStorageService {
  setItem(key: string, value: any): void {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Erro ao salvar no localStorage:', error);
    }
  }

  getItem&lt;T&gt;(key: string): T | null {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('Erro ao ler do localStorage:', error);
      return null;
    }
  }

  removeItem(key: string): void {
    localStorage.removeItem(key);
  }

  clear(): void {
    localStorage.clear();
  }

  exists(key: string): boolean {
    return localStorage.getItem(key) !== null;
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "LocalStorage JavaScript Tutorial" - Programming with Mosh</li>
<li><strong>YouTube</strong>: "Angular LocalStorage Service" - Academind</li>
<li><strong>Curso Online</strong>: "JavaScript Web Storage" - freeCodeCamp</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://www.treinaweb.com.br/blog/quando-usar-sessionstorage-e-localstorage">TreinaWeb - LocalStorage vs SessionStorage</a></li>
<li><a href="https://www.angulartraining.com/daily-newsletter/localstorage-and-sessionstorage/">Angular Training - Storage Guide</a></li>
<li><a href="https://jscrambler.com/blog/working-with-angular-local-storage">JSCrambler - Angular Local Storage</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - Sistema de Preferências</p>
<p>Crie um sistema que salve as preferências do usuário:</p>
<ul>
<li>Tema (claro/escuro)</li>
<li>Idioma preferido</li>
<li>Tamanho da fonte</li>
</ul>
<p>Exercício 2 - Carrinho de Compras</p>
<p>Implemente um carrinho que persista entre sessões:</p>
<ul>
<li>Adicionar/remover produtos</li>
<li>Calcular total</li>
<li>Manter estado após fechar o navegador</li>
</ul>
<p>Exercício 3 - Histórico de Pesquisas</p>
<p>Desenvolva um sistema que armazene:</p>
<ul>
<li>Últimas 10 pesquisas do usuário</li>
<li>Data/hora de cada pesquisa</li>
<li>Funcionalidade de limpar histórico</li>
</ul>
<hr />
<h2 id="2-sessionstorage">2. sessionStorage</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>O sessionStorage funciona de forma similar ao localStorage, mas os dados são <strong>temporários</strong> e existem apenas durante a sessão da aba do navegador.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: ~5-10MB por origem</li>
<li><strong>Persistência</strong>: Apenas durante a sessão da aba</li>
<li><strong>Escopo</strong>: Por aba do navegador</li>
<li><strong>Sincronismo</strong>: API síncrona</li>
<li><strong>Tipo de dados</strong>: Apenas strings</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Dados temporários de formulários</li>
<li>Estado da navegação</li>
<li>Informações sensíveis que não devem persistir</li>
<li>Dados de sessão de usuário</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Operações Básicas:</p>
<pre><code class="language-javascript">// API idêntica ao localStorage
sessionStorage.setItem('sessaoAtual', JSON.stringify({
  usuario: 'João',
  inicioSessao: new Date().getTime(),
  paginaAtual: 'dashboard'
}));

// Recuperar dados da sessão
const sessao = JSON.parse(sessionStorage.getItem('sessaoAtual') || '{}');

// Verificar tempo de sessão
const tempoSessao = Date.now() - sessao.inicioSessao;
if (tempoSessao &gt; 30 * 60 * 1000) { // 30 minutos
  console.log('Sessão expirada');
  sessionStorage.clear();
}
</code></pre>
<p>Service Angular para sessionStorage:</p>
<pre><code class="language-typescript">import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class SessionStorageService {
  private readonly SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutos

  setItem(key: string, value: any): void {
    try {
      const data = {
        value,
        timestamp: Date.now()
      };
      sessionStorage.setItem(key, JSON.stringify(data));
    } catch (error) {
      console.error('Erro ao salvar no sessionStorage:', error);
    }
  }

  getItem&lt;T&gt;(key: string): T | null {
    try {
      const item = sessionStorage.getItem(key);
      if (!item) return null;

      const data = JSON.parse(item);

      // Verificar se não expirou
      if (Date.now() - data.timestamp &gt; this.SESSION_TIMEOUT) {
        this.removeItem(key);
        return null;
      }
      return data.value;
    } catch (error) {
      console.error('Erro ao ler do sessionStorage:', error);
      return null;
    }
  }

  removeItem(key: string): void {
    sessionStorage.removeItem(key);
  }

  clear(): void {
    sessionStorage.clear();
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "SessionStorage vs LocalStorage" - Web Dev Simplified</li>
<li><strong>YouTube</strong>: "Angular Session Management" - Codevolution</li>
<li><strong>Tutorial</strong>: "Browser Storage Comparison" - Traversy Media</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://techspawn.com/localstorage-session-storage-or-cookies-in-angular/">TechSpawn - Comparação de Storage</a></li>
<li><a href="https://ng-girls.gitbook.io/todo-list-tutorial-portuguese/local_storage">NgGirls - Tutorial Prático</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - Formulário Multipasso</p>
<p>Implemente um wizard que salve o progresso:</p>
<ul>
<li>Salvar dados a cada passo</li>
<li>Restaurar se usuário voltar à página</li>
<li>Limpar ao concluir</li>
</ul>
<p>Exercício 2 - Estado de Navegação</p>
<p>Crie um sistema que mantenha:</p>
<ul>
<li>Filtros aplicados em uma listagem</li>
<li>Página atual de paginação</li>
<li>Ordenação selecionada</li>
</ul>
<hr />
<h2 id="3-cookies">3. Cookies</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>Cookies são pequenos arquivos de texto que o navegador armazena e envia automaticamente para o servidor a cada requisição HTTP.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: ~4KB por cookie</li>
<li><strong>Persistência</strong>: Configurável (sessão ou data específica)</li>
<li><strong>Escopo</strong>: Configurável (domínio e path)</li>
<li><strong>Automatismo</strong>: Enviados automaticamente ao servidor</li>
<li><strong>Segurança</strong>: Opções HttpOnly, Secure, SameSite</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Autenticação e sessões</li>
<li>Rastreamento de usuário</li>
<li>Personalização baseada em servidor</li>
<li>Conformidade com LGPD/GDPR</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Manipulação Básica:</p>
<pre><code class="language-javascript">// Criar cookie simples
document.cookie = &quot;usuario=joao&quot;;

// Cookie com expiração
const dataExpiracao = new Date();
dataExpiracao.setTime(dataExpiracao.getTime() + (24 * 60 * 60 * 1000)); // 24 horas
document.cookie = `sessao=abc123; expires=${dataExpiracao.toUTCString()}; path=/`;

// Cookie seguro
document.cookie = &quot;token=xyz789; Secure; HttpOnly; SameSite=Strict&quot;;

// Função para ler cookie
function getCookie(nome) {
  const nomeEQ = nome + &quot;=&quot;;
  const cookies = document.cookie.split(';');
  for(let i = 0; i &lt; cookies.length; i++) {
    let cookie = cookies[i];
    while (cookie.charAt(0) === ' ') {
      cookie = cookie.substring(1, cookie.length);
    }
    if (cookie.indexOf(nomeEQ) === 0) {
      return cookie.substring(nomeEQ.length, cookie.length);
    }
  }
  return null;
}

// Função para deletar cookie
function deleteCookie(nome) {
  document.cookie = nome + &quot;=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;&quot;;
}
</code></pre>
<p>Service Angular para Cookies:</p>
<pre><code class="language-typescript">import { Injectable } from '@angular/core';

export interface CookieOptions {
  expires?: Date;
  path?: string;
  domain?: string;
  secure?: boolean;
  sameSite?: 'Strict' | 'Lax' | 'None';
}

@Injectable({
  providedIn: 'root'
})
export class CookieService {
  set(name: string, value: string, options: CookieOptions = {}): void {
    let cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;

    if (options.expires) {
      cookie += `; expires=${options.expires.toUTCString()}`;
    }
    if (options.path) {
      cookie += `; path=${options.path}`;
    }
    if (options.domain) {
      cookie += `; domain=${options.domain}`;
    }
    if (options.secure) {
      cookie += '; Secure';
    }
    if (options.sameSite) {
      cookie += `; SameSite=${options.sameSite}`;
    }
    document.cookie = cookie;
  }

  get(name: string): string | null {
    const nameEQ = encodeURIComponent(name) + &quot;=&quot;;
    const cookies = document.cookie.split(';');

    for (let cookie of cookies) {
      cookie = cookie.trim();
      if (cookie.indexOf(nameEQ) === 0) {
        return decodeURIComponent(cookie.substring(nameEQ.length));
      }
    }
    return null;
  }

  delete(name: string, path: string = '/'): void {
    this.set(name, '', {
      expires: new Date(0),
      path: path
    });
  }

  exists(name: string): boolean {
    return this.get(name) !== null;
  }

  getAll(): { [key: string]: string } {
    const cookies: { [key: string]: string } = {};
    if (document.cookie) {
      document.cookie.split(';').forEach(cookie =&gt; {
        const [name, value] = cookie.trim().split('=');
        cookies[decodeURIComponent(name)] = decodeURIComponent(value || '');
      });
    }
    return cookies;
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "HTTP Cookies Explained" - Hussein Nasser</li>
<li><strong>YouTube</strong>: "Cookie vs LocalStorage vs SessionStorage" - Web Dev Simplified</li>
<li><strong>Curso</strong>: "Web Security &amp; Cookies" - OWASP</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://www.geeksforgeeks.org/difference-between-local-storage-session-storage-and-cookies/">GeeksforGeeks - Diferenças entre Storage</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/js-introduction-localstorage-sessionstorage">DigitalOcean - Introdução ao Storage</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - Sistema de Login</p>
<p>Implemente autenticação com cookies:</p>
<ul>
<li>Cookie de sessão</li>
<li>Lembrar usuário (persistent cookie)</li>
<li>Logout seguro</li>
</ul>
<p>Exercício 2 - Banner de Cookies (LGPD)</p>
<p>Crie um sistema de consentimento:</p>
<ul>
<li>Banner de aceitação</li>
<li>Categorização de cookies</li>
<li>Configurações de privacidade</li>
</ul>
<hr />
<h2 id="4-indexeddb">4. IndexedDB</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>IndexedDB é um banco de dados NoSQL completo que roda no navegador, permitindo armazenar grandes quantidades de dados estruturados.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: Limitada pelo espaço em disco</li>
<li><strong>Persistência</strong>: Permanente</li>
<li><strong>Tipo de dados</strong>: Objetos JavaScript complexos</li>
<li><strong>Transações</strong>: Suporte completo ACID</li>
<li><strong>Índices</strong>: Consultas rápidas</li>
<li><strong>Assíncrono</strong>: API baseada em Promises/Events</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Aplicações offline-first</li>
<li>Cache de dados grandes</li>
<li>Sincronização de dados</li>
<li>Armazenamento de arquivos/blobs</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Configuração Básica:</p>
<pre><code class="language-javascript">// Abrir banco de dados
function abrirBanco() {
  return new Promise((resolve, reject) =&gt; {
    const request = indexedDB.open('MeuApp', 1);

    request.onerror = () =&gt; reject(request.error);
    request.onsuccess = () =&gt; resolve(request.result);

    request.onupgradeneeded = (event) =&gt; {
      const db = event.target.result;
      // Criar object store
      if (!db.objectStoreNames.contains('usuarios')) {
        const store = db.createObjectStore('usuarios', {
          keyPath: 'id',
          autoIncrement: true
        });
        // Criar índices
        store.createIndex('email', 'email', { unique: true });
        store.createIndex('nome', 'nome', { unique: false });
      }
    };
  });
}

// Operações CRUD
class UsuarioRepository {
  constructor(db) {
    this.db = db;
  }

  async criar(usuario) {
    const transaction = this.db.transaction(['usuarios'], 'readwrite');
    const store = transaction.objectStore('usuarios');
    return store.add(usuario);
  }

  async buscarPorId(id) {
    const transaction = this.db.transaction(['usuarios'], 'readonly');
    const store = transaction.objectStore('usuarios');
    return store.get(id);
  }

  async buscarPorEmail(email) {
    const transaction = this.db.transaction(['usuarios'], 'readonly');
    const store = transaction.objectStore('usuarios');
    const index = store.index('email');
    return index.get(email);
  }

  async listarTodos() {
    const transaction = this.db.transaction(['usuarios'], 'readonly');
    const store = transaction.objectStore('usuarios');
    return store.getAll();
  }

  async atualizar(usuario) {
    const transaction = this.db.transaction(['usuarios'], 'readwrite');
    const store = transaction.objectStore('usuarios');
    return store.put(usuario);
  }

  async deletar(id) {
    const transaction = this.db.transaction(['usuarios'], 'readwrite');
    const store = transaction.objectStore('usuarios');
    return store.delete(id);
  }
}
</code></pre>
<p>Usando Dexie.js (Wrapper Simplificado):</p>
<pre><code class="language-typescript">import Dexie, { Table } from 'dexie';

export interface Usuario {
  id?: number;
  nome: string;
  email: string;
  idade: number;
  criadoEm: Date;
}

export class AppDatabase extends Dexie {
  usuarios!: Table&lt;Usuario&gt;;

  constructor() {
    super('AppDatabase');
    this.version(1).stores({
      usuarios: '++id, nome, email, idade, criadoEm'
    });
  }
}

export const db = new AppDatabase();

// Service Angular com Dexie
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class UsuarioService {
  async criarUsuario(usuario: Omit&lt;Usuario, 'id'&gt;): Promise&lt;number&gt; {
    return await db.usuarios.add({
      ...usuario,
      criadoEm: new Date()
    });
  }

  async buscarUsuarios(): Promise&lt;Usuario[]&gt; {
    return await db.usuarios.orderBy('nome').toArray();
  }

  async buscarPorEmail(email: string): Promise&lt;Usuario | undefined&gt; {
    return await db.usuarios.where('email').equals(email).first();
  }

  async atualizarUsuario(id: number, dados: Partial&lt;Usuario&gt;): Promise&lt;number&gt; {
    return await db.usuarios.update(id, dados);
  }

  async deletarUsuario(id: number): Promise&lt;void&gt; {
    await db.usuarios.delete(id);
  }

  async pesquisarPorNome(termo: string): Promise&lt;Usuario[]&gt; {
    return await db.usuarios
      .where('nome')
      .startsWithIgnoreCase(termo)
      .toArray();
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "IndexedDB Crash Course" - Traversy Media</li>
<li><strong>YouTube</strong>: "Dexie.js Tutorial" - The Net Ninja</li>
<li><strong>Curso</strong>: "Offline First Web Apps" - Google Developers</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/">FreeCodeCamp - Guia Completo IndexedDB</a></li>
<li><a href="https://www.telerik.com/blogs/beginners-guide-indexeddb">Telerik - Guia para Iniciantes</a></li>
<li><a href="https://dexie.org/docs/Tutorial/Angular">Dexie.js - Tutorial Angular</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - Sistema de Tarefas Offline</p>
<p>Desenvolva um todo app que funcione offline:</p>
<ul>
<li>CRUD completo de tarefas</li>
<li>Categorias e tags</li>
<li>Busca por texto</li>
<li>Sincronização quando online</li>
</ul>
<p>Exercício 2 - Cache de Dados da API</p>
<p>Implemente um sistema de cache inteligente:</p>
<ul>
<li>Armazenar respostas da API</li>
<li>Refresh automático</li>
<li>Estratégia de invalidação</li>
</ul>
<hr />
<h2 id="5-cache-api-service-workers">5. Cache API (Service Workers)</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>A Cache API, junto com Service Workers, permite criar aplicações web que funcionam offline interceptando requisições de rede e servindo conteúdo cacheado.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: Limitada pelo espaço em disco</li>
<li><strong>Persistência</strong>: Permanente (até ser limpa)</li>
<li><strong>Escopo</strong>: Controlado por Service Worker</li>
<li><strong>Estratégias</strong>: Cache-first, Network-first, etc.</li>
<li><strong>Atualizações</strong>: Controle granular de versioning</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Progressive Web Apps (PWA)</li>
<li>Aplicações offline-first</li>
<li>Cache de recursos estáticos</li>
<li>Otimização de performance</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Service Worker Básico:</p>
<pre><code class="language-javascript">// sw.js
const CACHE_NAME = 'meu-app-v1';
const urlsToCache = [
  '/',
  '/styles/main.css',
  '/scripts/app.js',
  '/images/logo.png'
];

// Instalação - cachear recursos
self.addEventListener('install', (event) =&gt; {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) =&gt; {
        console.log('Cache aberto');
        return cache.addAll(urlsToCache);
      })
  );
});

// Interceptar requisições
self.addEventListener('fetch', (event) =&gt; {
  event.respondWith(
    caches.match(event.request)
      .then((response) =&gt; {
        // Cache hit - retornar resposta
        if (response) {
          return response;
        }
        // Cache miss - fazer requisição
        return fetch(event.request)
          .then((response) =&gt; {
            const responseClone = response.clone();
            caches.open(CACHE_NAME)
              .then((cache) =&gt; {
                cache.put(event.request, responseClone);
              });
            return response;
          });
      })
  );
});

// Atualização - limpar caches antigos
self.addEventListener('activate', (event) =&gt; {
  event.waitUntil(
    caches.keys().then((cacheNames) =&gt; {
      return Promise.all(
        cacheNames.map((cacheName) =&gt; {
          if (cacheName !== CACHE_NAME) {
            console.log('Deletando cache antigo:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
</code></pre>
<p>Estratégias de Cache:</p>
<pre><code class="language-javascript">// Cache First - para recursos estáticos
async function cacheFirst(request) {
  const cachedResponse = await caches.match(request);
  return cachedResponse || fetch(request);
}

// Network First - para dados dinâmicos
async function networkFirst(request) {
  try {
    const response = await fetch(request);
    const cache = await caches.open(CACHE_NAME);
    cache.put(request, response.clone());
    return response;
  } catch (error) {
    const cachedResponse = await caches.match(request);
    return cachedResponse || new Response('Offline', { status: 503 });
  }
}

// Stale While Revalidate - melhor UX
async function staleWhileRevalidate(request) {
  const cachedResponse = await caches.match(request);
  const fetchPromise = fetch(request).then((response) =&gt; {
    const cache = caches.open(CACHE_NAME);
    cache.then((c) =&gt; c.put(request, response.clone()));
    return response;
  });
  return cachedResponse || fetchPromise;
}
</code></pre>
<p>Angular Service Worker:</p>
<pre><code class="language-typescript">// Adicionar ao projeto Angular
// ng add @angular/pwa

// Configuração ngsw-config.json
/*
{
  &quot;index&quot;: &quot;/index.html&quot;,
  &quot;assetGroups&quot;: [
    {
      &quot;name&quot;: &quot;app&quot;,
      &quot;installMode&quot;: &quot;prefetch&quot;,
      &quot;resources&quot;: {
        &quot;files&quot;: [
          &quot;/favicon.ico&quot;,
          &quot;/index.html&quot;,
          &quot;/manifest.webmanifest&quot;,
          &quot;/*.css&quot;,
          &quot;/*.js&quot;
        ]
      }
    }
  ],
  &quot;dataGroups&quot;: [
    {
      &quot;name&quot;: &quot;api-cache&quot;,
      &quot;urls&quot;: [&quot;/api/**&quot;],
      &quot;cacheConfig&quot;: {
        &quot;strategy&quot;: &quot;freshness&quot;,
        &quot;maxSize&quot;: 100,
        &quot;maxAge&quot;: &quot;1d&quot;,
        &quot;timeout&quot;: &quot;5s&quot;
      }
    }
  ]
}
*/

// Service para interagir com SW
import { Injectable } from '@angular/core';
import { SwUpdate } from '@angular/service-worker';

@Injectable({
  providedIn: 'root'
})
export class PwaService {
  constructor(private swUpdate: SwUpdate) {
    if (swUpdate.isEnabled) {
      swUpdate.available.subscribe(() =&gt; {
        if (confirm('Nova versão disponível. Atualizar?')) {
          window.location.reload();
        }
      });
    }
  }

  checkForUpdate(): void {
    if (this.swUpdate.isEnabled) {
      this.swUpdate.checkForUpdate();
    }
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "Service Workers Explained" - Google Chrome Developers</li>
<li><strong>YouTube</strong>: "Building PWAs with Angular" - Angular</li>
<li><strong>Curso</strong>: "Progressive Web Apps Training" - Google Developers</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://blog.angular-university.io/angular-service-worker/">Angular University - Service Worker Guide</a></li>
<li><a href="https://codezup.com/angular-service-worker-a-practical-guide-to-caching-and-offline-support/">CodeZup - Practical Guide</a></li>
<li><a href="https://web.dev/articles/service-worker-caching-and-http-caching">Web.dev - Service Worker Caching</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - PWA Completa</p>
<p>Transforme uma aplicação em PWA:</p>
<ul>
<li>Service Worker customizado</li>
<li>Cache de recursos e APIs</li>
<li>Funcionalidade offline</li>
<li>Installable app</li>
</ul>
<p>Exercício 2 - Cache Inteligente</p>
<p>Implemente diferentes estratégias:</p>
<ul>
<li>Cache-first para CSS/JS</li>
<li>Network-first para dados</li>
<li>Background sync para formulários</li>
</ul>
<hr />
<h2 id="6-opfs-origin-private-file-system">6. OPFS (Origin Private File System)</h2>
<p>📖 <strong>CONCEITOS FUNDAMENTAIS</strong></p>
<p>OPFS é uma API moderna que permite aplicações web criar, ler e manipular arquivos em um sistema de arquivos virtual privado por origem.</p>
<p>Características:</p>
<ul>
<li><strong>Capacidade</strong>: Limitada pelo espaço em disco disponível</li>
<li><strong>Performance</strong>: Acesso byte-a-byte otimizado</li>
<li><strong>Privacidade</strong>: Não visível ao usuário, privado por origem</li>
<li><strong>Segurança</strong>: Não requer permissões do usuário</li>
<li><strong>Streaming</strong>: Suporte a manipulação de arquivos grandes</li>
</ul>
<p>Quando usar:</p>
<ul>
<li>Manipulação de arquivos grandes</li>
<li>Bancos de dados personalizados</li>
<li>Cache de alta performance</li>
<li>Aplicações que precisam de I/O intensivo</li>
</ul>
<p>🔧 <strong>IMPLEMENTAÇÃO PRÁTICA</strong></p>
<p>Operações Básicas:</p>
<pre><code class="language-javascript">// Verificar suporte
if ('storage' in navigator &amp;&amp; 'getDirectory' in navigator.storage) {
  console.log('OPFS suportado');
} else {
  console.log('OPFS não suportado');
}

// Obter diretório raiz
async function obterDiretorioRaiz() {
  return await navigator.storage.getDirectory();
}

// Criar arquivo
async function criarArquivo(nome, conteudo) {
  const root = await navigator.storage.getDirectory();
  const fileHandle = await root.getFileHandle(nome, { create: true });
  const writable = await fileHandle.createWritable();
  await writable.write(conteudo);
  await writable.close();
  return fileHandle;
}

// Ler arquivo
async function lerArquivo(nome) {
  const root = await navigator.storage.getDirectory();
  const fileHandle = await root.getFileHandle(nome);
  const file = await fileHandle.getFile();
  return await file.text();
}

// Listar arquivos
async function listarArquivos() {
  const root = await navigator.storage.getDirectory();
  const arquivos = [];
  for await (const [nome, handle] of root.entries()) {
    arquivos.push({
      nome,
      tipo: handle.kind,
      handle
    });
  }
  return arquivos;
}

// Deletar arquivo
async function deletarArquivo(nome) {
  const root = await navigator.storage.getDirectory();
  await root.removeEntry(nome);
}
</code></pre>
<p>Manipulação Avançada com Streams:</p>
<pre><code class="language-javascript">// Acesso síncrono (apenas em Web Workers)
async function accessoSincrono() {
  const root = await navigator.storage.getDirectory();
  const fileHandle = await root.getFileHandle('dados.db', { create: true });
  // Criar handle de acesso síncrono
  const syncHandle = await fileHandle.createSyncAccessHandle();
  // Escrever dados
  const encoder = new TextEncoder();
  const data = encoder.encode('Dados importantes');
  syncHandle.write(data, { at: 0 });
  // Ler dados
  const buffer = new ArrayBuffer(1024);
  const bytesRead = syncHandle.read(buffer, { at: 0 });
  const decoder = new TextDecoder();
  const texto = decoder.decode(buffer.slice(0, bytesRead));
  // Obter tamanho do arquivo
  const tamanho = syncHandle.getSize();
  // Truncar arquivo
  syncHandle.truncate(100);
  // Fechar handle
  syncHandle.close();
}

// Sistema de arquivos hierárquico
async function estruturaHierarquica() {
  const root = await navigator.storage.getDirectory();
  // Criar diretório
  const pastaDados = await root.getDirectoryHandle('dados', { create: true });
  const pastaImagens = await root.getDirectoryHandle('imagens', { create: true });
  // Criar arquivo em subdiretório
  const arquivo = await pastaDados.getFileHandle('config.json', { create: true });
  const writable = await arquivo.createWritable();
  await writable.write(JSON.stringify({
    versao: '1.0',
    configuracoes: {
      tema: 'dark',
      idioma: 'pt-BR'
    }
  }));
  await writable.close();
}
</code></pre>
<p>Service Angular para OPFS:</p>
<pre><code class="language-typescript">import { Injectable } from '@angular/core';

export interface ArquivoOPFS {
  nome: string;
  tamanho: number;
  tipo: 'file' | 'directory';
  ultimaModificacao: Date;
}

@Injectable({
  providedIn: 'root'
})
export class OpfsService {
  private rootDirectoryHandle: FileSystemDirectoryHandle | null = null;

  async inicializar(): Promise&lt;boolean&gt; {
    if ('storage' in navigator &amp;&amp; 'getDirectory' in navigator.storage) {
      this.rootDirectoryHandle = await navigator.storage.getDirectory();
      return true;
    }
    return false;
  }

  async salvarArquivo(caminho: string, conteudo: string | ArrayBuffer): Promise&lt;void&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    const fileHandle = await this.rootDirectoryHandle.getFileHandle(caminho, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(conteudo);
    await writable.close();
  }

  async lerArquivo(caminho: string): Promise&lt;string&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    const fileHandle = await this.rootDirectoryHandle.getFileHandle(caminho);
    const file = await fileHandle.getFile();
    return await file.text();
  }

  async lerArquivoBinario(caminho: string): Promise&lt;ArrayBuffer&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    const fileHandle = await this.rootDirectoryHandle.getFileHandle(caminho);
    const file = await fileHandle.getFile();
    return await file.arrayBuffer();
  }

  async listarArquivos(diretorio: string = ''): Promise&lt;ArquivoOPFS[]&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    let currentDir = this.rootDirectoryHandle;
    if (diretorio) {
      currentDir = await this.rootDirectoryHandle.getDirectoryHandle(diretorio);
    }
    const arquivos: ArquivoOPFS[] = [];
    for await (const [nome, handle] of currentDir.entries()) {
      if (handle.kind === 'file') {
        const file = await (handle as FileSystemFileHandle).getFile();
        arquivos.push({
          nome,
          tamanho: file.size,
          tipo: 'file',
          ultimaModificacao: new Date(file.lastModified)
        });
      } else {
        arquivos.push({
          nome,
          tamanho: 0,
          tipo: 'directory',
          ultimaModificacao: new Date()
        });
      }
    }
    return arquivos;
  }

  async criarDiretorio(nome: string): Promise&lt;void&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    await this.rootDirectoryHandle.getDirectoryHandle(nome, { create: true });
  }

  async deletarArquivo(caminho: string): Promise&lt;void&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    await this.rootDirectoryHandle.removeEntry(caminho);
  }

  async obterTamanhoArquivo(caminho: string): Promise&lt;number&gt; {
    if (!this.rootDirectoryHandle) {
      throw new Error('OPFS não inicializado');
    }
    const fileHandle = await this.rootDirectoryHandle.getFileHandle(caminho);
    const file = await fileHandle.getFile();
    return file.size;
  }

  async arquivoExiste(caminho: string): Promise&lt;boolean&gt; {
    if (!this.rootDirectoryHandle) {
      return false;
    }
    try {
      await this.rootDirectoryHandle.getFileHandle(caminho);
      return true;
    } catch {
      return false;
    }
  }
}
</code></pre>
<p>Exemplo Prático - Editor de Arquivos:</p>
<pre><code class="language-typescript">import { Component, OnInit } from '@angular/core';
import { OpfsService } from './opfs.service';

@Component({
  selector: 'app-editor-arquivos',
  template: `
    &lt;div class=&quot;editor-container&quot;&gt;
      &lt;div class=&quot;sidebar&quot;&gt;
        &lt;h3&gt;Arquivos&lt;/h3&gt;
        &lt;button (click)=&quot;criarNovoArquivo()&quot;&gt;Novo Arquivo&lt;/button&gt;
        &lt;ul&gt;
          &lt;li *ngFor=&quot;let arquivo of arquivos&quot;
              (click)=&quot;abrirArquivo(arquivo.nome)&quot;
              [class.selected]=&quot;arquivoAtual === arquivo.nome&quot;&gt;
            {{ arquivo.nome }} ({{ arquivo.tamanho }} bytes)
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
      &lt;div class=&quot;editor&quot;&gt;
        &lt;div class=&quot;toolbar&quot;&gt;
          &lt;input [(ngModel)]=&quot;nomeArquivo&quot; placeholder=&quot;Nome do arquivo&quot;&gt;
          &lt;button (click)=&quot;salvarArquivo()&quot; [disabled]=&quot;!arquivoAtual&quot;&gt;Salvar&lt;/button&gt;
          &lt;button (click)=&quot;deletarArquivo()&quot; [disabled]=&quot;!arquivoAtual&quot;&gt;Deletar&lt;/button&gt;
        &lt;/div&gt;
        &lt;textarea
          [(ngModel)]=&quot;conteudoArquivo&quot;
          placeholder=&quot;Digite seu conteúdo aqui...&quot;
          rows=&quot;20&quot;
          cols=&quot;80&quot;&gt;
        &lt;/textarea&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `
})
export class EditorArquivosComponent implements OnInit {
  arquivos: any[] = [];
  arquivoAtual: string = '';
  nomeArquivo: string = '';
  conteudoArquivo: string = '';

  constructor(private opfsService: OpfsService) {}

  async ngOnInit() {
    const suportado = await this.opfsService.inicializar();
    if (suportado) {
      await this.carregarListaArquivos();
    } else {
      alert('OPFS não é suportado neste navegador');
    }
  }

  async carregarListaArquivos() {
    this.arquivos = await this.opfsService.listarArquivos();
  }

  async abrirArquivo(nome: string) {
    try {
      this.conteudoArquivo = await this.opfsService.lerArquivo(nome);
      this.arquivoAtual = nome;
      this.nomeArquivo = nome;
    } catch (error) {
      console.error('Erro ao abrir arquivo:', error);
    }
  }

  async salvarArquivo() {
    if (!this.nomeArquivo || !this.conteudoArquivo) return;
    try {
      await this.opfsService.salvarArquivo(this.nomeArquivo, this.conteudoArquivo);
      this.arquivoAtual = this.nomeArquivo;
      await this.carregarListaArquivos();
    } catch (error) {
      console.error('Erro ao salvar arquivo:', error);
    }
  }

  async deletarArquivo() {
    if (!this.arquivoAtual) return;
    if (confirm(`Deletar arquivo ${this.arquivoAtual}?`)) {
      try {
        await this.opfsService.deletarArquivo(this.arquivoAtual);
        this.arquivoAtual = '';
        this.nomeArquivo = '';
        this.conteudoArquivo = '';
        await this.carregarListaArquivos();
      } catch (error) {
        console.error('Erro ao deletar arquivo:', error);
      }
    }
  }

  criarNovoArquivo() {
    this.arquivoAtual = '';
    this.nomeArquivo = 'novo-arquivo.txt';
    this.conteudoArquivo = '';
  }
}
</code></pre>
<p>📺 <strong>CONTEÚDOS PARA ASSISTIR</strong></p>
<ul>
<li><strong>YouTube</strong>: "Origin Private File System API" - Chrome for Developers</li>
<li><strong>YouTube</strong>: "File System Access API vs OPFS" - Web Platform News</li>
<li><strong>Talk</strong>: "The Future of File Storage on the Web" - Google I/O</li>
</ul>
<p>📚 <strong>FONTES DE ESTUDO</strong></p>
<ul>
<li><a href="https://web.dev/articles/origin-private-file-system-api">Web.dev - Origin Private File System</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_API">MDN - File System API</a></li>
<li><a href="https://chromestatus.com/feature/6284708426022912">Chrome Platform Status - OPFS</a></li>
</ul>
<p>📝 <strong>EXERCÍCIOS PRÁTICOS</strong></p>
<p>Exercício 1 - Sistema de Backup Local</p>
<p>Implemente um sistema que:</p>
<ul>
<li>Faça backup automático de dados da aplicação</li>
<li>Mantenha múltiplas versões</li>
<li>Permita restauração seletiva</li>
</ul>
<p>Exercício 2 - Editor de Imagens Offline</p>
<p>Crie um editor que:</p>
<ul>
<li>Carregue e salve imagens localmente</li>
<li>Mantenha histórico de edições</li>
<li>Exporte em diferentes formatos</li>
</ul>
<hr />
<h2 id="7-projeto-final">7. PROJETO FINAL</h2>
<p>🎯 <strong>ESPECIFICAÇÕES DO PROJETO</strong></p>
<p>Tema: Sistema de Gestão de Conteúdo Offline-First</p>
<p>Desenvolva uma aplicação Angular que demonstre o uso integrado de todas as tecnologias de storage estudadas:</p>
<p>Funcionalidades Obrigatórias:</p>
<ol>
<li><strong>Sistema de Usuários</strong> (Cookies + localStorage)<ul>
<li>Login/logout com cookies seguros</li>
<li>Preferências salvas em localStorage</li>
<li>Sessão com timeout</li>
</ul>
</li>
<li><strong>Gestão de Conteúdo</strong> (IndexedDB + sessionStorage)<ul>
<li>CRUD completo de artigos/posts</li>
<li>Rascunhos salvos automaticamente</li>
<li>Cache de dados da API</li>
</ul>
</li>
<li><strong>Funcionalidade Offline</strong> (Service Workers + Cache API)<ul>
<li>Aplicação funciona sem internet</li>
<li>Sincronização quando voltar online</li>
<li>Updates automáticos da aplicação</li>
</ul>
</li>
<li><strong>Sistema de Arquivos</strong> (OPFS)<ul>
<li>Upload e gestão de imagens</li>
<li>Export de dados</li>
<li>Backup local automático</li>
</ul>
</li>
</ol>
<p>Arquitetura Sugerida:</p>
<pre><code>src/
├── app/
│   ├── core/
│   │   ├── services/
│   │   │   ├── storage/
│   │   │   │   ├── local-storage.service.ts
│   │   │   │   ├── session-storage.service.ts
│   │   │   │   ├── cookie.service.ts
│   │   │   │   ├── indexeddb.service.ts
│   │   │   │   ├── opfs.service.ts
│   │   │   │   └── cache.service.ts
│   │   │   ├── auth.service.ts
│   │   │   └── sync.service.ts
│   │   └── models/
│   ├── features/
│   │   ├── auth/
│   │   ├── content/
│   │   ├── files/
│   │   └── settings/
│   └── shared/
└── sw.js
</code></pre>
<p>Critérios de Avaliação:</p>
<ul>
<li><strong>Implementação Técnica (40%)</strong></li>
<li>Uso correto de cada tecnologia de storage</li>
<li>Tratamento de erros</li>
<li>Performance</li>
<li><strong>Arquitetura (30%)</strong></li>
<li>Organização do código</li>
<li>Separação de responsabilidades</li>
<li>Reutilização</li>
<li><strong>UX/UI (20%)</strong></li>
<li>Interface intuitiva</li>
<li>Feedback ao usuário</li>
<li>Responsividade</li>
<li><strong>Documentação (10%)</strong></li>
<li>README completo</li>
<li>Comentários no código</li>
<li>Guia de instalação</li>
</ul>
<p>📋 <strong>ENTREGÁVEIS</strong></p>
<ol>
<li><strong>Código fonte</strong> no GitHub</li>
<li><strong>Demo online</strong> (GitHub Pages/Netlify)</li>
<li><strong>Documentação técnica</strong></li>
<li><strong>Apresentação</strong> (10 minutos)</li>
</ol>
<p>⏰ <strong>Cronograma</strong></p>
<ul>
<li><strong>Semana 1-2</strong>: Configuração inicial e autenticação</li>
<li><strong>Semana 3-4</strong>: Gestão de conteúdo e IndexedDB</li>
<li><strong>Semana 5-6</strong>: Service Workers e funcionalidade offline</li>
<li><strong>Semana 7-8</strong>: OPFS e refinamentos finais</li>
</ul>
<hr />
<p>📚 <strong>RECURSOS ADICIONAIS</strong></p>
<p>Trilha de Conteúdo Complementar:</p>
<p>Nível Iniciante:</p>
<ul>
<li><a href="https://ng-girls.gitbook.io/todo-list-tutorial-portuguese/local_storage">NgGirls - Tutorial LocalStorage</a></li>
<li><a href="https://www.treinaweb.com.br/blog/quando-usar-sessionstorage-e-localstorage">TreinaWeb - Storage Comparison</a></li>
<li><a href="https://www.angulartraining.com/daily-newsletter/localstorage-and-sessionstorage/">Angular Training - Storage Guide</a></li>
</ul>
<p>Nível Intermediário:</p>
<ul>
<li><a href="https://www.freecodecamp.org/news/a-quick-but-complete-guide-to-indexeddb-25f030425501/">FreeCodeCamp - IndexedDB Guide</a></li>
<li><a href="https://dexie.org/docs/Tutorial/Angular">Dexie.js - Angular Tutorial</a></li>
<li><a href="https://www.telerik.com/blogs/beginners-guide-indexeddb">Telerik - IndexedDB for Beginners</a></li>
</ul>
<p>Nível Avançado:</p>
<ul>
<li><a href="https://rxdb.info/articles/angular-indexeddb.html">RxDB - Angular IndexedDB</a></li>
<li><a href="https://opensource.salesforce.com/akita/docs/enhancers/persist-state/">Akita - State Management</a></li>
<li><a href="https://auth0.com/blog/state-management-in-angular-with-akita-1/">Auth0 - Akita Integration</a></li>
</ul>
<p>Service Workers &amp; PWA:</p>
<ul>
<li><a href="https://blog.angular-university.io/angular-service-worker/">Angular University - SW Guide</a></li>
<li><a href="https://codezup.com/angular-service-worker-a-practical-guide-to-caching-and-offline-support/">CodeZup - Practical SW Guide</a></li>
<li><a href="https://web.dev/articles/service-worker-caching-and-http-caching">Web.dev - SW Caching</a></li>
</ul>
<p>OPFS &amp; Modern APIs:</p>
<ul>
<li><a href="https://web.dev/articles/origin-private-file-system-api">Web.dev - OPFS</a></li>
<li><a href="https://chromestatus.com/feature/6284708426022912">Chrome Platform Status - OPFS</a></li>
</ul>
<p>Canais YouTube Recomendados:</p>
<ul>
<li><strong>Academind</strong> - Angular tutorials</li>
<li><strong>Programming with Mosh</strong> - Web fundamentals</li>
<li><strong>Traversy Media</strong> - Full-stack development</li>
<li><strong>Google Chrome Developers</strong> - Web APIs</li>
<li><strong>Angular</strong> - Official channel</li>
</ul>
<p>Comunidades e Fóruns:</p>
<ul>
<li><strong>Stack Overflow</strong> - Dúvidas técnicas</li>
<li><strong>Angular Discord</strong> - Comunidade ativa</li>
<li><strong>Reddit r/Angular2</strong> - Discussões</li>
<li><strong>Dev.to</strong> - Artigos da comunidade</li>
</ul>
<hr />
<p>🏆 <strong>CONCLUSÃO</strong></p>
<p>Esta apostila oferece uma base sólida para compreender e implementar todas as principais tecnologias de armazenamento web modernas. O domínio desses conceitos é essencial para desenvolver aplicações web robustas, performáticas e com excelente experiência do usuário.</p>
<p>Lembre-se: a escolha da tecnologia de storage adequada depende sempre do contexto específico do seu projeto. Use esta apostila como referência e pratique bastante com os exercícios propostos.</p>
<p><strong>Boa sorte nos estudos!</strong> 🚀</p></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '../..';</script>
        <script src="../../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../../assets/js/mkdocs.js"></script>
			<script src="../../search/main.js" defer></script>

</body>

</html>