<!doctype html>
<html lang="en">

<head>
        <title>Semana 2 - Meus Estudos</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">Meus Estudos</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Início
                </a>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#requisitos-collapse" aria-expanded="false">
                    Requisitos
                </a>
                <div class="collapse" id="requisitos-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Requisitos/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#lógica-collapse" aria-expanded="false">
                    Lógica
                </a>
                <div class="collapse" id="lógica-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Logica/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Lógica de Programação
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#web-collapse" aria-expanded="false">
                    Web
                </a>
                <div class="collapse" id="web-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Web/Armazenamento/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Armazenamento Web
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class=" active 
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#typescript-collapse" aria-expanded="false">
                    TypeScript
                </a>
                <div class="collapse" id="typescript-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../estrutura-plano/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana1/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 1
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="./"
            class=" active 
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 2
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana3/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 3
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana4/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 4
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#mongo-collapse" aria-expanded="false">
                    Mongo
                </a>
                <div class="collapse" id="mongo-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Apostila
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/respostas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Respostas
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/tarefas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Tarefas
        </a>
    </li>
                    </ul>
                </div>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../Semana1/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a href="../Semana3/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><h1 id="semana-2-classes-avancadas-e-generics">Semana 2: Classes Avançadas e Generics</h1>
<h2 id="visao-geral-da-semana">Visão Geral da Semana</h2>
<p>Com os fundamentos sólidos, a segunda semana mergulha em conceitos mais poderosos e abstratos. Vamos explorar herança com <code>abstract classes</code>, o poder da reutilização de código com <code>generics</code>, o uso avançado do <code>this</code>, e introduzir <code>decorators</code> para metaprogramação. Continuaremos nossa missão de eliminar o <code>any</code> com tipos mais sofisticados como <code>never</code> e <code>branded types</code>, e finalizaremos com a introdução aos <code>conditional types</code>, uma das ferramentas mais avançadas do TypeScript.</p>
<hr />
<h2 id="dia-8-heranca-e-abstract-classes">Dia 8: Herança e Abstract Classes</h2>
<h3 id="foco-do-dia">Foco do Dia</h3>
<p>Entender como criar hierarquias de classes usando herança (<code>extends</code>) e como definir "contratos" de classes com <code>abstract classes</code>.</p>
<h3 id="leitura-e-teoria-aprofundada">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Herança (<code>extends</code>)</strong>: Permite que uma classe (subclasse ou classe filha) herde propriedades e métodos de outra classe (superclasse ou classe pai). Isso promove a reutilização de código.</li>
<li><strong><code>super()</code></strong>: Dentro do <code>constructor</code> de uma subclasse, <code>super()</code> é usado para chamar o <code>constructor</code> da classe pai. Isso é obrigatório antes de usar a palavra-chave <code>this</code> na subclasse.</li>
<li><strong>Sobrescrita de Métodos (Method Overriding)</strong>: Uma subclasse pode fornecer sua própria implementação de um método que já existe na classe pai.</li>
<li><strong>Classes Abstratas (<code>abstract class</code>)</strong>: São classes que não podem ser instanciadas diretamente. Elas servem como um modelo base para outras classes. Podem conter <code>métodos abstratos</code>, que são métodos sem implementação que <strong>devem</strong> ser implementados pelas subclasses.</li>
</ul>
<h3 id="documentacao-essencial">Documentação Essencial</h3>
<ul>
<li><a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Classes/extends">Herança de Classes (MDN)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#abstract-classes-and-members">Abstract Classes and Members (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Herança Simples</strong></p>
<pre><code class="language-typescript">class Animal {
  constructor(public name: string) {}

  move(distanceInMeters: number = 0) {
    console.log(`${this.name} moveu ${distanceInMeters}m.`);
  }
}

class Dog extends Animal {
  // O construtor da subclasse
  constructor(name: string) {
    super(name); // Chama o construtor da classe Animal
  }

  // Sobrescrevendo o método move
  move(distanceInMeters: number = 5) {
    console.log(&quot;Correndo...&quot;);
    super.move(distanceInMeters);
  }
}

const myDog = new Dog(&quot;Rex&quot;);
myDog.move(10);
</code></pre>
<p><strong>Exemplo 2: Classes Abstratas</strong></p>
<pre><code class="language-typescript">abstract class Shape {
  // Método abstrato: sem implementação, deve ser definido na subclasse
  abstract getArea(): number;

  // Método concreto: já tem implementação e é herdado
  printInfo() {
    console.log(`Esta é uma forma com área de ${this.getArea()}`);
  }
}

class Circle extends Shape {
  constructor(private radius: number) {
    super();
  }

  // Implementação obrigatória do método abstrato
  getArea(): number {
    return Math.PI * this.radius ** 2;
  }
}

// const shape = new Shape(); // Erro: Não se pode criar instância de classe abstrata.
const myCircle = new Circle(10);
myCircle.printInfo();
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe base <code>Vehicle</code> com uma propriedade <code>brand</code> (marca) e um método <code>startEngine()</code> que imprime "Motor ligado". Crie uma subclasse <code>Car</code> que herda de <code>Vehicle</code> e adiciona uma propriedade <code>model</code>. O construtor de <code>Car</code> deve receber <code>brand</code> e <code>model</code>.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">class Vehicle {
  constructor(public brand: string) {}

  startEngine(): void {
    console.log(&quot;Motor ligado.&quot;);
  }
}

class Car extends Vehicle {
  constructor(brand: string, public model: string) {
    super(brand); // Passa a marca para o construtor da classe pai
  }

  displayInfo(): void {
    console.log(`Carro: ${this.brand} ${this.model}`);
  }
}

// Teste
const myCar = new Car(&quot;Volkswagen&quot;, &quot;Gol&quot;);
myCar.displayInfo(); // &quot;Carro: Volkswagen Gol&quot;
myCar.startEngine(); // &quot;Motor ligado.&quot;
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe abstrata <code>LoggerBase</code> com um método abstrato <code>log(message: string)</code>. Crie duas classes concretas que herdam de <code>LoggerBase</code>: <code>ConsoleLogger</code> (que imprime a mensagem no console) e <code>FileLogger</code> (que simula a escrita da mensagem em um arquivo, imprimindo "Escrevendo no arquivo: [mensagem]").</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">abstract class LoggerBase {
  abstract log(message: string): void;

  logWithTimestamp(message: string): void {
    const timestamp = new Date().toISOString();
    this.log(`[${timestamp}] ${message}`);
  }
}

class ConsoleLogger extends LoggerBase {
  log(message: string): void {
    console.log(message);
  }
}

class FileLogger extends LoggerBase {
  constructor(private filePath: string) {
    super();
  }

  log(message: string): void {
    // Simulação
    console.log(`Escrevendo em ${this.filePath}: ${message}`);
  }
}

// Teste
const consoleLogger = new ConsoleLogger();
consoleLogger.logWithTimestamp(&quot;Esta é uma mensagem de teste.&quot;);

const fileLogger = new FileLogger(&quot;/var/log/app.log&quot;);
fileLogger.logWithTimestamp(&quot;Erro crítico no sistema.&quot;);
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Recrie a estrutura do seu <code>GetTableDataService</code> usando uma classe abstrata. Crie uma classe <code>BaseService&lt;TResponse, TParams&gt;</code> com um método abstrato <code>handle(params: TParams): Promise&lt;TResponse&gt;</code>. Crie uma classe concreta <code>FetchUsersService</code> que herda de <code>BaseService</code> e implementa o método <code>handle</code> para "buscar" uma lista de usuários.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">// Definição dos tipos para o serviço concreto
interface User {
  id: number;
  name: string;
}

interface FetchUsersParams {
  page: number;
  limit: number;
}

// A classe abstrata base
abstract class BaseService&lt;TResponse, TParams&gt; {
  abstract handle(params: TParams): Promise&lt;TResponse&gt;;

  // Um método concreto que pode ser compartilhado
  protected logRequest(params: TParams): void {
    console.log(&quot;Iniciando requisição com os parâmetros:&quot;, params);
  }
}

// A implementação concreta
class FetchUsersService extends BaseService&lt;User[], FetchUsersParams&gt; {
  async handle(params: FetchUsersParams): Promise&lt;User[]&gt; {
    this.logRequest(params);
    console.log(`Buscando usuários... Página: ${params.page}, Limite: ${params.limit}`);

    // Simula uma chamada de API
    const fakeUsers: User[] = [
      { id: 1, name: &quot;Lucas&quot; },
      { id: 2, name: &quot;Ana&quot; },
    ];

    return Promise.resolve(fakeUsers);
  }
}

// Teste
async function runService() {
  const userService = new FetchUsersService();
  const users = await userService.handle({ page: 1, limit: 10 });
  console.log(&quot;Usuários recebidos:&quot;, users);
}

runService();
</code></pre>

</details>

<h3 id="checklist-do-dia">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi como <code>extends</code> e <code>super()</code> funcionam.</li>
<li>[ ] Sei a diferença entre uma classe normal e uma abstrata.</li>
<li>[ ] Implementei um método abstrato em uma subclasse.</li>
<li>[ ] Criei uma hierarquia de classes para reutilizar código.</li>
</ul>
<hr />
<h2 id="dia-9-generics-em-classes">Dia 9: Generics em Classes</h2>
<h3 id="foco-do-dia_1">Foco do Dia</h3>
<p>Escrever classes flexíveis e reutilizáveis que podem trabalhar com diferentes tipos de dados usando Generics (<code>&lt;T&gt;</code>).</p>
<h3 id="leitura-e-teoria-aprofundada_1">Leitura e Teoria (Aprofundada)</h3>
<p>Generics permitem que você crie componentes que funcionam com qualquer tipo, em vez de um tipo específico. Isso aumenta drasticamente a reutilização de código e a segurança de tipo.</p>
<ul>
<li><strong>Parâmetros de Tipo (<code>&lt;T&gt;</code>)</strong>: A letra <code>T</code> é uma convenção para "Type". Você pode usar qualquer nome (<code>&lt;TData&gt;</code>, <code>&lt;TValue&gt;</code>, etc.). Ela atua como uma variável para o tipo.</li>
<li><strong>Constraints (<code>extends</code>)</strong>: Você pode restringir os tipos que podem ser usados com um generic. <code>class MyClass&lt;T extends SomeType&gt;</code> significa que <code>T</code> deve ser compatível com <code>SomeType</code>.</li>
<li><strong>Múltiplos Parâmetros de Tipo</strong>: Uma classe pode ter vários parâmetros de tipo, como <code>class Pair&lt;K, V&gt;</code> para um par chave-valor.</li>
<li><strong>Tipos Padrão</strong>: Você pode fornecer um tipo padrão para um parâmetro genérico: <code>class MyClass&lt;T = string&gt;</code>.</li>
</ul>
<h3 id="documentacao-essencial_1">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">Generics (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_1">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Uma Caixa Genérica</strong></p>
<pre><code class="language-typescript">class Box&lt;T&gt; {
  private content: T;

  constructor(initialContent: T) {
    this.content = initialContent;
  }

  getContent(): T {
    return this.content;
  }
}

const stringBox = new Box&lt;string&gt;(&quot;Olá, Generics!&quot;);
const numberBox = new Box&lt;number&gt;(123);

console.log(stringBox.getContent().toUpperCase());
console.log(numberBox.getContent().toFixed(2));
</code></pre>
<p><strong>Exemplo 2: Generic com Constraints</strong></p>
<pre><code class="language-typescript">interface WithLength {
  length: number;
}

// T pode ser qualquer tipo, desde que tenha uma propriedade `length`
class LengthReporter&lt;T extends WithLength&gt; {
  constructor(private value: T) {}

  report() {
    console.log(`O comprimento é ${this.value.length}`);
  }
}

const stringReporter = new LengthReporter(&quot;uma string&quot;);
const arrayReporter = new LengthReporter([1, 2, 3]);
// const numberReporter = new LengthReporter(123); // Erro: `number` não tem a propriedade `length`.

stringReporter.report();
arrayReporter.report();
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_1">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe genérica <code>DataStore&lt;T&gt;</code> que armazena um array de itens do tipo <code>T</code>. Ela deve ter os métodos <code>add(item: T)</code> e <code>getAll(): T[]</code>.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">class DataStore&lt;T&gt; {
  private data: T[] = [];

  add(item: T): void {
    this.data.push(item);
  }

  getAll(): T[] {
    return this.data;
  }
}

// Teste com strings
const stringStore = new DataStore&lt;string&gt;();
stringStore.add(&quot;TypeScript&quot;);
stringStore.add(&quot;Generics&quot;);
console.log(stringStore.getAll()); // [&quot;TypeScript&quot;, &quot;Generics&quot;]

// Teste com números
const numberStore = new DataStore&lt;number&gt;();
numberStore.add(10);
numberStore.add(20);
console.log(numberStore.getAll()); // [10, 20]
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe genérica <code>Cache&lt;T&gt;</code> que armazena um valor do tipo <code>T</code> e uma data de expiração. Implemente os métodos <code>set(value: T, ttl: number)</code> (ttl em segundos) e <code>get(): T | null</code>. O método <code>get</code> deve retornar <code>null</code> se o cache tiver expirado.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">class Cache&lt;T&gt; {
  private value: T | null = null;
  private expiresAt: Date | null = null;

  set(value: T, ttlInSeconds: number): void {
    this.value = value;
    const now = new Date();
    this.expiresAt = new Date(now.getTime() + ttlInSeconds * 1000);
    console.log(`Valor armazenado no cache. Expira em: ${this.expiresAt.toLocaleTimeString()}`);
  }

  get(): T | null {
    if (this.expiresAt &amp;&amp; this.expiresAt &gt; new Date() &amp;&amp; this.value) {
      console.log(&quot;Valor retornado do cache.&quot;);
      return this.value;
    }
    console.log(&quot;Cache expirado ou vazio.&quot;);
    this.value = null;
    this.expiresAt = null;
    return null;
  }
}

// Teste
async function testCache() {
  const userCache = new Cache&lt;{ name: string }&gt;();
  userCache.set({ name: &quot;Lucas&quot; }, 3); // Expira em 3 segundos

  console.log(userCache.get()); // Retorna o objeto

  await new Promise(resolve =&gt; setTimeout(resolve, 4000)); // Espera 4 segundos

  console.log(userCache.get()); // Retorna null
}

testCache();
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie uma classe <code>DataService&lt;T extends { id: K }, K extends string | number&gt;</code>. Esta classe deve gerenciar uma coleção de entidades <code>T</code>. Implemente os métodos <code>add(item: T)</code> e <code>findById(id: K): T | undefined</code>. O uso de múltiplos generics (<code>T</code> e <code>K</code>) garante que o tipo do <code>id</code> seja consistente.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">// A constraint genérica
interface BaseEntity&lt;K extends string | number&gt; {
  id: K;
}

class DataService&lt;T extends BaseEntity&lt;K&gt;, K extends string | number&gt; {
  private items: Record&lt;K, T&gt; = {} as Record&lt;K, T&gt;;

  add(item: T): void {
    this.items[item.id] = item;
  }

  findById(id: K): T | undefined {
    return this.items[id];
  }

  getAll(): T[] {
    return Object.values(this.items);
  }
}

// Teste
interface Product {
  id: number;
  name: string;
  price: number;
}

// O TS infere que K é `number` a partir de Product['id']
const productService = new DataService&lt;Product, number&gt;();
productService.add({ id: 101, name: &quot;Laptop&quot;, price: 5000 });
productService.add({ id: 102, name: &quot;Mouse&quot;, price: 150 });

console.log(productService.findById(101));
console.log(productService.findById(999));
console.log(productService.getAll());
</code></pre>

</details>

<h3 id="checklist-do-dia_1">Checklist do Dia</h3>
<ul>
<li>[ ] Criei uma classe genérica simples.</li>
<li>[ ] Usei constraints (<code>extends</code>) para limitar os tipos de um generic.</li>
<li>[ ] Entendi como usar múltiplos parâmetros de tipo.</li>
<li>[ ] Apliquei generics para criar uma classe de serviço reutilizável.</li>
</ul>
<hr />
<h2 id="dia-10-contexto-this-parte-2-avancada">Dia 10: Contexto <code>this</code> - Parte 2 Avançada</h2>
<h3 id="foco-do-dia_2">Foco do Dia</h3>
<p>Explorar técnicas avançadas para controlar o <code>this</code>, incluindo <code>this parameters</code> para adicionar tipagem explícita ao <code>this</code> em funções e <code>ThisType&lt;T&gt;</code> para fornecer contexto a objetos literais.</p>
<h3 id="leitura-e-teoria-aprofundada_2">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong><code>this</code> Parameters</strong>: TypeScript permite que você declare o tipo de <code>this</code> como o primeiro parâmetro de uma função. Este parâmetro é falso (não existe no JavaScript compilado), mas é usado pelo TypeScript para garantir que a função seja chamada com o contexto correto.</li>
<li><strong><code>ThisType&lt;T&gt;</code></strong>: Um tipo utilitário que não retorna um novo tipo, mas sim modifica o contexto de <code>this</code> dentro de um objeto literal. É muito útil para criar APIs onde você define métodos em um objeto, mas quer que <code>this</code> se refira a um tipo maior e mais complexo.</li>
</ul>
<h3 id="documentacao-essencial_2">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#this-parameters">This Parameters (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#thistypet">ThisType<T> (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_2">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: <code>this</code> Parameter para Segurança</strong></p>
<pre><code class="language-typescript">// A função espera que `this` seja um objeto com uma propriedade `name`
function sayHello(this: { name: string }) {
  console.log(`Hello, ${this.name}!`);
}

const person = { name: &quot;Lucas&quot;, sayHello };
const anotherPerson = { name: &quot;Ana&quot;, sayHello };

person.sayHello(); // OK
anotherPerson.sayHello(); // OK

// sayHello(); // Erro: O `this` da função não é do tipo `{ name: string }`.
</code></pre>
<p><strong>Exemplo 2: <code>ThisType&lt;T&gt;</code> para Objetos de Configuração</strong></p>
<pre><code class="language-typescript">interface ComponentOptions&lt;T&gt; {
  data: () =&gt; T;
  methods: Record&lt;string, (this: T, ...args: any[]) =&gt; any&gt;;
}

// O tipo `T` em `ThisType&lt;T&gt;` define o tipo de `this` nos métodos
function createComponent&lt;T&gt;(options: ComponentOptions&lt;T&gt; &amp; { methods: ThisType&lt;T&gt; }): void {
  // Lógica de criação do componente...
  console.log(&quot;Component created.&quot;);
}

createComponent({
  data: () =&gt; ({ count: 0, message: &quot;Hello&quot; }),
  methods: {
    increment() {
      // Graças a `ThisType`, o TS sabe que `this` tem `count` e `message`
      this.count++;
    },
    logMessage() {
      console.log(this.message);
    }
  }
});
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_2">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma interface <code>User</code> com <code>name: string</code>. Crie uma função <code>printUserName</code> que não recebe argumentos, mas espera que o <code>this</code> seja do tipo <code>User</code>. Demonstre seu uso correto e incorreto.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">interface User {
  name: string;
}

function printUserName(this: User): void {
  console.log(`User name: ${this.name}`);
}

// Teste
const user1: User = { name: &quot;Alice&quot; };
const user2: User = { name: &quot;Bob&quot; };

// Para chamar a função, precisamos fornecer o contexto `this`
printUserName.call(user1); // &quot;User name: Alice&quot;
printUserName.apply(user2); // &quot;User name: Bob&quot;

// const standaloneCall = printUserName; // Erro ao tentar chamar standaloneCall()
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe <code>Configuration&lt;T&gt;</code> que armazena um objeto de configuração. Crie um método <code>update(updater: (this: T, currentConfig: T) =&gt; T)</code>. A função <code>updater</code> deve receber a configuração atual, mas seu <code>this</code> deve ser tipado como a própria configuração <code>T</code>, permitindo acesso direto às propriedades.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">class Configuration&lt;T&gt; {
  constructor(private config: T) {}

  public update(updater: (this: T, currentConfig: T) =&gt; T): void {
    const newConfig = updater.call(this.config, this.config);
    this.config = newConfig;
  }

  public getConfig(): T {
    return this.config;
  }
}

// Teste
interface AppConfig {
  apiUrl: string;
  timeout: number;
}

const myConfig = new Configuration&lt;AppConfig&gt;({ 
  apiUrl: &quot;/api/v1&quot;, 
  timeout: 5000 
});

// A função updater pode usar `this` para acessar as propriedades de AppConfig
myConfig.update(function(current) {
  return {
    ...current,
    timeout: this.timeout + 1000 // `this` é do tipo AppConfig
  };
});

console.log(myConfig.getConfig()); // { apiUrl: '/api/v1', timeout: 6000 }
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Implemente a classe <code>FormBuilder&lt;T&gt;</code> do plano de estudos. Ela deve ter um método <code>field&lt;K extends keyof T&gt;(name: K, value: T[K]): this</code> que adiciona um campo ao formulário. O método <code>field</code> deve retornar <code>this</code> para encadeamento. Crie um método <code>build(): T</code> que retorna o objeto de formulário completo.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">class FormBuilder&lt;T extends object&gt; {
  private formData: Partial&lt;T&gt; = {};

  // O tipo de retorno `this` permite o encadeamento
  public field&lt;K extends keyof T&gt;(name: K, value: T[K]): this {
    this.formData[name] = value;
    return this;
  }

  // O type guard `this is { formData: T }` ajuda o TS a saber que o form está completo
  private isComplete(): this is { formData: T } {
    // Em um cenário real, verificaríamos se todas as chaves de T existem em formData
    return true; // Simplificação para o exercício
  }

  public build(): T | Error {
    if (this.isComplete()) {
      return this.formData; // Graças ao type guard, o TS sabe que formData é T, não Partial&lt;T&gt;
    }
    return new Error(&quot;Formulário incompleto.&quot;);
  }
}

// Teste
interface UserForm {
  name: string;
  email: string;
  age: number;
}

const userFormBuilder = new FormBuilder&lt;UserForm&gt;();

const newUser = userFormBuilder
  .field(&quot;name&quot;, &quot;Lucas&quot;)
  .field(&quot;email&quot;, &quot;lucas@ts.com&quot;)
  .field(&quot;age&quot;, 30)
  .build();

console.log(newUser);
</code></pre>

</details>

<h3 id="checklist-do-dia_2">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi o propósito de um <code>this</code> parameter.</li>
<li>[ ] Usei um <code>this</code> parameter para adicionar segurança a uma função.</li>
<li>[ ] Entendi como <code>ThisType&lt;T&gt;</code> funciona em objetos literais.</li>
<li>[ ] Criei uma classe builder usando <code>this</code> para encadeamento.</li>
</ul>
<hr />
<h2 id="dia-11-decorators">Dia 11: Decorators</h2>
<h3 id="foco-do-dia_3">Foco do Dia</h3>
<p>Introduzir <code>decorators</code>, uma proposta do ECMAScript para adicionar anotações e modificar classes e seus membros em tempo de design.</p>
<h3 id="leitura-e-teoria-aprofundada_3">Leitura e Teoria (Aprofundada)</h3>
<p>Decorators são funções especiais que podem ser anexadas a classes, métodos, propriedades ou parâmetros. Eles são executados durante a definição da classe, não durante a instanciação.</p>
<p><strong>Para usar decorators, você precisa habilitar a opção <code>experimentalDecorators</code> no seu <code>tsconfig.json</code>.</strong></p>
<ul>
<li><strong>Tipos de Decorators</strong>: Class, Method, Accessor, Property, Parameter.</li>
<li><strong>Fábrica de Decorators (Decorator Factory)</strong>: Uma função que retorna a expressão do decorator. Isso permite que você configure o decorator, como <code>@log("INFO")</code>.</li>
<li><strong>Composição</strong>: Múltiplos decorators podem ser aplicados a uma declaração.</li>
<li><strong><code>reflect-metadata</code></strong>: Uma biblioteca usada para adicionar metadados a classes e propriedades, que podem ser lidos posteriormente pelos decorators.</li>
</ul>
<h3 id="documentacao-essencial_3">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/decorators.html">Decorators (Handbook)</a> (Nota: esta é uma feature experimental)</li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_3">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Decorator de Método Simples</strong></p>
<pre><code class="language-typescript">// O decorator recebe o alvo (a classe), a chave (nome do método) e o descritor da propriedade
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args: any[]) {
    console.log(`Chamando o método ${propertyKey} com os argumentos:`, args);
    const result = originalMethod.apply(this, args);
    console.log(`O método ${propertyKey} retornou:`, result);
    return result;
  }
}

class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
}

new Calculator().add(2, 3);
</code></pre>
<p><strong>Exemplo 2: Decorator Factory</strong></p>
<pre><code class="language-typescript">function Enumerable(isEnumerable: boolean) {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.enumerable = isEnumerable;
  }
}

class Person {
  constructor(private name: string) {}

  @Enumerable(true)
  getName() { return this.name; }

  @Enumerable(false)
  getAge() { return 30; }
}

// O método getName aparecerá no loop, mas getAge não.
for (const key in new Person(&quot;Lucas&quot;)) {
  console.log(key);
}
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_3">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie um decorator de método chamado <code>@deprecated</code>. Quando um método decorado com ele for chamado, ele deve imprimir um aviso no console: <code>Aviso: O método [nome do método] está obsoleto e será removido em futuras versões.</code></p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">function deprecated(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.warn(`Aviso: O método ${propertyKey} está obsoleto e será removido em futuras versões.`);
    return originalMethod.apply(this, args);
  }
}

class OldApiService {
  @deprecated
  findUsers() {
    console.log(&quot;Buscando usuários...&quot;);
    return [{ name: &quot;Lucas&quot; }];
  }
}

// Teste
new OldApiService().findUsers();
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie um decorator de propriedade <code>@min(minValue: number)</code>. Este decorator deve garantir que, sempre que a propriedade for alterada, seu novo valor não seja menor que <code>minValue</code>. Se for, um erro deve ser lançado.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">function min(minValue: number) {
  return function(target: any, propertyKey: string) {
    let value = target[propertyKey];

    const getter = () =&gt; value;
    const setter = (newValue: number) =&gt; {
      if (newValue &lt; minValue) {
        throw new Error(`O valor de ${propertyKey} não pode ser menor que ${minValue}.`);
      }
      value = newValue;
    };

    Object.defineProperty(target, propertyKey, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true,
    });
  }
}

class Product {
  @min(0)
  price: number;

  @min(0)
  stock: number;

  constructor(price: number, stock: number) {
    this.price = price;
    this.stock = stock;
  }
}

// Teste
const product = new Product(50, 100);
console.log(product.price); // 50
product.price = 75;
console.log(product.price); // 75

try {
  product.stock = -10;
} catch (e: any) {
  console.error(e.message);
}
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um decorator de método <code>@cache</code>. Ele deve armazenar o resultado da primeira chamada do método. Nas chamadas subsequentes com os mesmos argumentos, ele deve retornar o resultado do cache em vez de executar o método novamente. Use <code>JSON.stringify</code> para criar uma chave de cache a partir dos argumentos.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  const cache = new Map&lt;string, any&gt;();

  descriptor.value = function(...args: any[]) {
    const cacheKey = JSON.stringify(args);

    if (cache.has(cacheKey)) {
      console.log(`Retornando do cache para a chave: ${cacheKey}`);
      return cache.get(cacheKey);
    }

    console.log(`Executando o método pela primeira vez para a chave: ${cacheKey}`);
    const result = originalMethod.apply(this, args);
    cache.set(cacheKey, result);
    return result;
  }
}

class MathOperations {
  @cache
  heavyCalculation(a: number, b: number): number {
    // Simula uma operação pesada
    const start = Date.now();
    while (Date.now() - start &lt; 1000) {}
    return a + b;
  }
}

// Teste
const math = new MathOperations();
console.log(math.heavyCalculation(2, 3)); // Executa, demora 1s, retorna 5
console.log(math.heavyCalculation(5, 10)); // Executa, demora 1s, retorna 15
console.log(math.heavyCalculation(2, 3)); // Retorna do cache, instantâneo, retorna 5
</code></pre>

</details>

<h3 id="checklist-do-dia_3">Checklist do Dia</h3>
<ul>
<li>[ ] Habilitei <code>experimentalDecorators</code> no <code>tsconfig.json</code>.</li>
<li>[ ] Entendi a diferença entre um decorator e uma decorator factory.</li>
<li>[ ] Criei um decorator de método simples.</li>
<li>[ ] Criei um decorator de propriedade que modifica seu comportamento.</li>
</ul>
<hr />
<h2 id="dia-12-eliminando-any-parte-2">Dia 12: Eliminando <code>any</code> - Parte 2</h2>
<h3 id="foco-do-dia_4">Foco do Dia</h3>
<p>Introduzir tipos avançados para aumentar a segurança: <code>never</code> para código inalcançável e <code>branded types</code> para criar tipos nominais que o TypeScript não suporta nativamente.</p>
<h3 id="leitura-e-teoria-aprofundada_4">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong><code>never</code></strong>: Representa o tipo de valores que nunca ocorrem. É usado em dois cenários principais:</li>
<li>Em funções que nunca retornam (ex: lançam uma exceção ou entram em um loop infinito).</li>
<li>Para fazer <strong>verificação exaustiva (exhaustive checking)</strong> em <code>switch</code> ou <code>if/else</code>, garantindo que todos os casos de uma união foram tratados.</li>
<li><strong>Branded Types (ou Opaque Types)</strong>: Uma técnica para criar tipos que são estruturalmente idênticos (ex: ambos são <code>string</code>), mas nominalmente diferentes para o TypeScript. Isso evita que você passe um <code>UserID</code> para uma função que espera um <code>ProductID</code>. É um padrão, não uma feature nativa.</li>
</ul>
<h3 id="documentacao-essencial_4">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#never">The <code>never</code> Type (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#exhaustiveness-checking">Exhaustiveness checking (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_4">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: <code>never</code> para Verificação Exaustiva</strong></p>
<pre><code class="language-typescript">type Shape = { kind: &quot;circle&quot;; radius: number } | { kind: &quot;square&quot;; sideLength: number };

function getArea(shape: Shape) {
  switch (shape.kind) {
    case &quot;circle&quot;:
      return Math.PI * shape.radius ** 2;
    case &quot;square&quot;:
      return shape.sideLength ** 2;
    default:
      // Se adicionarmos um novo tipo a Shape (ex: triangle), o TS dará um erro aqui,
      // pois o novo tipo não pode ser atribuído a `never`.
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
</code></pre>
<p><strong>Exemplo 2: Branded Types</strong></p>
<pre><code class="language-typescript">// O &quot;brand&quot; que torna o tipo único
type Brand&lt;K, T&gt; = K &amp; { __brand: T };

// Criando tipos nominais a partir de tipos primitivos
type UserId = Brand&lt;string, &quot;UserId&quot;&gt;;
type ProductId = Brand&lt;string, &quot;ProductId&quot;&gt;;

function getUser(id: UserId) {
  console.log(`Buscando usuário com ID: ${id}`);
}

const userId = &quot;user-123&quot; as UserId;
const productId = &quot;prod-456&quot; as ProductId;

getUser(userId); // OK
// getUser(productId); // Erro! O tipo `ProductId` não é compatível com `UserId`.
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_4">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma função <code>fail(message: string): never</code> que sempre lança um erro com a mensagem fornecida. Use-a em uma função que processa um <code>string | number</code> e chama <code>fail</code> se o tipo não for nenhum dos dois.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">function fail(message: string): never {
  throw new Error(message);
}

function processValue(value: string | number) {
  if (typeof value === 'string') {
    console.log(&quot;Processando string:&quot;, value.toUpperCase());
  } else if (typeof value === 'number') {
    console.log(&quot;Processando número:&quot;, value.toFixed(2));
  } else {
    // O TS sabe que este código é inalcançável
    fail(&quot;Valor inesperado!&quot;);
  }
}

// Teste
processValue(&quot;hello&quot;);
processValue(123);
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie um branded type <code>Email</code> a partir de <code>string</code>. Crie uma função <code>sendEmail(to: Email, subject: string)</code> que só aceita o tipo <code>Email</code>. Crie uma função <code>createEmail(address: string): Email | null</code> que valida se a string contém um <code>@</code> antes de fazer a asserção de tipo para <code>Email</code>.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">type Brand&lt;K, T&gt; = K &amp; { __brand: T };
type Email = Brand&lt;string, &quot;Email&quot;&gt;;

function createEmail(address: string): Email | null {
  if (address.includes(&quot;@&quot;)) {
    return address as Email;
  }
  return null;
}

function sendEmail(to: Email, subject: string): void {
  console.log(`Enviando email para ${to} com o assunto: &quot;${subject}&quot;`);
}

// Teste
const userEmail = createEmail(&quot;lucas@example.com&quot;);
const invalidEmail = createEmail(&quot;invalid-address&quot;);
const plainString = &quot;another@test.com&quot;;

if (userEmail) {
  sendEmail(userEmail, &quot;Olá!&quot;); // OK
}

if (invalidEmail === null) {
  console.log(&quot;Endereço de email inválido detectado.&quot;);
}

// sendEmail(plainString, &quot;Assunto&quot;); // Erro: `string` não é compatível com `Email`.
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um wrapper type-safe para uma biblioteca externa falsa. A biblioteca tem um objeto <code>untypedLibrary</code> que é <code>any</code>. Crie funções <code>safeGetNumber(key: string)</code> e <code>safeGetString(key: string)</code> que usam o <code>untypedLibrary</code>, verificam o tipo do valor retornado, e o retornam com o tipo correto ou <code>undefined</code> se o tipo não corresponder.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">// A biblioteca externa perigosa
declare const untypedLibrary: any;
const untypedLibrary = {
  appName: &quot;Super App&quot;,
  version: 2.1,
  userCount: 1500,
  settings: { theme: &quot;dark&quot; }
};

// O wrapper seguro
class SafeLibraryWrapper {
  private lib: any;

  constructor(library: any) {
    this.lib = library;
  }

  public get(key: string): unknown {
    return this.lib[key];
  }

  public getString(key: string): string | undefined {
    const value = this.get(key);
    if (typeof value === 'string') {
      return value;
    }
    return undefined;
  }

  public getNumber(key: string): number | undefined {
    const value = this.get(key);
    if (typeof value === 'number') {
      return value;
    }
    return undefined;
  }
}

// Teste
const safeLib = new SafeLibraryWrapper(untypedLibrary);

const appName = safeLib.getString(&quot;appName&quot;);
const version = safeLib.getNumber(&quot;version&quot;);
const userCount = safeLib.getNumber(&quot;userCount&quot;);
const settings = safeLib.getString(&quot;settings&quot;); // Retorna undefined, pois não é string

console.log(`App: ${appName}, Versão: ${version}, Usuários: ${userCount}`);
console.log(`Settings (string):`, settings);
</code></pre>

</details>

<h3 id="checklist-do-dia_4">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi o propósito do tipo <code>never</code>.</li>
<li>[ ] Usei <code>never</code> para fazer verificação exaustiva.</li>
<li>[ ] Entendi o padrão de Branded Types e por que ele é útil.</li>
<li>[ ] Criei e usei um branded type para aumentar a segurança de tipo.</li>
</ul>
<hr />
<h2 id="dia-13-conditional-types">Dia 13: Conditional Types</h2>
<h3 id="foco-do-dia_5">Foco do Dia</h3>
<p>Entender <code>Conditional Types</code>, que permitem que um tipo seja escolhido com base em uma condição, e a palavra-chave <code>infer</code> para extrair tipos de dentro de outros tipos.</p>
<h3 id="leitura-e-teoria-aprofundada_5">Leitura e Teoria (Aprofundada)</h3>
<p>Conditional Types têm a forma <code>T extends U ? X : Y</code>, que se lê como: "Se <code>T</code> for compatível com <code>U</code>, então o tipo é <code>X</code>, senão o tipo é <code>Y</code>".</p>
<ul>
<li><strong><code>infer</code></strong>: A palavra-chave <code>infer</code> pode ser usada dentro da cláusula <code>extends</code> para declarar uma nova variável de tipo genérico. Ela "captura" o tipo que está naquela posição para que você possa usá-lo.</li>
</ul>
<p>Exemplo com <code>infer</code>:
  <code>type UnpackPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;</code>
  Aqui, <code>infer U</code> captura o tipo que está dentro do <code>Promise</code> (ex: <code>string</code> em <code>Promise&lt;string&gt;</code>) e o retorna. Se <code>T</code> não for uma <code>Promise</code>, ele retorna <code>T</code>.</p>
<h3 id="documentacao-essencial_5">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">Conditional Types (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-with-infer">Inferring with <code>infer</code> (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_5">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Tipo Condicional Simples</strong></p>
<pre><code class="language-typescript">type IsString&lt;T&gt; = T extends string ? true : false;

type A = IsString&lt;string&gt;; // true
type B = IsString&lt;number&gt;; // false
</code></pre>
<p><strong>Exemplo 2: <code>infer</code> para Obter o Tipo de Retorno de uma Função</strong></p>
<pre><code class="language-typescript">type GetReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : T;

type Fn = () =&gt; number;
type Num = GetReturnType&lt;Fn&gt;; // number

type Str = GetReturnType&lt;string&gt;; // string (cai no caso `Y`)
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_5">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie um tipo utilitário <code>ElementTypeOf&lt;T&gt;</code> que obtém o tipo dos elementos de um array. Se <code>T</code> não for um array, ele deve retornar <code>never</code>. Ex: <code>ElementTypeOf&lt;string[]&gt;</code> deve ser <code>string</code>.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">type ElementTypeOf&lt;T&gt; = T extends (infer E)[] ? E : never;

// Teste
type A = ElementTypeOf&lt;string[]&gt;; // string
type B = ElementTypeOf&lt;number[]&gt;; // number
type C = ElementTypeOf&lt;{ name: string }[]&gt;; // { name: string }
type D = ElementTypeOf&lt;string&gt;; // never
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Implemente seu próprio <code>NonNullable&lt;T&gt;</code>. Este tipo utilitário deve remover <code>null</code> e <code>undefined</code> de um tipo <code>T</code>.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">type MyNonNullable&lt;T&gt; = T extends null | undefined ? never : T;

// Teste
type A = MyNonNullable&lt;string | null&gt;; // string
type B = MyNonNullable&lt;string | number | undefined&gt;; // string | number
type C = MyNonNullable&lt;null | undefined&gt;; // never
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Implemente o tipo <code>DeepPartial&lt;T&gt;</code> do plano de estudos. Ele deve tornar todas as propriedades de um objeto e de seus sub-objetos aninhados opcionais. Dica: você precisará de recursão e mapped types.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">type DeepPartial&lt;T&gt; = T extends object ? {
  // Para cada propriedade P no objeto T
  [P in keyof T]?: DeepPartial&lt;T[P]&gt;; // Torna a propriedade opcional e aplica DeepPartial recursivamente
} : T; // Se T não for um objeto, retorna o próprio tipo

// Teste
interface UserProfile {
  id: number;
  details: {
    name: string;
    address: {
      street: string;
      city: string;
    }
  }
}

type PartialUserProfile = DeepPartial&lt;UserProfile&gt;;

const partialProfile: PartialUserProfile = {
  id: 1,
  details: {
    address: {
      city: &quot;São Paulo&quot;
    }
  }
};
</code></pre>

</details>

<h3 id="checklist-do-dia_5">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi a sintaxe <code>T extends U ? X : Y</code>.</li>
<li>[ ] Usei <code>infer</code> para extrair um tipo de dentro de outro.</li>
<li>[ ] Criei um tipo utilitário condicional simples.</li>
<li>[ ] Implementei um tipo utilitário recursivo (<code>DeepPartial</code>).</li>
</ul>
<hr />
<h2 id="dia-14-projeto-mini-2-sistema-de-autenticacao">Dia 14: Projeto Mini #2 - Sistema de Autenticação</h2>
<h3 id="foco-do-dia_6">Foco do Dia</h3>
<p>Consolidar os conceitos da semana (Herança, Generics, Decorators, Conditional Types) para construir um mini-sistema de autenticação type-safe.</p>
<h3 id="leitura-e-teoria-revisao">Leitura e Teoria (Revisão)</h3>
<ul>
<li><strong>Abstract Classes</strong>: Para definir um contrato para provedores de autenticação.</li>
<li><strong>Generics</strong>: Para lidar com diferentes tipos de dados de usuário (ex: <code>User</code>, <code>Admin</code>).</li>
<li><strong>Decorators</strong>: Para adicionar verificação de permissões de forma declarativa.</li>
<li><strong>Conditional Types</strong>: Para criar tipos de permissão dinâmicos.</li>
</ul>
<h3 id="exercicios-praticos-niveis-crescentes_6">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe abstrata <code>AuthProvider</code> com um método abstrato <code>authenticate(credentials: any): Promise&lt;boolean&gt;</code>. Crie duas classes concretas: <code>EmailProvider</code> e <code>GoogleProvider</code>, que herdam de <code>AuthProvider</code> e implementam o método <code>authenticate</code> (pode apenas simular a lógica e retornar <code>true</code>).</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">abstract class AuthProvider {
  abstract authenticate(credentials: any): Promise&lt;boolean&gt;;
}

class EmailProvider extends AuthProvider {
  async authenticate(credentials: { email: string, pass: string }): Promise&lt;boolean&gt; {
    console.log(`Autenticando com email: ${credentials.email}`);
    return true; // Simulação
  }
}

class GoogleProvider extends AuthProvider {
  async authenticate(credentials: { token: string }): Promise&lt;boolean&gt; {
    console.log(`Autenticando com token do Google: ${credentials.token.substring(0, 10)}...`);
    return true; // Simulação
  }
}

// Teste
const emailAuth = new EmailProvider();
emailAuth.authenticate({ email: &quot;test@test.com&quot;, pass: &quot;123&quot; });

const googleAuth = new GoogleProvider();
googleAuth.authenticate({ token: &quot;abc123xyz&quot; });
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Melhore o sistema do Nível 1. Torne a classe <code>AuthProvider</code> genérica: <code>AuthProvider&lt;TUser, TCreds&gt;</code>. O método <code>authenticate</code> deve agora retornar <code>Promise&lt;TUser | null&gt;</code>. Adapte as classes <code>EmailProvider</code> e <code>GoogleProvider</code> para usar tipos específicos de usuário e credenciais.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">interface BaseUser { id: number; name: string; }

abstract class AuthProvider&lt;TUser extends BaseUser, TCreds&gt; {
  abstract authenticate(credentials: TCreds): Promise&lt;TUser | null&gt;;
}

// Tipos para Email
interface EmailUser extends BaseUser { email: string; }
interface EmailCreds { email: string; pass: string; }

class EmailProvider extends AuthProvider&lt;EmailUser, EmailCreds&gt; {
  async authenticate(credentials: EmailCreds): Promise&lt;EmailUser | null&gt; {
    console.log(`Autenticando com email: ${credentials.email}`);
    if (credentials.pass === &quot;123&quot;) {
      return { id: 1, name: &quot;Usuário de Email&quot;, email: credentials.email };
    }
    return null;
  }
}

// Tipos para Google
interface GoogleUser extends BaseUser { googleId: string; }
interface GoogleCreds { token: string; }

class GoogleProvider extends AuthProvider&lt;GoogleUser, GoogleCreds&gt; {
  async authenticate(credentials: GoogleCreds): Promise&lt;GoogleUser | null&gt; {
    console.log(`Autenticando com token do Google...`);
    return { id: 2, name: &quot;Usuário do Google&quot;, googleId: &quot;g-123&quot; };
  }
}

// Teste
async function testAuth() {
  const emailAuth = new EmailProvider();
  const user1 = await emailAuth.authenticate({ email: &quot;test@test.com&quot;, pass: &quot;123&quot; });
  console.log(&quot;Usuário 1:&quot;, user1);

  const googleAuth = new GoogleProvider();
  const user2 = await googleAuth.authenticate({ token: &quot;abc123xyz&quot; });
  console.log(&quot;Usuário 2:&quot;, user2);
}

testAuth();
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um decorator de método <code>@permission(requiredRole: Role)</code>. Crie um <code>enum Role { USER, ADMIN }</code>. Crie uma classe <code>ProtectedService</code> com um usuário logado (que tem uma propriedade <code>role</code>). Adicione um método <code>sensitiveData()</code> decorado com <code>@permission('ADMIN')</code>. O decorator deve verificar se o <code>role</code> do usuário na instância do serviço corresponde ao <code>requiredRole</code> antes de executar o método. Se não, deve lançar um erro.</p>
<details>
<summary>Ver Solução</summary>

---


<pre><code class="language-typescript">enum Role { USER, ADMIN }

interface UserSession {
  name: string;
  role: Role;
}

// Decorator Factory
function permission(requiredRole: Role) {
  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function(...args: any[]) {
      // `this` aqui se refere à instância de ProtectedService
      const user = (this as any).currentUser as UserSession;

      if (user &amp;&amp; user.role === requiredRole) {
        console.log(`Permissão concedida para ${user.name} (${user.role}).`);
        return originalMethod.apply(this, args);
      } else {
        throw new Error(&quot;Acesso negado: permissão insuficiente.&quot;);
      }
    }
  }
}

class ProtectedService {
  currentUser: UserSession;

  constructor(user: UserSession) {
    this.currentUser = user;
  }

  @permission(Role.ADMIN)
  deleteEverything(): void {
    console.log(&quot;Todos os dados foram deletados com sucesso!&quot;);
  }

  @permission(Role.USER)
  viewDashboard(): void {
    console.log(&quot;Bem-vindo ao seu dashboard!&quot;);
  }
}

// Teste
const adminService = new ProtectedService({ name: &quot;Admin&quot;, role: Role.ADMIN });
const userService = new ProtectedService({ name: &quot;User&quot;, role: Role.USER });

adminService.deleteEverything(); // OK
userService.viewDashboard(); // OK

try {
  userService.deleteEverything(); // Lança erro
} catch (e: any) {
  console.error(e.message);
}
</code></pre>

</details>

<h3 id="checklist-do-dia_6">Checklist do Dia</h3>
<ul>
<li>[ ] Usei uma classe abstrata para definir um contrato.</li>
<li>[ ] Apliquei generics para tornar o sistema de autenticação flexível.</li>
<li>[ ] Criei um decorator para lidar com permissões de forma declarativa.</li>
<li>[ ] Combinei múltiplos conceitos da semana em um único projeto.</li>
</ul></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '../..';</script>
        <script src="../../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../../assets/js/mkdocs.js"></script>
			<script src="../../search/main.js" defer></script>

</body>

</html>