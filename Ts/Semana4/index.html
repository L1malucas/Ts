<!doctype html>
<html lang="en">

<head>
        <title>Semana 4 - Meus Estudos</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">Meus Estudos</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Início
                </a>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#requisitos-collapse" aria-expanded="false">
                    Requisitos
                </a>
                <div class="collapse" id="requisitos-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Requisitos/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#lógica-collapse" aria-expanded="false">
                    Lógica
                </a>
                <div class="collapse" id="lógica-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Logica/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Lógica de Programação
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#web-collapse" aria-expanded="false">
                    Web
                </a>
                <div class="collapse" id="web-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Web/Armazenamento/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Armazenamento Web
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class=" active 
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#typescript-collapse" aria-expanded="false">
                    TypeScript
                </a>
                <div class="collapse" id="typescript-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../estrutura-plano/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana1/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 1
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana2/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 2
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana3/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 3
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="./"
            class=" active 
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 4
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#mongo-collapse" aria-expanded="false">
                    Mongo
                </a>
                <div class="collapse" id="mongo-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Apostila
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/respostas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Respostas
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/tarefas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Tarefas
        </a>
    </li>
                    </ul>
                </div>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../Semana3/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a href="../../MongoDB/apostila/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><h1 id="semana-4-integracao-e-refinamento">Semana 4: Integração e Refinamento</h1>
<h2 id="visao-geral-da-semana">Visão Geral da Semana</h2>
<p>Na última semana, nosso foco é a aplicação prática e a integração do TypeScript em ecossistemas do mundo real. Vamos aprender a integrar com bibliotecas externas como o React Hook Form, gerenciar estado de forma segura, organizar nosso código com módulos e path mapping, e escrever testes que também validam nossos tipos. Finalizaremos com uma olhada em otimização de performance e padrões de design avançados, culminando em um projeto final que une todo o conhecimento adquirido.</p>
<hr />
<h2 id="dia-22-form-integration-react-hook-form">Dia 22: Form Integration (React Hook Form)</h2>
<h3 id="foco-do-dia">Foco do Dia</h3>
<p>Integrar TypeScript com bibliotecas externas, usando o React Hook Form como exemplo, e aprender a usar <code>Module Augmentation</code> para estender tipos de bibliotecas de terceiros.</p>
<h3 id="leitura-e-teoria-aprofundada">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Integração com Bibliotecas</strong>: Muitas bibliotecas populares (React, Vue, etc.) são escritas em TypeScript ou fornecem seus próprios arquivos de declaração de tipo (<code>.d.ts</code>). Isso nos permite usar a biblioteca de forma type-safe.</li>
<li><strong>Tipos Utilitários de Bibliotecas</strong>: Bibliotecas como React Hook Form exportam seus próprios tipos utilitários (ex: <code>Control</code>, <code>FieldErrors</code>, <code>UseFormSetValue</code>) que são genéricos e devem ser usados com os tipos do nosso formulário.</li>
<li><strong>Module Augmentation</strong>: Permite que você "adicione" declarações a um módulo existente. É útil para estender interfaces de bibliotecas de terceiros para adicionar propriedades customizadas sem precisar criar um fork da biblioteca.</li>
</ul>
<h3 id="documentacao-essencial">Documentação Essencial</h3>
<ul>
<li><a href="https://react.dev/learn/typescript">TypeScript com React (React Docs)</a></li>
<li><a href="https://react-hook-form.com/ts">TypeScript com React Hook Form (RHF Docs)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation">Module Augmentation (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo: Tipando um Formulário Simples com React Hook Form</strong></p>
<pre><code class="language-typescript">import { useForm, Control, FieldErrors, UseFormSetValue } from 'react-hook-form';

// 1. Definir o tipo dos valores do formulário
interface MyFormValues {
  firstName: string;
  age: number;
}

// 2. Usar o tipo com o hook `useForm`
function MyForm() {
  const { control, formState: { errors }, setValue } = useForm&lt;MyFormValues&gt;();

  // O tipo de `control` é Control&lt;MyFormValues&gt;
  // O tipo de `errors` é FieldErrors&lt;MyFormValues&gt;
  // O tipo de `setValue` é UseFormSetValue&lt;MyFormValues&gt;

  // ... resto do componente JSX
}
</code></pre>
<p><strong>Exemplo: Recriando seu tipo <code>RenderMinFareForm</code></strong></p>
<pre><code class="language-typescript">import { Control, FieldErrors, UseFormSetValue, UseFormClearErrors } from 'react-hook-form';

// O tipo que define os valores do seu formulário
interface MinFareFormValue {
  yield: number;
  price: number;
}

// O tipo que agrupa todos os props necessários para renderizar o form
export type RenderMinFareForm = {
  control: Control&lt;MinFareFormValue&gt;;
  errors: FieldErrors&lt;MinFareFormValue&gt;;
  setValue: UseFormSetValue&lt;MinFareFormValue&gt;;
  clearErrors: UseFormClearErrors&lt;MinFareFormValue&gt;;
};
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Defina um tipo para um formulário de login, <code>LoginFormValues</code>, que contém <code>email</code> (string) e <code>password</code> (string). Em seguida, crie um tipo <code>LoginProps</code> que represente as propriedades que um componente de formulário de login receberia, incluindo <code>onSubmit</code> que é uma função que recebe os <code>LoginFormValues</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface LoginFormValues {
  email: string;
  password: string;
}

type LoginProps = {
  onSubmit: (data: LoginFormValues) =&gt; void;
};

// Exemplo de uso em um componente (simulado)
function LoginForm(props: LoginProps) {
  // const { handleSubmit } = useForm&lt;LoginFormValues&gt;();
  // return &lt;form onSubmit={handleSubmit(props.onSubmit)}&gt;...&lt;/form&gt;
  console.log(&quot;Componente de formulário de login renderizado.&quot;);
}
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie um tipo <code>ProfileFormValues</code> com <code>name</code> (string) e <code>bio</code> (string, opcional). Crie um tipo <code>ProfileFormProps</code> que agrupa as propriedades <code>control</code> e <code>errors</code> do React Hook Form, devidamente tipadas com <code>ProfileFormValues</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">import { Control, FieldErrors } from 'react-hook-form';

interface ProfileFormValues {
  name: string;
  bio?: string;
}

type ProfileFormProps = {
  control: Control&lt;ProfileFormValues&gt;;
  errors: FieldErrors&lt;ProfileFormValues&gt;;
};

// Simulação de um componente que recebe esses props
function ProfileFormComponent(props: ProfileFormProps) {
  // &lt;Controller name=&quot;name&quot; control={props.control} ... /&gt;
  // {props.errors.name &amp;&amp; &lt;p&gt;Erro no nome&lt;/p&gt;}
  console.log(&quot;Componente de perfil renderizado.&quot;);
}
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Usando <code>Module Augmentation</code>, estenda a interface <code>DefaultTheme</code> de uma biblioteca de estilização (ex: <code>styled-components</code>). Adicione uma propriedade <code>customColors</code> que é um objeto com chaves <code>primary</code> e <code>secondary</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Em um arquivo, ex: styled.d.ts

// 1. Importe o tipo original da biblioteca
import 'styled-components';

// 2. Declare o módulo novamente para estendê-lo
declare module 'styled-components' {
  // 3. Estenda a interface DefaultTheme
  export interface DefaultTheme {
    customColors: {
      primary: string;
      secondary: string;
      background: string;
    };
  }
}

// Em outro arquivo, ex: theme.ts
import { DefaultTheme } from 'styled-components';

const myTheme: DefaultTheme = {
  // Agora o TS espera a propriedade customColors
  customColors: {
    primary: '#007bff',
    secondary: '#6c757d',
    background: '#f8f9fa',
  },
};
</code></pre>

</details>

<h3 id="checklist-do-dia">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi como usar tipos genéricos de bibliotecas externas.</li>
<li>[ ] Criei um tipo para os valores de um formulário.</li>
<li>[ ] Agrupei os props de um formulário em um único tipo.</li>
<li>[ ] Usei <code>Module Augmentation</code> para estender uma interface de biblioteca.</li>
</ul>
<hr />
<h2 id="dia-23-state-management-type-safe">Dia 23: State Management Type-Safe</h2>
<h3 id="foco-do-dia_1">Foco do Dia</h3>
<p>Projetar um sistema de gerenciamento de estado (como Redux ou Zustand) de forma totalmente type-safe, com foco em <code>action creators</code> e <code>selectors</code> tipados.</p>
<h3 id="leitura-e-teoria-aprofundada_1">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Store</strong>: Um objeto único que contém todo o estado da aplicação.</li>
<li><strong>Actions</strong>: Objetos que descrevem uma intenção de mudar o estado. Geralmente têm uma propriedade <code>type</code> (uma string literal) e um <code>payload</code> opcional.</li>
<li><strong>Reducers</strong>: Funções puras que recebem o estado atual e uma ação, e retornam o novo estado. <code>(currentState, action) =&gt; newState</code>.</li>
<li><strong>Action Creators</strong>: Funções que criam e retornam objetos de ação. Ajuda a evitar erros de digitação no <code>type</code> da ação.</li>
<li><strong>Selectors</strong>: Funções que extraem e computam dados derivados do estado do store. Memoização (como na biblioteca <code>reselect</code>) é frequentemente usada para performance.</li>
</ul>
<h3 id="documentacao-essencial_1">Documentação Essencial</h3>
<ul>
<li><a href="https://redux.js.org/usage/usage-with-typescript">Static Typing com Redux (Redux Docs)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_1">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo: Tipando Ações e Reducer do Redux</strong></p>
<pre><code class="language-typescript">// 1. Definir o tipo do estado
interface CounterState {
  value: number;
}

// 2. Definir os tipos das ações
const INCREMENT = 'counter/increment';
const ADD = 'counter/add';

interface IncrementAction { type: typeof INCREMENT; }
interface AddAction { type: typeof ADD; payload: number; }

type CounterAction = IncrementAction | AddAction;

// 3. Criar o reducer
const initialState: CounterState = { value: 0 };

function counterReducer(state = initialState, action: CounterAction): CounterState {
  switch (action.type) {
    case INCREMENT:
      return { ...state, value: state.value + 1 };
    case ADD:
      // O TS sabe que `action` tem `payload` aqui
      return { ...state, value: state.value + action.payload };
    default:
      return state;
  }
}
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_1">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie os <code>action creators</code> para as ações <code>IncrementAction</code> e <code>AddAction</code> do exemplo guiado. As funções devem retornar os objetos de ação devidamente tipados.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Tipos do exemplo anterior...
const INCREMENT = 'counter/increment';
const ADD = 'counter/add';
interface IncrementAction { type: typeof INCREMENT; }
interface AddAction { type: typeof ADD; payload: number; }

// Action Creators
function increment(): IncrementAction {
  return { type: INCREMENT };
}

function add(amount: number): AddAction {
  return { type: ADD, payload: amount };
}

// Teste
const incrementAction = increment(); // tipo IncrementAction
const addAction = add(5); // tipo AddAction

console.log(incrementAction);
console.log(addAction);
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Defina um estado para uma lista de tarefas (<code>todos</code>). Crie os tipos de ação e o reducer para adicionar uma nova tarefa (<code>ADD_TODO</code>) e marcar uma tarefa como completa (<code>TOGGLE_TODO</code>).</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// 1. Tipos de Estado
interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

interface TodosState {
  todos: Todo[];
}

// 2. Tipos de Ação
const ADD_TODO = 'todos/add';
const TOGGLE_TODO = 'todos/toggle';

interface AddTodoAction { type: typeof ADD_TODO; payload: { text: string } }
interface ToggleTodoAction { type: typeof TOGGLE_TODO; payload: { id: number } }

type TodoAction = AddTodoAction | ToggleTodoAction;

// 3. Reducer
const initialTodosState: TodosState = { todos: [] };
let nextTodoId = 0;

function todosReducer(state = initialTodosState, action: TodoAction): TodosState {
  switch (action.type) {
    case ADD_TODO:
      return {
        ...state,
        todos: [...state.todos, { id: nextTodoId++, text: action.payload.text, completed: false }]
      };
    case TOGGLE_TODO:
      return {
        ...state,
        todos: state.todos.map(todo =&gt;
          todo.id === action.payload.id ? { ...todo, completed: !todo.completed } : todo
        )
      };
    default:
      return state;
  }
}
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um seletor tipado <code>selectCompletedTodos</code> que recebe o estado completo da aplicação (que contém <code>todosState</code>) e retorna apenas a lista de tarefas completas.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Reutilizando os tipos do Nível 2
interface Todo { id: number; text: string; completed: boolean; }
interface TodosState { todos: Todo[]; }

// Estado global da aplicação
interface AppState {
  todosState: TodosState;
  // ... outros estados
}

// O seletor
function selectCompletedTodos(state: AppState): Todo[] {
  return state.todosState.todos.filter(todo =&gt; todo.completed);
}

// Teste
const testState: AppState = {
  todosState: {
    todos: [
      { id: 0, text: 'Aprender TS', completed: true },
      { id: 1, text: 'Dominar o mundo', completed: false },
      { id: 2, text: 'Tomar café', completed: true },
    ]
  }
};

const completed = selectCompletedTodos(testState);
console.log(completed);
</code></pre>

</details>

<h3 id="checklist-do-dia_1">Checklist do Dia</h3>
<ul>
<li>[ ] Defini o tipo para uma fatia (slice) do estado.</li>
<li>[ ] Criei tipos de ação usando discriminated unions.</li>
<li>[ ] Implementei um reducer type-safe.</li>
<li>[ ] Criei action creators e seletores tipados.</li>
</ul>
<hr />
<h2 id="dia-24-module-system-e-path-mapping">Dia 24: Module System e Path Mapping</h2>
<h3 id="foco-do-dia_2">Foco do Dia</h3>
<p>Organizar a arquitetura de código usando o sistema de módulos do TypeScript, incluindo <code>barrel exports</code> e <code>path mapping</code> para imports mais limpos.</p>
<h3 id="leitura-e-teoria-aprofundada_2">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Módulos</strong>: Cada arquivo em TypeScript é um módulo. <code>export</code> torna variáveis, funções e classes disponíveis para outros módulos. <code>import</code> as consome.</li>
<li><strong>Barrel Exports</strong>: Um arquivo, geralmente chamado <code>index.ts</code>, que re-exporta todos os exports de um diretório. Isso permite que os consumidores importem tudo de um único local, em vez de múltiplos caminhos.
  <code>import { ServiceA, ServiceB } from './services';</code> em vez de <code>... from './services/ServiceA'</code> e <code>... from './services/ServiceB'</code>.</li>
<li><strong>Path Mapping</strong>: Uma feature do <code>tsconfig.json</code> que permite criar aliases para caminhos de importação. Isso evita imports relativos longos como <code>../../../../components</code> e os substitui por aliases como <code>@components</code>.</li>
</ul>
<h3 id="documentacao-essencial_2">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/modules.html">Modules (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/tsconfig#paths">Path mapping (tsconfig Reference)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_2">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Barrel Exports</strong></p>
<pre><code class="language-typescript">// Em src/utils/stringUtils.ts
export const capitalize = (s: string) =&gt; s.charAt(0).toUpperCase() + s.slice(1);

// Em src/utils/numberUtils.ts
export const isEven = (n: number) =&gt; n % 2 === 0;

// Em src/utils/index.ts (o &quot;barrel&quot;)
export * from './stringUtils';
export * from './numberUtils';

// Em outro arquivo
import { capitalize, isEven } from '../utils'; // Importa de um único lugar
</code></pre>
<p><strong>Exemplo 2: Configurando Path Mapping</strong>
No <code>tsconfig.json</code>:</p>
<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;./src&quot;, // Essencial para o path mapping
    &quot;paths&quot;: {
      &quot;@components/*&quot;: [&quot;components/*&quot;],
      &quot;@services/*&quot;: [&quot;services/*&quot;],
      &quot;@domain/*&quot;: [&quot;domain/*&quot;]
    }
  }
}
</code></pre>
<p>Uso no código:</p>
<pre><code class="language-typescript">// Em vez de: import { User } from '../../domain/models/User';
import { User } from '@domain/models/User';

// Em vez de: import { Button } from '../components/Button';
import { Button } from '@components/Button';
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_2">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma estrutura de pastas <code>domain/errors</code>. Dentro, crie dois arquivos: <code>UnexpectedError.ts</code> e <code>NotFoundError.ts</code>, cada um exportando uma classe de erro. Crie um arquivo <code>index.ts</code> em <code>domain/errors</code> que exporta ambas as classes.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Em domain/errors/UnexpectedError.ts
export class UnexpectedError extends Error {
  constructor() {
    super('Um erro inesperado aconteceu.');
    this.name = 'UnexpectedError';
  }
}

// Em domain/errors/NotFoundError.ts
export class NotFoundError extends Error {
  constructor() {
    super('Recurso não encontrado.');
    this.name = 'NotFoundError';
  }
}

// Em domain/errors/index.ts
export * from './UnexpectedError';
export * from './NotFoundError';

// Em outro arquivo (ex: app.ts)
// import { UnexpectedError, NotFoundError } from './domain/errors';
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Configure o <code>path mapping</code> no seu <code>tsconfig.json</code> para criar um alias <code>@/</code> que aponte para o diretório <code>src/</code>. Refatore um import que usa um caminho relativo (ex: <code>../utils</code>) para usar o novo alias (<code>@/utils</code>).</p>
<details>
<summary>Ver Solução</summary>

No `tsconfig.json`:

<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;, // ou &quot;./src&quot;
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;src/*&quot;]
    }
  }
}
</code></pre>


No código:

<pre><code class="language-typescript">// Antes:
// import { capitalize } from '../../utils/stringUtils';

// Depois:
// import { capitalize } from '@/utils/stringUtils';
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie uma estrutura de módulos para a sua camada de dados, como no seu exemplo. Crie <code>data/protocols/http/</code> com um <code>index.ts</code> e um <code>http-client.ts</code>. O <code>http-client.ts</code> deve exportar um <code>HttpStatusCode</code> (enum) e uma interface <code>HttpClient</code>. O <code>index.ts</code> deve exportar tudo de <code>http-client.ts</code>. Configure um alias <code>@data</code> para a pasta <code>data</code>.</p>
<details>
<summary>Ver Solução</summary>

No `tsconfig.json`:

<pre><code class="language-json">{
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;./src&quot;,
    &quot;paths&quot;: {
      &quot;@data/*&quot;: [&quot;data/*&quot;]
    }
  }
}
</code></pre>


Estrutura de arquivos:

<pre><code>src/
  data/
    protocols/
      http/
        http-client.ts
        index.ts
</code></pre>


Em `src/data/protocols/http/http-client.ts`:

<pre><code class="language-typescript">export enum HttpStatusCode {
  ok = 200,
  noContent = 204,
  badRequest = 400,
  notFound = 404,
  serverError = 500,
}

export interface HttpClient&lt;R = any&gt; {
  request: (data: HttpRequest) =&gt; Promise&lt;HttpResponse&lt;R&gt;&gt;;
}

export type HttpRequest = { url: string; method: string; body?: any; headers?: any; };
export type HttpResponse&lt;R = any&gt; = { statusCode: HttpStatusCode; body?: R; };
</code></pre>


Em `src/data/protocols/http/index.ts`:

<pre><code class="language-typescript">export * from './http-client';
</code></pre>


Em outro arquivo:

<pre><code class="language-typescript">import { HttpStatusCode, HttpClient } from '@data/protocols/http';
</code></pre>

</details>

<h3 id="checklist-do-dia_2">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi a diferença entre <code>export</code> e <code>export default</code>.</li>
<li>[ ] Criei um barrel export (<code>index.ts</code>) para simplificar imports.</li>
<li>[ ] Configurei <code>baseUrl</code> e <code>paths</code> no <code>tsconfig.json</code>.</li>
<li>[ ] Refatorei imports relativos para usar aliases de caminho.</li>
</ul>
<hr />
<h2 id="dia-25-testing-types">Dia 25: Testing Types</h2>
<h3 id="foco-do-dia_3">Foco do Dia</h3>
<p>Escrever testes que não apenas validam a lógica de execução, mas também a correção dos tipos, usando mocks type-safe e testes de asserção de tipo.</p>
<h3 id="leitura-e-teoria-aprofundada_3">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Mocks Type-Safe</strong>: Ao mockar (simular) módulos ou classes, é crucial que o mock tenha o mesmo tipo do original. Ferramentas como <code>jest.Mocked&lt;T&gt;</code> ajudam a garantir isso.</li>
<li><strong>Testando Tipos</strong>: Às vezes, queremos testar apenas o tipo, não o valor. Por exemplo, garantir que uma função não pode ser chamada com argumentos errados. Isso geralmente é feito em arquivos <code>.test-d.ts</code> (testes de declaração) com ferramentas como <code>tsd</code> ou <code>expect-type</code>.</li>
<li><strong>Mock Factories</strong>: Criar funções que geram mocks consistentes e tipados para os seus testes. Isso reduz a duplicação de código nos testes.</li>
</ul>
<h3 id="documentacao-essencial_3">Documentação Essencial</h3>
<ul>
<li><a href="https://jestjs.io/docs/getting-started#using-typescript">TypeScript com Jest</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_3">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo: Mockando um Serviço com Tipagem</strong></p>
<pre><code class="language-typescript">// Em user.service.ts
export class UserService {
  async getUserName(id: string): Promise&lt;string&gt; {
    // ... lógica real
    return &quot;Nome Real&quot;;
  }
}

// Em user.controller.test.ts
import { UserService } from './user.service';
import { jest } from '@jest/globals';

// Mocka o módulo inteiro
jest.mock('./user.service');

// Cria uma versão tipada da classe mockada
const MockedUserService = UserService as jest.MockedClass&lt;typeof UserService&gt;;

// Teste
it('should return user name', async () =&gt; {
  // O TS sabe que `mock.instances[0].getUserName` existe e é um mock
  MockedUserService.prototype.getUserName.mockResolvedValue(&quot;Nome Mockado&quot;);

  const serviceInstance = new UserService();
  const name = await serviceInstance.getUserName('1');
  expect(name).toBe(&quot;Nome Mockado&quot;);
});
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_3">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma interface <code>INotifier</code> com um método <code>notify(message: string)</code>. Crie um mock simples para esta interface em um teste, garantindo que o mock satisfaça a interface.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Interface original
interface INotifier {
  notify(message: string): void;
}

// Teste
describe('Notifier Test', () =&gt; {
  it('should be called with the correct message', () =&gt; {
    // O mock é tipado como a interface
    const mockNotifier: INotifier = {
      notify: jest.fn(), // jest.fn() cria uma função mock
    };

    // Simula o uso do notifier
    mockNotifier.notify(&quot;hello&quot;);

    expect(mockNotifier.notify).toHaveBeenCalledWith(&quot;hello&quot;);
  });
});
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma "mock factory" para um objeto <code>User</code>. A factory deve ser uma função <code>createMockUser(overrides: Partial&lt;User&gt;): User</code> que cria um usuário padrão e permite sobrescrever propriedades específicas para cada teste.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface User {
  id: string;
  name: string;
  email: string;
  isAdmin: boolean;
}

function createMockUser(overrides?: Partial&lt;User&gt;): User {
  const defaultUser: User = {
    id: 'user-1',
    name: 'Usuário Padrão',
    email: 'default@test.com',
    isAdmin: false,
  };

  return { ...defaultUser, ...overrides };
}

// Teste
describe('Mock User Factory', () =&gt; {
  it('should create a default user', () =&gt; {
    const user = createMockUser();
    expect(user.name).toBe('Usuário Padrão');
  });

  it('should override properties', () =&gt; {
    const adminUser = createMockUser({ name: 'Admin', isAdmin: true });
    expect(adminUser.name).toBe('Admin');
    expect(adminUser.isAdmin).toBe(true);
  });
});
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Usando uma ferramenta como <code>expect-type</code> (ou apenas com comentários, se não estiver configurada), escreva um teste de tipo para garantir que uma função <code>add(a: number, b: number)</code> não pode ser chamada com strings.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">import { expectTypeOf } from 'expect-type';

function add(a: number, b: number): number {
  return a + b;
}

// Teste de tipo
test('type tests for add function', () =&gt; {
  // Verifica se a função aceita números
  expectTypeOf(add).toBeCallableWith(1, 2);

  // Verifica se a função NÃO aceita strings
  expectTypeOf(add).not.toBeCallableWith('1', '2');

  // Verifica o tipo de retorno
  expectTypeOf(add).returns.toBeNumber();
});
</code></pre>


**Solução sem biblioteca (usando comentários de erro esperado):**

<pre><code class="language-typescript">function add(a: number, b: number): number {
  return a + b;
}

// @ts-expect-error - Testando que isso deve dar um erro de tipo
add('1', '2');

const result = add(1, 2);
// @ts-expect-error - Testando que o resultado não é uma string
const resultIsString: string = result;
</code></pre>

</details>

<h3 id="checklist-do-dia_3">Checklist do Dia</h3>
<ul>
<li>[ ] Criei um mock tipado para uma interface.</li>
<li>[ ] Usei <code>jest.MockedClass</code> para mockar uma classe.</li>
<li>[ ] Criei uma factory para gerar mocks consistentes.</li>
<li>[ ] Entendi como testar a correção de tipos, não apenas de valores.</li>
</ul>
<hr />
<h2 id="dia-26-performance-e-optimization">Dia 26: Performance e Optimization</h2>
<h3 id="foco-do-dia_4">Foco do Dia</h3>
<p>Entender como tipos complexos podem impactar a performance do compilador TypeScript e aprender técnicas para otimizá-los.</p>
<h3 id="leitura-e-teoria-aprofundada_4">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Custo da Tipagem</strong>: Tipos muito complexos, especialmente os recursivos ou que geram uniões muito grandes, podem deixar o <code>tsc</code> (compilador do TypeScript) e o IntelliSense lentos.</li>
<li><strong>Análise de Performance</strong>: O compilador do TypeScript tem flags para ajudar a diagnosticar problemas de performance, como <code>--diagnostics</code> e <code>--generateTrace</code>.</li>
<li><strong>Técnicas de Otimização</strong>:</li>
<li><strong>Evitar Recursão Infinita</strong>: Cuidado com tipos recursivos que não têm um caso base claro.</li>
<li><strong>Interfaces vs. Types</strong>: Interfaces são geralmente melhores para objetos, pois são extensíveis e podem ser ligeiramente mais performáticas em alguns casos devido à forma como são cacheadas internamente.</li>
<li><strong>Simplificar Tipos Condicionais</strong>: Tente quebrar tipos condicionais complexos em tipos auxiliares menores.</li>
<li><strong>Adiar Computação de Tipos</strong>: Em vez de um tipo que calcula tudo de uma vez, use um tipo genérico que é resolvido apenas quando usado.</li>
</ul>
<h3 id="documentacao-essencial_4">Documentação Essencial</h3>
<ul>
<li><a href="https://github.com/microsoft/TypeScript/wiki/Performance">TypeScript Performance Wiki</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_4">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo: Tipo Recursivo que Pode Ser Lento</strong></p>
<pre><code class="language-typescript">// Este tipo pode ser lento se a profundidade for grande
type DeeplyNested&lt;T&gt; = { content: T; next?: DeeplyNested&lt;T&gt; };

// Uma alternativa pode ser limitar a profundidade, se possível
type LimitedDepth&lt;T, D extends number&gt; = D extends 0 ? T : { content: T; next?: LimitedDepth&lt;T, any /* D-1 */&gt; };
// (A matemática de tipos para subtrair 1 é complexa, mas a ideia é limitar a recursão)
</code></pre>
<p><strong>Exemplo: Simplificando Uniões Grandes</strong></p>
<pre><code class="language-typescript">// Lento: Gera uma união de 1000 tipos literais
type Thousand = 1 | 2 | 3 | ... | 1000;

// Mais performático: Usa um tipo mais geral e valida em tempo de execução
type SmallNumber = number &amp; { __brand: 'SmallNumber' };
function createSmallNumber(n: number): SmallNumber | null {
  if (n &gt; 0 &amp;&amp; n &lt;= 1000) return n as SmallNumber;
  return null;
}
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_4">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Refatore um tipo que usa <code>type</code> para um objeto para usar <code>interface</code>. Explique por que <code>interface</code> pode ser preferível para objetos que podem ser estendidos.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Antes
type UserType = {
  id: number;
  name: string;
};

// Depois (Refatorado)
interface UserInterface {
  id: number;
  name: string;
}

// Interfaces podem ser estendidas por outras interfaces e aumentadas (module augmentation).
// Isso as torna mais flexíveis para objetos, especialmente em APIs públicas.
interface AdminUser extends UserInterface {
  permissions: string[];
}
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Dado um tipo <code>ComplexMappedType</code> que faz várias operações, quebre-o em tipos utilitários menores e mais legíveis.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface Props {
  name: string;
  age: number;
  onNameChange: (name: string) =&gt; void;
  onAgeChange: (age: number) =&gt; void;
}

// Antes: Um tipo monolítico
type CallbacksOnlyBefore&lt;T&gt; = {
  [K in keyof T as T[K] extends (...args: any[]) =&gt; any ? K : never]: T[K]
};

// Depois: Refatorado em tipos menores
// 1. Pega as chaves cujos valores são funções
type FunctionKeys&lt;T&gt; = {
  [K in keyof T]: T[K] extends (...args: any[]) =&gt; any ? K : never
}[keyof T];

// 2. Usa Pick para criar o tipo final
type CallbacksOnlyAfter&lt;T&gt; = Pick&lt;T, FunctionKeys&lt;T&gt;&gt;;

// Teste
type PropCallbacks = CallbacksOnlyAfter&lt;Props&gt;;
// { onNameChange: (name: string) =&gt; void; onAgeChange: (age: number) =&gt; void; }
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um tipo <code>Path&lt;T&gt;</code> que gera todas as chaves de um objeto aninhado como uma string com pontos (ex: <code>'details.address.city'</code>). Este é um tipo inerentemente recursivo e pesado. Pense em como você poderia otimizá-lo ou quais seriam seus gargalos de performance.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Este tipo é conhecido por ser pesado e pode causar lentidão no compilador
// com objetos muito grandes ou profundos.

type Path&lt;T, K extends keyof T = keyof T&gt; = 
  K extends string 
    ? T[K] extends Record&lt;string, any&gt; 
      ? `${K}.${Path&lt;T[K]&gt;}` | K
      : K
    : never;

// Teste
interface UserProfile {
  id: number;
  details: {
    name: string;
    address: {
      street: string;
      city: string;
    }
  }
}

type UserProfilePaths = Path&lt;UserProfile&gt;;
// &quot;id&quot; | &quot;details&quot; | &quot;details.name&quot; | &quot;details.address&quot; | &quot;details.address.street&quot; | &quot;details.address.city&quot;

/*
Otimização/Gargalos:
1. Profundidade da Recursão: A principal causa de lentidão. Uma otimização seria adicionar um parâmetro de profundidade para limitar a recursão.
2. Largura do Objeto: Muitos campos em cada nível aumentam o número de uniões geradas.
3. Tipos Condicionais: Cada verificação `T[K] extends Record&lt;string, any&gt;` adiciona custo computacional.
Uma otimização real em um projeto seria talvez não usar este tipo e preferir uma validação em tempo de execução para caminhos de objetos.
*/
</code></pre>

</details>

<h3 id="checklist-do-dia_4">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi que tipos complexos podem impactar a performance.</li>
<li>[ ] Sei a diferença entre <code>interface</code> e <code>type</code> e quando usar cada um.</li>
<li>[ ] Refatorei um tipo complexo em tipos auxiliares menores.</li>
<li>[ ] Analisei um tipo recursivo e identifiquei seus possíveis gargalos.</li>
</ul>
<hr />
<h2 id="dia-27-advanced-patterns">Dia 27: Advanced Patterns</h2>
<h3 id="foco-do-dia_5">Foco do Dia</h3>
<p>Implementar padrões de design de software clássicos (Design Patterns) em TypeScript, aproveitando o sistema de tipos para torná-los mais seguros e expressivos.</p>
<h3 id="leitura-e-teoria-aprofundada_5">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li><strong>Builder Pattern</strong>: Usado para construir objetos complexos passo a passo. Permite produzir diferentes tipos e representações de um objeto usando o mesmo processo de construção. Ideal para objetos com muitos parâmetros de configuração.</li>
<li><strong>Factory Pattern</strong>: Usado para criar objetos sem expor a lógica de criação ao cliente. Uma função ou método "fábrica" decide qual classe concreta instanciar com base em algum parâmetro.</li>
<li><strong>Observer Pattern</strong>: Usado para criar uma relação de um-para-muitos entre objetos. Quando um objeto (o <code>subject</code>) muda de estado, todos os seus dependentes (os <code>observers</code>) são notificados e atualizados automaticamente.</li>
</ul>
<h3 id="documentacao-essencial_5">Documentação Essencial</h3>
<ul>
<li><a href="https://refactoring.guru/design-patterns">Design Patterns (Refactoring Guru)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_5">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo: Observer Pattern</strong></p>
<pre><code class="language-typescript">// A interface para os observadores
interface Observer&lt;T&gt; { update(data: T): void; }

// O sujeito que os observadores observam
class Subject&lt;T&gt; {
  private observers = new Set&lt;Observer&lt;T&gt;&gt;();

  subscribe(observer: Observer&lt;T&gt;) { this.observers.add(observer); }
  unsubscribe(observer: Observer&lt;T&gt;) { this.observers.delete(observer); }

  notify(data: T) {
    this.observers.forEach(observer =&gt; observer.update(data));
  }
}

// Exemplo de uso
const newsFeed = new Subject&lt;string&gt;();
const observerA = { update: (data: string) =&gt; console.log(`Observer A: ${data}`) };
const observerB = { update: (data: string) =&gt; console.log(`Observer B: ${data}`) };

newsFeed.subscribe(observerA);
newsFeed.subscribe(observerB);

newsFeed.notify(&quot;Nova notícia importante!&quot;);
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_5">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Implemente uma <code>SimpleFactory</code> para criar objetos <code>Logger</code>. A factory deve ter um método <code>createLogger(type: 'console' | 'file')</code> que retorna uma instância de <code>ConsoleLogger</code> ou <code>FileLogger</code>, ambas implementando uma interface <code>ILogger</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface ILogger { log(message: string): void; }

class ConsoleLogger implements ILogger {
  log(message: string) { console.log(message); }
}

class FileLogger implements ILogger {
  log(message: string) { console.log(`File: ${message}`); }
}

class LoggerFactory {
  public createLogger(type: 'console' | 'file'): ILogger {
    if (type === 'file') {
      return new FileLogger();
    }
    return new ConsoleLogger();
  }
}

// Teste
const factory = new LoggerFactory();
const consoleLogger = factory.createLogger('console');
const fileLogger = factory.createLogger('file');

consoleLogger.log(&quot;Teste console&quot;);
fileLogger.log(&quot;Teste arquivo&quot;);
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Implemente o <strong>Builder Pattern</strong> para criar um objeto <code>Pizza</code>. A classe <code>PizzaBuilder</code> deve ter métodos como <code>setCheese(cheese: string)</code>, <code>addTopping(topping: string)</code>, e um método <code>build()</code> que retorna o objeto <code>Pizza</code> final.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class Pizza {
  public cheese?: string;
  public toppings: string[] = [];

  describe(): void {
    console.log(`Pizza com queijo ${this.cheese} e coberturas: ${this.toppings.join(', ')}`);
  }
}

class PizzaBuilder {
  private pizza: Pizza;

  constructor() {
    this.pizza = new Pizza();
  }

  setCheese(cheese: string): this {
    this.pizza.cheese = cheese;
    return this;
  }

  addTopping(topping: string): this {
    this.pizza.toppings.push(topping);
    return this;
  }

  build(): Pizza {
    return this.pizza;
  }
}

// Teste
const myPizza = new PizzaBuilder()
  .setCheese('mussarela')
  .addTopping('calabresa')
  .addTopping('cebola')
  .build();

myPizza.describe();
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um sistema de eventos type-safe usando o Observer Pattern. Crie uma classe <code>EventManager</code> que permite se inscrever (<code>on</code>) e emitir (<code>emit</code>) eventos. O sistema deve ser tipado de forma que, ao emitir um evento, o payload seja do tipo correto esperado pelos listeners daquele evento.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Mapeia nomes de eventos para os tipos de seus payloads
interface EventMap {
  'user:created': { userId: string; name: string; };
  'user:deleted': { userId: string; };
  'product:viewed': { productId: string; };
}

type EventKey = keyof EventMap;

class EventManager {
  private listeners: { [K in EventKey]?: ((payload: EventMap[K]) =&gt; void)[] } = {};

  // Se inscreve em um evento
  public on&lt;K extends EventKey&gt;(eventName: K, listener: (payload: EventMap[K]) =&gt; void): void {
    if (!this.listeners[eventName]) {
      this.listeners[eventName] = [];
    }
    this.listeners[eventName]?.push(listener);
  }

  // Emite um evento
  public emit&lt;K extends EventKey&gt;(eventName: K, payload: EventMap[K]): void {
    this.listeners[eventName]?.forEach(listener =&gt; listener(payload));
  }
}

// Teste
const events = new EventManager();

events.on('user:created', (payload) =&gt; {
  // O tipo de `payload` é { userId: string; name: string; }
  console.log(`Novo usuário criado: ${payload.name} (ID: ${payload.userId})`);
});

events.on('user:deleted', (payload) =&gt; {
  // O tipo de `payload` é { userId: string; }
  console.log(`Usuário deletado: ${payload.userId}`);
});

events.emit('user:created', { userId: 'u-123', name: 'Lucas' });
events.emit('user:deleted', { userId: 'u-456' });

// events.emit('user:created', { userId: 'u-789' }); // Erro: a propriedade 'name' está faltando.
</code></pre>

</details>

<h3 id="checklist-do-dia_5">Checklist do Dia</h3>
<ul>
<li>[ ] Implementei o Factory Pattern para criar objetos.</li>
<li>[ ] Implementei o Builder Pattern para construir um objeto complexo.</li>
<li>[ ] Implementei o Observer Pattern para notificação de eventos.</li>
<li>[ ] Usei os recursos de tipo do TypeScript para tornar os padrões mais seguros.</li>
</ul>
<hr />
<h2 id="dias-28-30-projeto-final">Dias 28-30: Projeto Final</h2>
<h3 id="foco-do-projeto">Foco do Projeto</h3>
<p>Consolidar todo o conhecimento adquirido ao longo das 4 semanas para planejar, implementar e refinar uma pequena aplicação ou um componente de sistema complexo. O objetivo é aplicar os padrões e técnicas aprendidas em um contexto coeso.</p>
<h3 id="ideia-do-projeto-um-mini-framework-de-formularios-type-safe">Ideia do Projeto: Um Mini-Framework de Formulários Type-Safe</h3>
<p>Vamos construir um pequeno framework para gerenciar o estado de formulários, inspirado em bibliotecas como Formik ou React Hook Form, mas muito mais simples. Ele irá demonstrar o uso de classes, generics, mapped types, e mais.</p>
<h3 id="dia-28-planejamento-e-estrutura">Dia 28: Planejamento e Estrutura</h3>
<p><strong>Exercício:</strong> Defina os tipos e a classe principal.
1.  Crie uma classe <code>FormStore&lt;T extends object&gt;</code> que será o coração do nosso framework.
2.  No construtor, ela deve receber um <code>initialValues: T</code>.
3.  Ela deve ter propriedades para armazenar os valores (<code>values: T</code>), os erros (<code>errors: FormErrors&lt;T&gt;</code>) e o estado de "tocado" (<code>touched: FormTouched&lt;T&gt;</code>).
4.  Defina os tipos utilitários <code>FormErrors&lt;T&gt;</code> e <code>FormTouched&lt;T&gt;</code> usando Mapped Types. <code>FormErrors</code> deve ter as mesmas chaves de <code>T</code>, mas com valores <code>string | undefined</code>. <code>FormTouched</code> deve ter valores <code>boolean | undefined</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Tipos utilitários
type FormErrors&lt;T&gt; = {
  [P in keyof T]?: string;
};

type FormTouched&lt;T&gt; = {
  [P in keyof T]?: boolean;
};

class FormStore&lt;T extends object&gt; {
  public values: T;
  public errors: FormErrors&lt;T&gt; = {};
  public touched: FormTouched&lt;T&gt; = {};

  constructor(initialValues: T) {
    this.values = initialValues;
  }

  public getState() {
    return {
      values: this.values,
      errors: this.errors,
      touched: this.touched,
    };
  }
}

// Teste da estrutura
const form = new FormStore({ name: '', email: '' });
console.log(form.getState());
</code></pre>

</details>

<h3 id="dia-29-implementacao-dos-metodos">Dia 29: Implementação dos Métodos</h3>
<p><strong>Exercício:</strong> Adicione os métodos para interagir com o formulário.
1.  Adicione um método <code>setFieldValue&lt;K extends keyof T&gt;(field: K, value: T[K]): void</code> que atualiza um valor no <code>values</code>.
2.  Adicione um método <code>setFieldTouched&lt;K extends keyof T&gt;(field: K, isTouched: boolean): void</code>.
3.  Adicione um método <code>setErrors(errors: FormErrors&lt;T&gt;): void</code> que substitui o objeto de erros.
4.  Adicione um método de validação <code>validate(validationSchema: ValidationSchema&lt;T&gt;): boolean</code>. O <code>validationSchema</code> deve ser um objeto onde cada chave de <code>T</code> tem uma função que recebe o valor do campo e retorna uma <code>string</code> de erro ou <code>undefined</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Tipos do dia anterior...
type FormErrors&lt;T&gt; = { [P in keyof T]?: string; };
type FormTouched&lt;T&gt; = { [P in keyof T]?: boolean; };

// Novo tipo para o esquema de validação
type ValidationSchema&lt;T&gt; = {
  [K in keyof T]?: (value: T[K]) =&gt; string | undefined;
};

class FormStore&lt;T extends object&gt; {
  public values: T;
  public errors: FormErrors&lt;T&gt; = {};
  public touched: FormTouched&lt;T&gt; = {};

  constructor(initialValues: T) { this.values = initialValues; }

  public setFieldValue&lt;K extends keyof T&gt;(field: K, value: T[K]): void {
    this.values[field] = value;
  }

  public setFieldTouched&lt;K extends keyof T&gt;(field: K, isTouched: boolean = true): void {
    this.touched[field] = isTouched;
  }

  public setErrors(errors: FormErrors&lt;T&gt;): void {
    this.errors = errors;
  }

  public validate(validationSchema: ValidationSchema&lt;T&gt;): boolean {
    const newErrors: FormErrors&lt;T&gt; = {};
    let isValid = true;

    for (const key in validationSchema) {
      const validator = validationSchema[key];
      if (validator) {
        const error = validator(this.values[key]);
        if (error) {
          newErrors[key] = error;
          isValid = false;
        }
      }
    }
    this.setErrors(newErrors);
    return isValid;
  }
}
</code></pre>

</details>

<h3 id="dia-30-refinamento-e-uso">Dia 30: Refinamento e Uso</h3>
<p><strong>Exercício:</strong> Use o <code>FormStore</code> para gerenciar um formulário de registro de usuário.
1.  Defina a interface <code>UserSignupForm</code> com <code>name</code>, <code>email</code>, e <code>password</code>.
2.  Crie uma instância do <code>FormStore</code> com os valores iniciais.
3.  Crie um <code>ValidationSchema</code> para o formulário (ex: nome é obrigatório, email deve conter <code>@</code>, senha deve ter mais de 6 caracteres).
4.  Simule a interação do usuário: mude valores, toque em campos e chame a validação. Imprima o estado (<code>values</code>, <code>errors</code>, <code>touched</code>) no console a cada passo.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// Classe e tipos do dia anterior...

// 1. Definir a interface do formulário
interface UserSignupForm {
  name: string;
  email: string;
  password: string;
}

// 2. Criar a instância do FormStore
const signupForm = new FormStore&lt;UserSignupForm&gt;({
  name: '',
  email: '',
  password: '',
});

// 3. Criar o esquema de validação
const signupValidationSchema: ValidationSchema&lt;UserSignupForm&gt; = {
  name: (value) =&gt; (value ? undefined : 'Nome é obrigatório'),
  email: (value) =&gt; (value.includes('@') ? undefined : 'Email inválido'),
  password: (value) =&gt; (value.length &gt; 6 ? undefined : 'Senha muito curta'),
};

// 4. Simular a interação
console.log(&quot;Estado Inicial:&quot;, signupForm.errors);

// Usuário digita o nome
signupForm.setFieldValue('name', 'Lucas');
signupForm.setFieldTouched('name');

// Usuário digita um email inválido e sai do campo
signupForm.setFieldValue('email', 'lucas.com');
signupForm.setFieldTouched('email');

// Valida o formulário
signupForm.validate(signupValidationSchema);
console.log(&quot;Estado após validação 1:&quot;, signupForm.errors);
// { email: 'Email inválido', password: 'Senha muito curta' }

// Usuário corrige o email e a senha
signupForm.setFieldValue('email', 'lucas@ts.com');
signupForm.setFieldValue('password', '1234567');

// Valida novamente
signupForm.validate(signupValidationSchema);
console.log(&quot;Estado após validação 2:&quot;, signupForm.errors);
// {}
</code></pre>

</details>

<h3 id="checklist-final">Checklist Final</h3>
<ul>
<li>[ ] Planejei a estrutura de uma classe complexa com tipos genéricos.</li>
<li>[ ] Usei Mapped Types para criar tipos de estado derivados.</li>
<li>[ ] Implementei a lógica de negócio em métodos de classe.</li>
<li>[ ] Usei a classe final para resolver um problema prático.</li>
<li>[ ] Sinto-me confiante para arquitetar aplicações TypeScript intermediárias.</li>
</ul></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '../..';</script>
        <script src="../../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../../assets/js/mkdocs.js"></script>
			<script src="../../search/main.js" defer></script>

</body>

</html>