<!doctype html>
<html lang="en">

<head>
        <title>Semana 1 - Meus Estudos</title>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        
        
        

        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../assets/css/darcula-highlight.min.css">

        <link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="../../assets/css/dracula-ui.min.css">
        <link rel="stylesheet" href="../../assets/css/mkdocs.min.css">

        
            <link  rel="icon" type="image/x-icon" href="../../assets/img/favicon.ico">
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad();</script>

</head>

<body class="drac-bg-black-secondary drac-text-grey-ternary drac-text drac-scrollbar-purple">

    <main class="d-flex">

        <!-- block sidebar -->
            <nav id="sidebar" class="sidebar drac-bg-black">
    <div class="custom-menu">
        <button type="button" id="sidebarCollapse" class="btn btn-primary">
            <i class="fa fa-bars"></i>
            <span class="sr-only">Menu</span>
        </button>
    </div>

    <div class="p-4">
        

        <div class="drac-text-center">
            
                <span class="drac-text drac-line-height drac-text-white">Meus Estudos</span>
            
        </div>

        <div class="drac-box flex-column">
            <ul class="dot-ul">
                <li><div class="dot-li drac-bg-cyan"></div></li>
                <li><div class="dot-li drac-bg-green"></div></li>
                <li><div class="dot-li drac-bg-orange"></div></li>
                <li><div class="dot-li drac-bg-pink"></div></li>
                <li><div class="dot-li drac-bg-purple"></div></li>
                <li><div class="dot-li drac-bg-red"></div></li>
                <li><div class="dot-li drac-bg-yellow"></div></li>
            </ul>
        </div>

        <hr class="drac-divider" />

        <!-- block menu -->
        <ul class="mb-5 drac-list drac-list-none">
            
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
                    Início
                </a>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#requisitos-collapse" aria-expanded="false">
                    Requisitos
                </a>
                <div class="collapse" id="requisitos-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Requisitos/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#lógica-collapse" aria-expanded="false">
                    Lógica
                </a>
                <div class="collapse" id="lógica-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Logica/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Lógica de Programação
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#web-collapse" aria-expanded="false">
                    Web
                </a>
                <div class="collapse" id="web-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../Web/Armazenamento/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Armazenamento Web
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class=" active 
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#typescript-collapse" aria-expanded="false">
                    TypeScript
                </a>
                <div class="collapse" id="typescript-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../estrutura-plano/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Visão Geral
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="./"
            class=" active 
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 1
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana2/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 2
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana3/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 3
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../Semana4/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Semana 4
        </a>
    </li>
                    </ul>
                </div>
            </li>
            <li class="drac-box">
                <a href="../.."
                    class="
                    drac-anchor btn-toggle d-inline-flex align-items-center border-0 drac-text-purple--hover collapsed"
                    data-bs-toggle="collapse" data-bs-target="#mongo-collapse" aria-expanded="false">
                    Mongo
                </a>
                <div class="collapse" id="mongo-collapse">
                    <ul class="mb-5 drac-list drac-list-none">
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/apostila/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Apostila
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/respostas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Respostas
        </a>
    </li>
                            
    <li class="drac-box-ternary">
        <a href="../../MongoDB/tarefas/"
            class="
            drac-anchor d-inline-flex align-items-center border-0 drac-text-purple--hover">
            Tarefas
        </a>
    </li>
                    </ul>
                </div>
            </li>
        </ul>
        <!-- endblock -->
    </div>
</nav>
        <!-- endblock -->

        <nav class="divider drac-bg-purple-cyan"></nav>

        <div class="content">
            <!-- block header -->
                <header>
    <nav class="navbar navbar-expand-xl drac-bg-purple">
        <div class="container-fluid">
            
            <button class="navbar-toggler w-100 text-center" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsMenu"
                aria-controls="navbarsMenu" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse flex-column ml-auto" id="navbarsMenu">
                <ul class="navbar-nav text-md-center">

                    <!-- block preview -->
                    <li class="nav-item">
                            
        <div class="container">
            <div class="row row-preview">
                <div class="col">
                    <a href="../estrutura-plano/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover">
                        <i class="fa fa-arrow-left"></i> Previous
                    </a>
                </div>
                <div class="col">
                    <a href="../Semana2/"
                        class="btn-preview drac-btn drac-btn-outline drac-text-white drac-text-cyan-green--hover" style="padding-left: 3%;">
                        Next <i class="fa fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </div>
                    </li>
                    <!--  endblock -->

                    <!-- block search -->
                    <li class="nav-item"><div role="search" class="search-box">
	<form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
		<input type="text" name="q" class="drac-input drac-input-search drac-input-white drac-text-white drac-bg-black-secondary"
		placeholder="Search docs" title="Type search term here" />
	</form>
</div>
                    </li>
                    <!--  endblock -->

                    <!-- block source -->
                    <li class="nav-item">
                        
                    </li>
                    <!--  endblock -->

                </ul>
            </div>

        </div>
    </nav>
</header>
            <!-- endblock -->

            <!-- block content -->
                <section class="p-md-5 section-content">
    <article>
        <p><h1 id="semana-1-fundamentos-criticos-e-classes">Semana 1: Fundamentos Críticos e Classes</h1>
<h2 id="visao-geral-da-semana">Visão Geral da Semana</h2>
<p>Nesta primeira semana, nosso objetivo é construir uma base sólida em TypeScript. Vamos focar em dominar o sistema de classes, entender o comportamento do <code>this</code> e, crucialmente, começar a jornada para eliminar o <code>any</code> do nosso código, substituindo-o por padrões de tipagem seguros e robustos como <code>unknown</code> e type guards. Ao final da semana, você terá as ferramentas para construir componentes encapsulados e reutilizáveis.</p>
<hr />
<h2 id="dia-1-classes-fundamentais">Dia 1: Classes Fundamentais</h2>
<h3 id="foco-do-dia">Foco do Dia</h3>
<p>Construir e entender a estrutura de classes em TypeScript, incluindo como inicializar, controlar o acesso a propriedades e definir o comportamento através de métodos.</p>
<h3 id="leitura-e-teoria-aprofundada">Leitura e Teoria (Aprofundada)</h3>
<p>Classes são um dos pilares da programação orientada a objetos. Elas são "plantas" para criar objetos.</p>
<ul>
<li><strong>Propriedades (Properties)</strong>: São as variáveis de uma classe. Elas definem o estado de um objeto.</li>
<li><strong>Métodos (Methods)</strong>: São as funções de uma classe. Eles definem o comportamento de um objeto.</li>
<li><strong>Construtor (Constructor)</strong>: Um método especial para criar e inicializar um objeto. Ele é chamado automaticamente quando usamos a palavra-chave <code>new</code>.</li>
<li><strong>Modificadores de Acesso (Access Modifiers)</strong>:</li>
<li><code>public</code>: (padrão) A propriedade ou método pode ser acessado de qualquer lugar.</li>
<li><code>private</code>: A propriedade ou método só pode ser acessado de <strong>dentro da própria classe</strong>. Isso é chamado de <strong>encapsulamento</strong> e é crucial para proteger os dados e esconder a complexidade.</li>
<li><code>protected</code>: Pode ser acessado de dentro da classe e de classes que a herdam (<code>extends</code>). Veremos mais sobre herança na Semana 2.</li>
<li><strong><code>readonly</code></strong>: Uma propriedade marcada como <code>readonly</code> só pode receber um valor durante a sua declaração ou dentro do construtor. Garante <strong>imutabilidade</strong> após a criação do objeto.</li>
<li><strong>Parameter Properties</strong>: Um atalho do TypeScript para declarar e inicializar propriedades diretamente nos parâmetros do construtor.</li>
</ul>
<h3 id="documentacao-essencial">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html">Classes (TypeScript Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties">Parameter Properties (TypeScript Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Classe Básica</strong></p>
<pre><code class="language-typescript">class Player {
  // Propriedade pública, acessível de qualquer lugar
  health: number = 100;

  // Método público
  attack() {
    console.log(&quot;O jogador ataca!&quot;);
  }
}

const player1 = new Player();
console.log(player1.health); // 100
player1.attack(); // &quot;O jogador ataca!&quot;
</code></pre>
<p><strong>Exemplo 2: Encapsulamento com <code>private</code> e <code>readonly</code></strong></p>
<pre><code class="language-typescript">class BankAccount {
  public readonly accountNumber: string;
  private balance: number;

  constructor(accountNumber: string, initialBalance: number) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
  }

  // Método público para acessar um dado privado de forma controlada
  public getBalance(): number {
    // Aqui poderíamos adicionar lógica de permissão, por exemplo
    return this.balance;
  }

  // Método público para modificar um dado privado
  public deposit(amount: number): void {
    if (amount &gt; 0) {
      this.balance += amount;
    }
  }
}

const myAccount = new BankAccount(&quot;12345-6&quot;, 500);
// myAccount.balance = 10000; // Erro: 'balance' é privado.
// myAccount.accountNumber = &quot;98765-4&quot;; // Erro: 'accountNumber' é readonly.
myAccount.deposit(150);
console.log(myAccount.getBalance()); // 650
</code></pre>
<p><strong>Exemplo 3: Atalho com Parameter Properties</strong></p>
<pre><code class="language-typescript">class Car {
  // Declara e inicializa as propriedades diretamente no construtor
  constructor(
    public readonly model: string,
    private year: number
  ) {}

  public getCarInfo(): string {
    return `Carro: ${this.model}, Ano: ${this.year}`;
  }
}

const myCar = new Car(&quot;Fusca&quot;, 1978);
console.log(myCar.model); // &quot;Fusca&quot;
console.log(myCar.getCarInfo()); // &quot;Carro: Fusca, Ano: 1978&quot;
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe <code>Rectangle</code> com propriedades <code>width</code> e <code>height</code> (ambas <code>public</code> e do tipo <code>number</code>). Adicione um método <code>getArea()</code> que retorna a área do retângulo (<code>width * height</code>).</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class Rectangle {
  public width: number;
  public height: number;

  constructor(width: number, height: number) {
    this.width = width;
    this.height = height;
  }

  public getArea(): number {
    return this.width * this.height;
  }
}

// Teste
const rect = new Rectangle(10, 20);
console.log(rect.getArea()); // 200
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe <code>Product</code> com propriedades <code>name</code> (string) e <code>price</code> (number), ambas <code>private</code>. Use <em>parameter properties</em>. Adicione um método público <code>getPrice()</code> para ler o preço e um método <code>setPrice(newPrice: number)</code> que só permite a alteração se o <code>newPrice</code> for maior que zero.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class Product {
  constructor(
    private name: string,
    private price: number
  ) {}

  public getPrice(): number {
    return this.price;
  }

  public setPrice(newPrice: number): void {
    if (newPrice &gt; 0) {
      this.price = newPrice;
      console.log(`O preço de ${this.name} foi atualizado para ${newPrice}.`);
    } else {
      console.log(&quot;Preço inválido. O valor deve ser maior que zero.&quot;);
    }
  }
}

// Teste
const book = new Product(&quot;O Senhor dos Anéis&quot;, 50);
console.log(book.getPrice()); // 50
book.setPrice(65);
console.log(book.getPrice()); // 65
book.setPrice(-10); // &quot;Preço inválido...&quot;
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Implemente a classe <code>DatabaseConnection</code> que simula o padrão de <em>constructor overloading</em>. A classe deve poder ser instanciada de duas formas:
1.  <code>new DatabaseConnection(url: string)</code>
2.  <code>new DatabaseConnection(host: string, port: number, database: string)</code>
O construtor deve ter uma única implementação que verifica os argumentos recebidos e monta a <code>connectionString</code> interna de acordo.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class DatabaseConnection {
  private connectionString: string;

  // Assinatura de sobrecarga 1
  constructor(url: string);
  // Assinatura de sobrecarga 2
  constructor(host: string, port: number, database: string);
  // Implementação real do construtor
  constructor(arg1: string, arg2?: number, arg3?: string) {
    // Verifica se os argumentos correspondem à segunda assinatura
    if (typeof arg2 === 'number' &amp;&amp; typeof arg3 === 'string') {
      const host = arg1;
      const port = arg2;
      const database = arg3;
      this.connectionString = `mongodb://${host}:${port}/${database}`;
    } else {
      // Caso contrário, trata como a primeira assinatura
      const url = arg1;
      this.connectionString = url;
    }
  }

  public connect(): void {
    console.log(`Conectando a: ${this.connectionString}`);
  }
}

// Teste
const connFromUrl = new DatabaseConnection('mysql://user:pass@server/db');
connFromUrl.connect(); // &quot;Conectando a: mysql://user:pass@server/db&quot;

const connFromParts = new DatabaseConnection('localhost', 5432, 'postgres');
connFromParts.connect(); // &quot;Conectando a: postgresql://localhost:5432/postgres&quot;
</code></pre>

</details>

<h3 id="checklist-do-dia">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi a diferença entre <code>public</code> e <code>private</code>.</li>
<li>[ ] Sei por que <code>readonly</code> é útil para imutabilidade.</li>
<li>[ ] Usei o atalho de <em>parameter properties</em>.</li>
<li>[ ] Implementei o padrão de "overload" de construtor em TypeScript.</li>
</ul>
<hr />
<h2 id="dia-2-contexto-do-this-parte-1">Dia 2: Contexto do <code>this</code> - Parte 1</h2>
<h3 id="foco-do-dia_1">Foco do Dia</h3>
<p>Entender como o <code>this</code> funciona em JavaScript/TypeScript e como garantir que ele se refira ao contexto correto, especialmente em callbacks e métodos encadeados.</p>
<h3 id="leitura-e-teoria-aprofundada_1">Leitura e Teoria (Aprofundada)</h3>
<p>O <code>this</code> é uma das fontes mais comuns de bugs em JavaScript. Seu valor é determinado por <strong>como a função é chamada (call-site)</strong>, não onde ela é definida.</p>
<ul>
<li>
<p><strong>Função Regular (<code>function() {}</code> ou <code>metodo() {}</code>)</strong>: O <code>this</code> é dinâmico. Se a função é chamada como <code>obj.metodo()</code>, <code>this</code> é <code>obj</code>. Se a função é simplesmente chamada (<code>funcao()</code>), <code>this</code> é <code>undefined</code> (em 'strict mode', o padrão em módulos e classes) ou o objeto global (<code>window</code> no browser).</p>
</li>
<li>
<p><strong>Arrow Function (<code>() =&gt; {}</code>)</strong>: O <code>this</code> é estático (léxico). Ela <strong>não possui seu próprio <code>this</code></strong>. Ela "herda" o <code>this</code> do escopo onde foi <strong>definida</strong>. Dentro de um método de classe definido como arrow function, <code>this</code> <strong>sempre</strong> se referirá à instância da classe.</p>
</li>
</ul>
<h3 id="documentacao-essencial_1">Documentação Essencial</h3>
<ul>
<li><a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Operators/this">O <code>this</code> em JavaScript (MDN)</a> - Essencial para entender a base.</li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html#this-types">This Types (TypeScript Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_1">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: O Problema - Perdendo o <code>this</code></strong></p>
<pre><code class="language-typescript">class Greeter {
  prefix = &quot;Hello, &quot;;

  // Método de classe normal
  greet(name: string) {
    console.log(this.prefix + name);
  }
}

const greeter = new Greeter();
const greetFunction = greeter.greet; // A função é extraída do objeto

// greetFunction(&quot;Mundo&quot;); // Crash! `this` é undefined aqui.
</code></pre>
<p><strong>Exemplo 2: A Solução - Arrow Function como Método</strong></p>
<pre><code class="language-typescript">class SafeGreeter {
  prefix = &quot;Hello, &quot;;

  // O método é uma propriedade que contém uma arrow function
  // A arrow function &quot;lembra&quot; do `this` de onde foi criada
  greet = (name: string) =&gt; {
    console.log(this.prefix + name);
  }
}

const safeGreeter = new SafeGreeter();
const safeGreetFunction = safeGreeter.greet;

safeGreetFunction(&quot;Mundo&quot;); // Funciona! &quot;Hello, Mundo&quot;
</code></pre>
<p><strong>Exemplo 3: Method Chaining com o tipo <code>this</code></strong></p>
<pre><code class="language-typescript">class StringBuilder {
  private parts: string[] = [];

  add(part: string): this {
    this.parts.push(part);
    return this; // Retornar `this` permite o encadeamento
  }

  build(): string {
    return this.parts.join(&quot;&quot;);
  }
}

const builder = new StringBuilder();
const result = builder.add(&quot;Hello, &quot;).add(&quot;World!&quot;).build();
console.log(result); // &quot;Hello, World!&quot;
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_1">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe <code>Logger</code> com uma propriedade <code>message</code>. Crie um método <code>printMessage()</code>. Chame este método dentro de um <code>setTimeout</code> e observe o erro. Em seguida, corrija o problema para que a mensagem seja impressa corretamente após 1 segundo.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class Logger {
  constructor(private message: string = &quot;Operação concluída!&quot;) {}

  // A solução é definir o método como uma arrow function
  printMessage = () =&gt; {
    console.log(this.message);
  }

  public schedulePrint(): void {
    console.log(&quot;Agendando impressão...&quot;);
    setTimeout(this.printMessage, 1000);
  }
}

// Teste
const logger = new Logger();
logger.schedulePrint(); // Após 1s: &quot;Operação concluída!&quot;
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe <code>Calculator</code> com uma propriedade <code>value</code> (number, private, inicia em 0). Crie os métodos <code>add(num: number)</code>, <code>subtract(num: number)</code> e <code>multiply(num: number)</code>. Cada um desses métodos deve modificar o <code>value</code> e retornar <code>this</code> para permitir o encadeamento de chamadas.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class Calculator {
  private value: number = 0;

  constructor(initialValue: number = 0) {
    this.value = initialValue;
  }

  add(num: number): this {
    this.value += num;
    return this;
  }

  subtract(num: number): this {
    this.value -= num;
    return this;
  }

  multiply(num: number): this {
    this.value *= num;
    return this;
  }

  getResult(): number {
    return this.value;
  }
}

// Teste
const calc = new Calculator(10);
const result = calc.add(5).subtract(3).multiply(2).getResult(); // (10 + 5 - 3) * 2 = 24
console.log(result); // 24
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie uma classe <code>DOMManager</code>. Ela deve ter um método <code>createElement(tag: string, text: string)</code> que cria um elemento (simulado por um objeto <code>{tag, text}</code>) e o armazena em um array <code>private elements</code>. Crie um método <code>render(containerId: string)</code> que deveria (em um cenário real) adicionar os elementos a um contêiner do DOM. O método <code>render</code> deve ser chamado por um objeto externo, simulando um event listener, então você precisa garantir que o <code>this</code> dentro de <code>render</code> ainda se refira à instância de <code>DOMManager</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface Element {
  tag: string;
  text: string;
}

class DOMManager {
  private elements: Element[] = [];

  public createElement(tag: string, text: string): this {
    this.elements.push({ tag, text });
    return this;
  }

  // Definido como arrow function para garantir o `this` léxico
  public render = (containerId: string) =&gt; {
    // Em um app real, faríamos: const container = document.getElementById(containerId);
    console.log(`Renderizando ${this.elements.length} elementos em #${containerId}`);
    for (const el of this.elements) {
      console.log(`  &lt;${el.tag}&gt;${el.text}&lt;/${el.tag}&gt;`);
    }
  }
}

// Teste
const manager = new DOMManager();
manager.createElement(&quot;h1&quot;, &quot;Título Principal&quot;).createElement(&quot;p&quot;, &quot;Este é um parágrafo.&quot;);

// Simulando um sistema de eventos que pega a função e a chama depois
const eventSystem = {
  listeners: {} as Record&lt;string, () =&gt; void&gt;,
  addEventListener: function(eventName: string, callback: () =&gt; void) {
    this.listeners[eventName] = callback;
  },
  trigger: function(eventName: string) {
    this.listeners[eventName]();
  }
};

// Passamos o método `render` como callback. Graças à arrow function, o `this` funciona.
eventSystem.addEventListener(&quot;renderPage&quot;, () =&gt; manager.render(&quot;app-root&quot;));
eventSystem.trigger(&quot;renderPage&quot;);
</code></pre>

</details>

<h3 id="checklist-do-dia_1">Checklist do Dia</h3>
<ul>
<li>[ ] Sei explicar a diferença de <code>this</code> entre <code>function()</code> e <code>() =&gt; {}</code>.</li>
<li>[ ] Consigo resolver um problema de <code>this</code> perdido em um callback.</li>
<li>[ ] Entendi como <code>return this;</code> permite o encadeamento de métodos.</li>
<li>[ ] Implementei uma classe com uma API fluente.</li>
</ul>
<hr />
<h2 id="dia-3-eliminando-any-parte-1">Dia 3: Eliminando <code>any</code> - Parte 1</h2>
<h3 id="foco-do-dia_2">Foco do Dia</h3>
<p>Abandonar o <code>any</code> e adotar <code>unknown</code> como a alternativa segura para tipos desconhecidos, forçando a verificação de tipos antes do uso.</p>
<h3 id="leitura-e-teoria-aprofundada_2">Leitura e Teoria (Aprofundada)</h3>
<ul>
<li>
<p><strong><code>any</code></strong>: É a "válvula de escape" do TypeScript. Uma variável do tipo <code>any</code> <strong>desliga completamente a verificação de tipos</strong>. Você pode chamar qualquer método, acessar qualquer propriedade, e o compilador não vai reclamar. Isso é perigoso e anula o propósito de usar TypeScript.</p>
</li>
<li>
<p><strong><code>unknown</code></strong>: É a alternativa segura. Uma variável <code>unknown</code> também pode receber qualquer valor, mas você <strong>não pode fazer nada</strong> com ela sem antes <strong>provar</strong> ao TypeScript qual é o seu tipo. Esse processo de prova é chamado de <em>narrowing</em> (estreitamento).</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align: left;">Característica</th>
<th style="text-align: left;"><code>any</code></th>
<th style="text-align: left;"><code>unknown</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Atribuição</strong></td>
<td style="text-align: left;">Pode receber qualquer valor</td>
<td style="text-align: left;">Pode receber qualquer valor</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Operações</strong></td>
<td style="text-align: left;">Permite qualquer operação</td>
<td style="text-align: left;"><strong>Não permite nenhuma operação</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Segurança</strong></td>
<td style="text-align: left;">Baixa</td>
<td style="text-align: left;">Alta</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Necessidade</strong></td>
<td style="text-align: left;">Nenhuma verificação</td>
<td style="text-align: left;"><strong>Requer verificação de tipo</strong></td>
</tr>
</tbody>
</table>
<h3 id="documentacao-essencial_2">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#unknown">The <code>unknown</code> Type (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#any">The <code>any</code> Type (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_2">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: O Perigo do <code>any</code></strong></p>
<pre><code class="language-typescript">let value: any = &quot;isto é uma string&quot;;
// Nenhuma verificação do compilador!
value.toFixed(2); // Crash em tempo de execução: value.toFixed is not a function
</code></pre>
<p><strong>Exemplo 2: A Segurança do <code>unknown</code></strong></p>
<pre><code class="language-typescript">let safeValue: unknown = &quot;isto é uma string&quot;;
// Erro de compilação! O TS nos protege.
// safeValue.toFixed(2); // Object is of type 'unknown'.
</code></pre>
<p><strong>Exemplo 3: Usando <code>unknown</code> Corretamente com Verificação</strong></p>
<pre><code class="language-typescript">let anotherSafeValue: unknown = 123.456;

if (typeof anotherSafeValue === 'number') {
  // Dentro deste bloco, o TS sabe que anotherSafeValue é um número
  console.log(anotherSafeValue.toFixed(2)); // &quot;123.46&quot;
}
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_2">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma função <code>logString(value: unknown)</code> que verifica se o valor recebido é uma <code>string</code>. Se for, ela o imprime no console. Se não for, ela imprime a mensagem "Valor não é uma string".</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">function logString(value: unknown): void {
  if (typeof value === 'string') {
    console.log(value);
  } else {
    console.log(&quot;Valor não é uma string.&quot;);
  }
}

// Teste
logString(&quot;Olá, TypeScript!&quot;); // &quot;Olá, TypeScript!&quot;
logString(123); // &quot;Valor não é uma string.&quot;
logString({}); // &quot;Valor não é uma string.&quot;
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma função <code>getDouble(value: unknown): number | null</code> que verifica se o valor é um <code>number</code>. Se for, a função deve retornar o dobro do valor. Caso contrário, deve retornar <code>null</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">function getDouble(value: unknown): number | null {
  if (typeof value === 'number') {
    return value * 2;
  }
  return null;
}

// Teste
console.log(getDouble(10)); // 20
console.log(getDouble(&quot;20&quot;)); // null
console.log(getDouble(null)); // null
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie uma função <code>safeJsonParse(json: string): unknown | Error</code>. Esta função deve receber uma string JSON, tentar fazer o parse com <code>JSON.parse</code>. Se for bem-sucedido, deve retornar o objeto parseado (como <code>unknown</code>). Se ocorrer um erro no parse, ela deve capturar a exceção e retornar um objeto <code>Error</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">function safeJsonParse(json: string): unknown | Error {
  try {
    // JSON.parse por padrão retorna `any`, mas nós o atribuímos a `unknown`
    // para forçar quem chama a função a verificar o tipo do resultado.
    const parsed: unknown = JSON.parse(json);
    return parsed;
  } catch (e) {
    if (e instanceof Error) {
      return e;
    }
    return new Error(&quot;Falha desconhecida ao analisar JSON.&quot;);
  }
}

// Teste
const validJson = '{&quot;name&quot;: &quot;Lucas&quot;, &quot;id&quot;: 1}';
const invalidJson = '{'name': &quot;Lucas&quot;}'; // JSON malformado

const result1 = safeJsonParse(validJson);
const result2 = safeJsonParse(invalidJson);

if (result1 instanceof Error) {
  console.error(&quot;Erro no JSON válido:&quot;, result1.message);
} else {
  console.log(&quot;Sucesso no JSON válido:&quot;, result1);
}

if (result2 instanceof Error) {
  console.error(&quot;Erro no JSON inválido:&quot;, result2.message);
} else {
  console.log(&quot;Sucesso no JSON inválido:&quot;, result2);
}
</code></pre>

</details>

<h3 id="checklist-do-dia_2">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi por que <code>any</code> é perigoso e deve ser evitado.</li>
<li>[ ] Sei a diferença fundamental entre <code>any</code> e <code>unknown</code>.</li>
<li>[ ] Usei <code>typeof</code> para fazer <em>narrowing</em> de um tipo <code>unknown</code>.</li>
<li>[ ] Implementei uma função que lida com dados de tipo desconhecido de forma segura.</li>
</ul>
<hr />
<h2 id="dia-4-type-guards-e-narrowing">Dia 4: Type Guards e Narrowing</h2>
<h3 id="foco-do-dia_3">Foco do Dia</h3>
<p>Aprender as técnicas de <em>narrowing</em> (estreitamento de tipo) para que o TypeScript possa inferir um tipo mais específico dentro de um bloco de código, e criar seus próprios <code>type guards</code> customizados.</p>
<h3 id="leitura-e-teoria-aprofundada_3">Leitura e Teoria (Aprofundada)</h3>
<p><em>Narrowing</em> é o processo pelo qual o TypeScript remove tipos de uma união. Se você tem <code>string | number</code>, e o TS prova que é <code>string</code>, ele "estreita" o tipo para apenas <code>string</code> naquele escopo.</p>
<p><strong>Técnicas de Narrowing:</strong>
1.  <strong><code>typeof</code></strong>: Para tipos primitivos (<code>string</code>, <code>number</code>, <code>boolean</code>, etc.).
2.  <strong><code>instanceof</code></strong>: Para verificar se um objeto é uma instância de uma classe.
3.  <strong>Truthiness</strong>: Verificar se um valor não é <code>null</code>, <code>undefined</code>, <code>false</code>, <code>0</code>, <code>""</code>.
4.  <strong>Equality (<code>===</code>)</strong>: Verificar igualdade com um valor literal.
5.  <strong><code>in</code> operator</strong>: Verificar se um objeto possui uma propriedade com um certo nome.
6.  <strong>Discriminated Unions</strong>: Um padrão poderoso onde você usa uma propriedade literal comum (<code>kind</code>, <code>type</code>, <code>status</code>) em vários tipos para ajudar o TypeScript a descobrir qual tipo é.
7.  <strong>Custom Type Guards (Type Predicates)</strong>: Funções que retornam um booleano especial: <code>parametro is Tipo</code>. Se a função retornar <code>true</code>, o TypeScript "confia" que o parâmetro é daquele <code>Tipo</code> no resto do escopo.</p>
<h3 id="documentacao-essencial_3">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">Narrowing (Handbook)</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">Using Type Predicates (Custom Type Guards)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_3">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: <code>typeof</code></strong></p>
<pre><code class="language-typescript">function padLeft(padding: number | string, input: string): string {
  if (typeof padding === &quot;number&quot;) {
    return &quot; &quot;.repeat(padding) + input;
  }
  return padding + input;
}
</code></pre>
<p><strong>Exemplo 2: <code>instanceof</code></strong></p>
<pre><code class="language-typescript">class Cat { meow() { console.log(&quot;Meow!&quot;); } }
class Dog { bark() { console.log(&quot;Woof!&quot;); } }
type Pet = Cat | Dog;

function makeSound(pet: Pet) {
  if (pet instanceof Cat) {
    pet.meow(); // O TS sabe que `pet` é um Cat aqui
  }
}
</code></pre>
<p><strong>Exemplo 3: <code>in</code> operator</strong></p>
<pre><code class="language-typescript">interface Movie { title: string; duration: number; }
interface TVShow { title: string; seasons: number; }
type Media = Movie | TVShow;

function getMediaTitle(media: Media) {
  if ('duration' in media) {
    return `Filme: ${media.title}`;
  }
  // O TS sabe que se não tem 'duration', deve ter 'seasons'
  return `Série: ${media.title}`;
}
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_3">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma função <code>formatInput(input: string | string[])</code>. Se o <code>input</code> for uma <code>string</code>, retorne a própria string. Se for um array de strings, retorne as strings unidas por um espaço. Use o type guard <code>Array.isArray()</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">function formatInput(input: string | string[]): string {
  if (Array.isArray(input)) {
    // O TS sabe que `input` é string[] aqui
    return input.join(' ');
  }
  // O TS sabe que `input` é string aqui
  return input;
}

// Teste
console.log(formatInput(&quot;hello&quot;)); // &quot;hello&quot;
console.log(formatInput([&quot;hello&quot;, &quot;world&quot;])); // &quot;hello world&quot;
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Defina duas interfaces: <code>Fish</code> com um método <code>swim()</code> e <code>Bird</code> com um método <code>fly()</code>. Crie uma função <code>makePetMove(pet: Fish | Bird)</code>. Dentro dela, use um <strong>custom type guard</strong> <code>isFish(pet): pet is Fish</code> para verificar o tipo do animal e chamar o método correto (<code>swim</code> ou <code>fly</code>).</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface Fish {
  swim: () =&gt; void;
}

interface Bird {
  fly: () =&gt; void;
}

type Animal = Fish | Bird;

// Custom type guard
function isFish(pet: Animal): pet is Fish {
  // Se o pet tem a propriedade 'swim', então ele é um Fish.
  // A asserção `(pet as Fish)` é necessária para checar a propriedade
  // que pode não existir no tipo Animal.
  return (pet as Fish).swim !== undefined;
}

function makePetMove(pet: Animal) {
  if (isFish(pet)) {
    pet.swim();
  } else {
    pet.fly();
  }
}

// Teste
const nemo: Fish = { swim: () =&gt; console.log(&quot;Nemo está nadando.&quot;) };
const zazu: Bird = { fly: () =&gt; console.log(&quot;Zazu está voando.&quot;) };

makePetMove(nemo);
makePetMove(zazu);
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Implemente o padrão <em>Discriminated Union</em>. Crie duas interfaces, <code>SuccessResponse</code> e <code>ErrorResponse</code>. Ambas devem ter uma propriedade <code>status</code>, mas com valores literais diferentes (<code>'success'</code> e <code>'error'</code>). Crie uma função <code>handleApiResponse(response: ApiResponse)</code> que usa a propriedade <code>status</code> para identificar o tipo da resposta e logar os dados ou a mensagem de erro apropriada.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface SuccessResponse {
  status: 'success'; // Propriedade discriminante
  data: { id: number; name: string };
}

interface ErrorResponse {
  status: 'error'; // Propriedade discriminante
  error: { code: number; message: string };
}

type ApiResponse = SuccessResponse | ErrorResponse;

function handleApiResponse(response: ApiResponse) {
  // Usando um switch na propriedade discriminante
  switch (response.status) {
    case 'success':
      // O TS sabe que `response` é SuccessResponse aqui
      console.log(&quot;Dados recebidos:&quot;, response.data.name);
      break;
    case 'error':
      // O TS sabe que `response` é ErrorResponse aqui
      console.error(&quot;Ocorreu um erro:&quot;, response.error.message);
      break;
  }
}

// Teste
const success: ApiResponse = { status: 'success', data: { id: 1, name: 'Produto A' } };
const failure: ApiResponse = { status: 'error', error: { code: 404, message: 'Produto não encontrado' } };

handleApiResponse(success);
handleApiResponse(failure);
</code></pre>

</details>

<h3 id="checklist-do-dia_3">Checklist do Dia</h3>
<ul>
<li>[ ] Sei usar <code>typeof</code>, <code>instanceof</code> e <code>in</code> para narrowing.</li>
<li>[ ] Entendi o padrão de <em>Discriminated Unions</em>.</li>
<li>[ ] Criei e usei um <em>custom type guard</em> (<code>is Type</code>).</li>
<li>[ ] Apliquei narrowing para acessar propriedades de tipos em uma união de forma segura.</li>
</ul>
<hr />
<h2 id="dia-5-utility-types-nativos-record-e-basicos">Dia 5: Utility Types Nativos - Record e Básicos</h2>
<h3 id="foco-do-dia_4">Foco do Dia</h3>
<p>Utilizar os <code>Utility Types</code> nativos do TypeScript para transformar e criar novos tipos a partir de tipos existentes, com foco especial em <code>Record&lt;K,V&gt;</code>.</p>
<h3 id="leitura-e-teoria-aprofundada_4">Leitura e Teoria (Aprofundada)</h3>
<p>Utility Types são ferramentas que ajudam a manipular tipos sem ter que reescrevê-los.</p>
<ul>
<li><strong><code>Record&lt;Keys, Type&gt;</code></strong>: Constrói um tipo de objeto cujas chaves são <code>Keys</code> e os valores são <code>Type</code>. Perfeito para dicionários ou mapeamentos onde as chaves são de um conjunto conhecido.</li>
<li><strong><code>Partial&lt;Type&gt;</code></strong>: Constrói um tipo com todas as propriedades de <code>Type</code> definidas como <strong>opcionais</strong>. Útil para payloads de atualização (<code>update</code>).</li>
<li><strong><code>Required&lt;Type&gt;</code></strong>: O oposto de <code>Partial</code>. Torna todas as propriedades <strong>obrigatórias</strong>.</li>
<li><strong><code>Pick&lt;Type, Keys&gt;</code></strong>: Constrói um tipo "pegando" um conjunto de propriedades <code>Keys</code> de <code>Type</code>.</li>
<li><strong><code>Omit&lt;Type, Keys&gt;</code></strong>: O oposto de <code>Pick</code>. Constrói um tipo com todas as propriedades de <code>Type</code>, <strong>exceto</strong> as <code>Keys</code>.</li>
<li><strong><code>Readonly&lt;Type&gt;</code></strong>: Torna todas as propriedades de <code>Type</code> somente leitura.</li>
</ul>
<h3 id="documentacao-essencial_4">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">Utility Types (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_4">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: <code>Partial</code> para atualizações</strong></p>
<pre><code class="language-typescript">interface User { name: string; age: number; email: string; }
function updateUser(user: User, fieldsToUpdate: Partial&lt;User&gt;) {
  return { ...user, ...fieldsToUpdate };
}
const user1 = { name: 'Lucas', age: 30, email: 'lucas@test.com' };
const updatedUser = updateUser(user1, { age: 31 });
</code></pre>
<p><strong>Exemplo 2: <code>Pick</code> para dados públicos</strong></p>
<pre><code class="language-typescript">interface UserWithPassword { id: number; name: string; passwordHash: string; }
type PublicUser = Pick&lt;UserWithPassword, 'id' | 'name'&gt;;
const publicProfile: PublicUser = { id: 1, name: 'Ana' };
</code></pre>
<p><strong>Exemplo 3: <code>Omit</code> para remover dados sensíveis</strong></p>
<pre><code class="language-typescript">type UserWithoutPassword = Omit&lt;UserWithPassword, 'passwordHash'&gt;;
const userToSend: UserWithoutPassword = { id: 2, name: 'Beto' };
</code></pre>
<p><strong>Exemplo 4: <code>Record</code> para um dicionário de configurações</strong></p>
<pre><code class="language-typescript">type Theme = 'light' | 'dark';
interface ThemeSettings { color: string; background: string; }
const themes: Record&lt;Theme, ThemeSettings&gt; = {
  light: { color: '#000', background: '#fff' },
  dark: { color: '#fff', background: '#000' },
};
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_4">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Dada a interface <code>Book { id: number; title: string; author: string; pages: number; }</code>, crie um tipo <code>BookPreview</code> que contenha apenas as propriedades <code>title</code> e <code>author</code> usando um Utility Type.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface Book {
  id: number;
  title: string;
  author: string;
  pages: number;
}

type BookPreview = Pick&lt;Book, 'title' | 'author'&gt;;

// Teste
const preview: BookPreview = {
  title: &quot;Duna&quot;,
  author: &quot;Frank Herbert&quot;
};
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma interface <code>AppSettings</code> com todas as propriedades opcionais: <code>theme: string</code>, <code>fontSize: number</code>, <code>language: string</code>. Em seguida, crie um tipo <code>RequiredAppSettings</code> que tenha todas essas mesmas propriedades, mas como obrigatórias. Por fim, crie uma função <code>applySettings(settings: RequiredAppSettings)</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">interface AppSettings {
  theme?: string;
  fontSize?: number;
  language?: string;
}

type RequiredAppSettings = Required&lt;AppSettings&gt;;

function applySettings(settings: RequiredAppSettings) {
  console.log(&quot;Aplicando configurações:&quot;, settings);
}

// Teste
const mySettings: RequiredAppSettings = {
  theme: 'dark',
  fontSize: 14,
  language: 'pt-BR'
};

applySettings(mySettings);

// const invalidSettings: RequiredAppSettings = { theme: 'light' }; // Erro: fontSize e language estão faltando
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um <code>enum</code> chamado <code>UserRole</code> com os valores <code>ADMIN</code>, <code>EDITOR</code>, e <code>VIEWER</code>. Crie um tipo <code>Permissions</code> que define o que cada papel pode fazer (ex: <code>{ canWrite: boolean; canRead: boolean; }</code>). Use o Utility Type <code>Record</code> para criar um objeto <code>rolePermissions</code> que mapeia cada <code>UserRole</code> para seu respectivo objeto <code>Permissions</code> de forma type-safe.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">enum UserRole {
  ADMIN = 'admin',
  EDITOR = 'editor',
  VIEWER = 'viewer'
}

interface Permissions {
  canWrite: boolean;
  canRead: boolean;
  canDelete: boolean;
}

const rolePermissions: Record&lt;UserRole, Permissions&gt; = {
  [UserRole.ADMIN]: { canWrite: true, canRead: true, canDelete: true },
  [UserRole.EDITOR]: { canWrite: true, canRead: true, canDelete: false },
  [UserRole.VIEWER]: { canWrite: false, canRead: true, canDelete: false },
};

// Teste
function checkPermissions(role: UserRole) {
  const permissions = rolePermissions[role];
  console.log(`Permissões para ${role.toUpperCase()}:`, permissions);
}

checkPermissions(UserRole.EDITOR);
// checkPermissions('guest'); // Erro: Argument of type '&quot;guest&quot;' is not assignable to parameter of type 'UserRole'.
</code></pre>

</details>

<h3 id="checklist-do-dia_4">Checklist do Dia</h3>
<ul>
<li>[ ] Entendi o propósito do <code>Record&lt;K, V&gt;</code>.</li>
<li>[ ] Usei <code>Record</code> para criar um dicionário type-safe.</li>
<li>[ ] Sei a diferença entre <code>Pick</code> e <code>Omit</code>.</li>
<li>[ ] Combinei <code>Partial</code> e <code>Required</code> para manipular tipos.</li>
</ul>
<hr />
<h2 id="dia-6-template-literal-types">Dia 6: Template Literal Types</h2>
<h3 id="foco-do-dia_5">Foco do Dia</h3>
<p>Criar tipos de string altamente específicos e dinâmicos usando Template Literals, permitindo validação de formatos de string em tempo de compilação.</p>
<h3 id="leitura-e-teoria-aprofundada_5">Leitura e Teoria (Aprofundada)</h3>
<p>Template Literal Types usam a mesma sintaxe de template strings do JavaScript (<code>${}</code>), mas no nível dos tipos. Eles permitem construir novos tipos de string concatenando outros tipos, especialmente uniões.</p>
<p><strong>Com Unions (o superpoder):</strong></p>
<pre><code class="language-typescript">type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type ApiEndpoint = 'users' | 'products';

// Gera uma união de todas as 8 combinações possíveis:
// &quot;GET /api/users&quot; | &quot;POST /api/users&quot; | ...
type ApiRequestSignature = `${HttpMethod} /api/${ApiEndpoint}`;
</code></pre>
<p><strong>Com Helpers de Manipulação de String:</strong>
TypeScript inclui tipos utilitários para manipular strings dentro dos tipos: <code>Uppercase&lt;S&gt;</code>, <code>Lowercase&lt;S&gt;</code>, <code>Capitalize&lt;S&gt;</code>, <code>Uncapitalize&lt;S&gt;</code>.</p>
<h3 id="documentacao-essencial_5">Documentação Essencial</h3>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html">Template Literal Types (Handbook)</a></li>
</ul>
<h3 id="pratica-guiada-passo-a-passo_5">Prática Guiada (Passo a Passo)</h3>
<p><strong>Exemplo 1: Concatenação Simples</strong></p>
<pre><code class="language-typescript">type World = &quot;World&quot;;
type Greeting = `Hello ${World}`;
const g: Greeting = &quot;Hello World&quot;; // Válido
</code></pre>
<p><strong>Exemplo 2: União de Tipos</strong></p>
<pre><code class="language-typescript">type MarginSide = 'top' | 'right' | 'bottom' | 'left';
type MarginProperty = `margin-${MarginSide}`;
const m: MarginProperty = &quot;margin-left&quot;; // Válido
</code></pre>
<p><strong>Exemplo 3: <code>Capitalize</code> para Nomes de Eventos</strong></p>
<pre><code class="language-typescript">type EventName = 'click' | 'scroll' | 'focus';
type HandlerName = `on${Capitalize&lt;EventName&gt;}`;
const handler: HandlerName = &quot;onClick&quot;; // Válido
</code></pre>
<h3 id="exercicios-praticos-niveis-crescentes_5">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie um tipo <code>Size</code> (<code>'small' | 'medium' | 'large'</code>) e um tipo <code>Color</code> (<code>'red' | 'blue' | 'green'</code>). Crie um terceiro tipo, <code>TShirtSKU</code>, que combine os dois para formar um identificador de produto, como por exemplo <code>'small-red'</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">type Size = 'small' | 'medium' | 'large';
type Color = 'red' | 'blue' | 'green';

type TShirtSKU = `${Size}-${Color}`;

// Teste
const myShirt: TShirtSKU = &quot;medium-blue&quot;;
const anotherShirt: TShirtSKU = &quot;large-red&quot;;
// const invalidShirt: TShirtSKU = &quot;small-yellow&quot;; // Erro: 'yellow' não é uma cor válida
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie um tipo <code>IconName</code> que represente nomes de ícones no formato <code>icon-[nome]</code>, onde <code>[nome]</code> pode ser <code>user</code>, <code>home</code>, ou <code>settings</code>. Em seguida, crie um tipo <code>IconSize</code> que pode ser <code>16</code>, <code>24</code>, ou <code>32</code>. Finalmente, crie um tipo <code>IconId</code> que combine os dois, no formato <code>icon-[nome]-[tamanho]px</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">type IconName = `icon-${'user' | 'home' | 'settings'}`;
type IconSize = 16 | 24 | 32;

type IconId = `${IconName}-${IconSize}px`;

// Teste
const userIcon: IconId = &quot;icon-user-24px&quot;;
const homeIcon: IconId = &quot;icon-home-32px&quot;;
// const invalidIcon: IconId = &quot;icon-settings-20px&quot;; // Erro: 20 não é um tamanho válido
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Crie um tipo <code>ApiRoute</code> que valide os seguintes formatos de rota para uma API RESTful:
1.  Listar todos os recursos: <code>/api/[recurso]</code> (ex: <code>/api/users</code>)
2.  Obter um recurso específico: <code>/api/[recurso]/[id]</code> (ex: <code>/api/posts/123</code>)
Onde <code>[recurso]</code> pode ser <code>users</code>, <code>posts</code>, ou <code>products</code>, e <code>[id]</code> pode ser <code>string</code> ou <code>number</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">type Resource = 'users' | 'posts' | 'products';
type ResourceId = string | number;

type ApiRoute = `/api/${Resource}` | `/api/${Resource}/${ResourceId}`;

// Teste
const listUsers: ApiRoute = '/api/users';
const getPost: ApiRoute = '/api/posts/post-id-abc';
const getProduct: ApiRoute = '/api/products/12345';

// const invalidRoute1: ApiRoute = '/api/orders'; // Erro: 'orders' não é um Resource
// const invalidRoute2: ApiRoute = '/api/users/1/comments'; // Erro: formato inválido
</code></pre>

</details>

<h3 id="checklist-do-dia_5">Checklist do Dia</h3>
<ul>
<li>[ ] Criei um tipo de string simples com template literals.</li>
<li>[ ] Usei uniões para gerar múltiplas strings possíveis a partir de um template.</li>
<li>[ ] Usei <code>Capitalize</code> e outras helpers para transformar strings em tipos.</li>
<li>[ ] Construí um tipo prático para validar um formato de string (rotas de API).</li>
</ul>
<hr />
<h2 id="dia-7-projeto-mini-1-consolidando-conceitos">Dia 7: Projeto Mini #1 - Consolidando Conceitos</h2>
<h3 id="foco-do-dia_6">Foco do Dia</h3>
<p>Consolidar todos os conceitos da semana (Classes, <code>this</code>, <code>unknown</code>, Type Guards, Utility Types) em um único projeto prático: um <code>BaseRepository</code> genérico para operações CRUD em memória.</p>
<h3 id="leitura-e-teoria-revisao">Leitura e Teoria (Revisão)</h3>
<ul>
<li><strong>Classes e Generics (<code>&lt;T&gt;</code>)</strong>: Para criar uma "planta" reutilizável.</li>
<li><strong>Constraints (<code>extends</code>)</strong>: Para garantir que o tipo <code>T</code> tenha as propriedades que precisamos (como <code>id</code>).</li>
<li><strong><code>Record&lt;K, V&gt;</code></strong>: Para criar um armazenamento em memória type-safe.</li>
<li><strong><code>Partial</code> e <code>Omit</code></strong>: Para criar um payload de atualização seguro.</li>
<li><strong>Type Guards</strong>: Para verificar se um item existe antes de realizar uma operação.</li>
</ul>
<h3 id="exercicios-praticos-niveis-crescentes_6">Exercícios Práticos (Níveis Crescentes)</h3>
<p><strong>Nível 1: Básico</strong>
Crie uma classe <code>StringStore</code> <strong>não genérica</strong>. Ela deve ter um array privado para armazenar strings. Implemente dois métodos: <code>add(item: string)</code> e <code>getAll(): string[]</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class StringStore {
  private data: string[] = [];

  public add(item: string): void {
    this.data.push(item);
  }

  public getAll(): string[] {
    return this.data;
  }
}

// Teste
const store = new StringStore();
store.add(&quot;maçã&quot;);
store.add(&quot;banana&quot;);
console.log(store.getAll()); // [&quot;maçã&quot;, &quot;banana&quot;]
</code></pre>

</details>

<p><strong>Nível 2: Intermediário</strong>
Crie uma classe <code>KeyValueStore&lt;V&gt;</code> que seja genérica para o <strong>valor</strong> (<code>V</code>), mas a chave seja sempre <code>string</code>. Use um <code>Record&lt;string, V&gt;</code> para o armazenamento privado. Implemente os métodos <code>set(key: string, value: V)</code> e <code>get(key: string): V | undefined</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">class KeyValueStore&lt;V&gt; {
  private data: Record&lt;string, V&gt; = {};

  public set(key: string, value: V): void {
    this.data[key] = value;
  }

  public get(key: string): V | undefined {
    return this.data[key];
  }
}

// Teste com números
const userAges = new KeyValueStore&lt;number&gt;();
userAges.set(&quot;Lucas&quot;, 30);
userAges.set(&quot;Ana&quot;, 25);
console.log(userAges.get(&quot;Lucas&quot;)); // 30

// Teste com objetos
interface User { id: number; name: string; }
const users = new KeyValueStore&lt;User&gt;();
users.set(&quot;user-1&quot;, { id: 1, name: &quot;Lucas&quot; });
console.log(users.get(&quot;user-1&quot;)); // { id: 1, name: &quot;Lucas&quot; }
</code></pre>

</details>

<p><strong>Nível 3: Avançado</strong>
Implemente a classe <code>BaseRepository&lt;T&gt;</code>. Esta classe deve ser genérica e funcionar para qualquer tipo <code>T</code> que satisfaça a constraint <code>BaseEntity</code> (que possui uma propriedade <code>id</code> do tipo <code>string | number</code>).
<strong>Requisitos:</strong>
1.  Crie a interface <code>BaseEntity { id: string | number; }</code>.
2.  A classe <code>BaseRepository&lt;T extends BaseEntity&gt;</code> deve usar um <code>Record</code> para armazenamento privado.
3.  Implemente os métodos: <code>create(item: T)</code>, <code>findById(id: T['id'])</code>, <code>update(id: T['id'], payload: Partial&lt;Omit&lt;T, 'id'&gt;&gt;)</code>, e <code>delete(id: T['id'])</code>.</p>
<details>
<summary>Ver Solução</summary>


<pre><code class="language-typescript">// A constraint que todas as entidades devem seguir
interface BaseEntity {
  id: string | number;
}

class BaseRepository&lt;T extends BaseEntity&gt; {
  private data: Record&lt;T['id'], T&gt; = {} as Record&lt;T['id'], T&gt;;

  public create(item: T): T {
    this.data[item.id] = item;
    return item;
  }

  public findById(id: T['id']): T | undefined {
    return this.data[id];
  }

  public update(id: T['id'], payload: Partial&lt;Omit&lt;T, 'id'&gt;&gt;): T | undefined {
    const currentItem = this.findById(id);
    if (!currentItem) {
      return undefined;
    }

    const updatedItem = { ...currentItem, ...payload } as T;
    this.data[id] = updatedItem;
    return updatedItem;
  }

  public delete(id: T['id']): boolean {
    if (!this.findById(id)) {
      return false;
    }
    delete this.data[id];
    return true;
  }

  public findAll(): T[] {
    return Object.values(this.data);
  }
}

// Teste
interface Post extends BaseEntity {
  id: string;
  title: string;
  content: string;
}

const postRepository = new BaseRepository&lt;Post&gt;();
postRepository.create({ id: 'post-1', title: &quot;Primeiro Post&quot;, content: &quot;...&quot; });
postRepository.create({ id: 'post-2', title: &quot;Segundo Post&quot;, content: &quot;...&quot; });

postRepository.update('post-1', { title: &quot;Título Atualizado&quot; });
postRepository.delete('post-2');

console.log(postRepository.findAll());
// [ { id: 'post-1', title: 'Título Atualizado', content: '...' } ]
</code></pre>

</details>

<h3 id="checklist-do-dia_6">Checklist do Dia</h3>
<ul>
<li>[ ] Criei uma classe genérica com constraints (<code>extends</code>).</li>
<li>[ ] Usei <code>Record</code> como um armazenamento em memória type-safe.</li>
<li>[ ] Implementei métodos CRUD (Create, Read, Update, Delete).</li>
<li>[ ] Usei <code>Partial</code> e <code>Omit</code> para criar um payload de atualização seguro.</li>
<li>[ ] Sinto-me mais confiante para aplicar os conceitos da Semana 1 em um projeto real.</li>
</ul></p>
    </article>
</section>
            <!-- endblock -->

            <!-- block footer -->
                <footer>
    <div class="d-flex flex-sm-row justify-content-between py-2 border-top drac-text-black drac-bg-cyan-green">
        <a href="https://github.com/dracula/mkdocs" target="_blank" style="padding-left: 1%;"
            class="footer-text drac-anchor drac-text-black drac-text-purple--hover">
            Made with Dracula Theme for MkDocs
        </a>
    </div>
</footer>
            <!-- endblock -->
        </div>

    </main>

        <script>var base_url = '../..';</script>
        <script src="../../assets/js/jquery-3.3.1.slim.min.js"></script>
        <script src="../../assets/js/bootstrap.bundle.min.js"></script>
        <script src="../../assets/js/mkdocs.js"></script>
			<script src="../../search/main.js" defer></script>

</body>

</html>